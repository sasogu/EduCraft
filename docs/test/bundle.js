/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@jpweeks/typedarray-pool/node_modules/is-buffer/index.js":
/*!*******************************************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/@jpweeks/typedarray-pool/node_modules/is-buffer/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/@jpweeks/typedarray-pool/node_modules/is-buffer/index.js?");

/***/ }),

/***/ "../../node_modules/@jpweeks/typedarray-pool/pool.js":
/*!*******************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/@jpweeks/typedarray-pool/pool.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar bits = __webpack_require__(/*! bit-twiddle */ \"../../node_modules/bit-twiddle/twiddle.js\")\nvar dup = __webpack_require__(/*! dup */ \"../../node_modules/dup/dup.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"../../node_modules/@jpweeks/typedarray-pool/node_modules/is-buffer/index.js\")\n\n//Legacy pool support\nif(!global.__TYPEDARRAY_POOL) {\n  global.__TYPEDARRAY_POOL = {\n      UINT8   : dup([32, 0])\n    , UINT16  : dup([32, 0])\n    , UINT32  : dup([32, 0])\n    , INT8    : dup([32, 0])\n    , INT16   : dup([32, 0])\n    , INT32   : dup([32, 0])\n    , FLOAT   : dup([32, 0])\n    , DOUBLE  : dup([32, 0])\n    , DATA    : dup([32, 0])\n    , UINT8C  : dup([32, 0])\n    , BUFFER  : dup([32, 0])\n  }\n}\n\nvar hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'\nvar POOL = global.__TYPEDARRAY_POOL\n\n//Upgrade pool\nif(!POOL.UINT8C) {\n  POOL.UINT8C = dup([32, 0])\n}\nif(!POOL.BUFFER) {\n  POOL.BUFFER = dup([32, 0])\n}\n\n//New technique: Only allocate from ArrayBufferView and Buffer\nvar DATA    = POOL.DATA\n  , BUFFER  = POOL.BUFFER\n\nexports.free = function free(array) {\n  if(isBuffer(array)) {\n    BUFFER[bits.log2(array.length)].push(array)\n  } else {\n    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {\n      array = array.buffer\n    }\n    if(!array) {\n      return\n    }\n    var n = array.length || array.byteLength\n    var log_n = bits.log2(n)|0\n    DATA[log_n].push(array)\n  }\n}\n\nfunction freeArrayBuffer(buffer) {\n  if(!buffer) {\n    return\n  }\n  var n = buffer.length || buffer.byteLength\n  var log_n = bits.log2(n)\n  DATA[log_n].push(buffer)\n}\n\nfunction freeTypedArray(array) {\n  freeArrayBuffer(array.buffer)\n}\n\nexports.freeUint8 =\nexports.freeUint16 =\nexports.freeUint32 =\nexports.freeInt8 =\nexports.freeInt16 =\nexports.freeInt32 =\nexports.freeFloat32 = \nexports.freeFloat =\nexports.freeFloat64 = \nexports.freeDouble = \nexports.freeUint8Clamped = \nexports.freeDataView = freeTypedArray\n\nexports.freeArrayBuffer = freeArrayBuffer\n\nexports.freeBuffer = function freeBuffer(array) {\n  BUFFER[bits.log2(array.length)].push(array)\n}\n\nexports.malloc = function malloc(n, dtype) {\n  if(dtype === undefined || dtype === 'arraybuffer') {\n    return mallocArrayBuffer(n)\n  } else {\n    switch(dtype) {\n      case 'uint8':\n        return mallocUint8(n)\n      case 'uint16':\n        return mallocUint16(n)\n      case 'uint32':\n        return mallocUint32(n)\n      case 'int8':\n        return mallocInt8(n)\n      case 'int16':\n        return mallocInt16(n)\n      case 'int32':\n        return mallocInt32(n)\n      case 'float':\n      case 'float32':\n        return mallocFloat(n)\n      case 'double':\n      case 'float64':\n        return mallocDouble(n)\n      case 'uint8_clamped':\n        return mallocUint8Clamped(n)\n      case 'buffer':\n        throw 'Buffer not supported'\n      case 'data':\n      case 'dataview':\n        return mallocDataView(n)\n\n      default:\n        return null\n    }\n  }\n  return null\n}\n\nfunction mallocArrayBuffer(n) {\n  var n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var d = DATA[log_n]\n  if(d.length > 0) {\n    return d.pop()\n  }\n  return new ArrayBuffer(n)\n}\nexports.mallocArrayBuffer = mallocArrayBuffer\n\nfunction mallocUint8(n) {\n  return new Uint8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocUint8 = mallocUint8\n\nfunction mallocUint16(n) {\n  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocUint16 = mallocUint16\n\nfunction mallocUint32(n) {\n  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocUint32 = mallocUint32\n\nfunction mallocInt8(n) {\n  return new Int8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocInt8 = mallocInt8\n\nfunction mallocInt16(n) {\n  return new Int16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocInt16 = mallocInt16\n\nfunction mallocInt32(n) {\n  return new Int32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocInt32 = mallocInt32\n\nfunction mallocFloat(n) {\n  return new Float32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocFloat32 = exports.mallocFloat = mallocFloat\n\nfunction mallocDouble(n) {\n  return new Float64Array(mallocArrayBuffer(8*n), 0, n)\n}\nexports.mallocFloat64 = exports.mallocDouble = mallocDouble\n\nfunction mallocUint8Clamped(n) {\n  if(hasUint8C) {\n    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)\n  } else {\n    return mallocUint8(n)\n  }\n}\nexports.mallocUint8Clamped = mallocUint8Clamped\n\nfunction mallocDataView(n) {\n  return new DataView(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocDataView = mallocDataView\n\nexports.clearCache = function clearCache() {\n  for(var i=0; i<32; ++i) {\n    POOL.UINT8[i].length = 0\n    POOL.UINT16[i].length = 0\n    POOL.UINT32[i].length = 0\n    POOL.INT8[i].length = 0\n    POOL.INT16[i].length = 0\n    POOL.INT32[i].length = 0\n    POOL.FLOAT[i].length = 0\n    POOL.DOUBLE[i].length = 0\n    POOL.UINT8C[i].length = 0\n    DATA[i].length = 0\n    BUFFER[i].length = 0\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/@jpweeks/typedarray-pool/pool.js?");

/***/ }),

/***/ "../../node_modules/aabb-3d/index.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/aabb-3d/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = AABB\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\nfunction AABB(pos, vec) {\n\n  if(!(this instanceof AABB)) {\n    return new AABB(pos, vec)\n  }\n\n  var pos2 = vec3.create()\n  vec3.add(pos2, pos, vec)\n \n  this.base = vec3.min(vec3.create(), pos, pos2)\n  this.vec = vec3.clone(vec)\n  this.max = vec3.max(vec3.create(), pos, pos2)\n\n  this.mag = vec3.length(this.vec)\n\n}\n\nvar cons = AABB\n  , proto = cons.prototype\n\nproto.width = function() {\n  return this.vec[0]\n}\n\nproto.height = function() {\n  return this.vec[1]\n}\n\nproto.depth = function() {\n  return this.vec[2]\n}\n\nproto.x0 = function() {\n  return this.base[0]\n}\n\nproto.y0 = function() {\n  return this.base[1]\n}\n\nproto.z0 = function() {\n  return this.base[2]\n}\n\nproto.x1 = function() {\n  return this.max[0]\n}\n\nproto.y1 = function() {\n  return this.max[1]\n}\n\nproto.z1 = function() {\n  return this.max[2]\n}\n\nproto.translate = function(by) {\n  vec3.add(this.max, this.max, by)\n  vec3.add(this.base, this.base, by)\n  return this\n}\n\nproto.setPosition = function(pos) {\n  vec3.add(this.max, pos, this.vec)\n  vec3.copy(this.base, pos)\n  return this\n}\n\nproto.expand = function(aabb) {\n  var max = vec3.create()\n    , min = vec3.create()\n\n  vec3.max(max, aabb.max, this.max)\n  vec3.min(min, aabb.base, this.base)\n  vec3.subtract(max, max, min)\n\n  return new AABB(min, max)\n}\n\nproto.intersects = function(aabb) {\n  if(aabb.base[0] > this.max[0]) return false\n  if(aabb.base[1] > this.max[1]) return false\n  if(aabb.base[2] > this.max[2]) return false\n  if(aabb.max[0] < this.base[0]) return false\n  if(aabb.max[1] < this.base[1]) return false\n  if(aabb.max[2] < this.base[2]) return false\n\n  return true\n}\n\nproto.touches = function(aabb) {\n\n  var intersection = this.union(aabb);\n\n  return (intersection !== null) &&\n         ((intersection.width() == 0) ||\n         (intersection.height() == 0) || \n         (intersection.depth() == 0))\n\n}\n\nproto.union = function(aabb) {\n  if(!this.intersects(aabb)) return null\n\n  var base_x = Math.max(aabb.base[0], this.base[0])\n    , base_y = Math.max(aabb.base[1], this.base[1])\n    , base_z = Math.max(aabb.base[2], this.base[2])\n    , max_x = Math.min(aabb.max[0], this.max[0])\n    , max_y = Math.min(aabb.max[1], this.max[1])\n    , max_z = Math.min(aabb.max[2], this.max[2])\n\n  return new AABB([base_x, base_y, base_z], [max_x - base_x, max_y - base_y, max_z - base_z])\n}\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/aabb-3d/index.js?");

/***/ }),

/***/ "../../node_modules/binary-search-bounds/search-bounds.js":
/*!************************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/binary-search-bounds/search-bounds.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction compileSearch(funcName, predicate, reversed, extraArgs, useNdarray, earlyOut) {\n  var code = [\n    \"function \", funcName, \"(a,l,h,\", extraArgs.join(\",\"),  \"){\",\nearlyOut ? \"\" : \"var i=\", (reversed ? \"l-1\" : \"h+1\"),\n\";while(l<=h){\\\nvar m=(l+h)>>>1,x=a\", useNdarray ? \".get(m)\" : \"[m]\"]\n  if(earlyOut) {\n    if(predicate.indexOf(\"c\") < 0) {\n      code.push(\";if(x===y){return m}else if(x<=y){\")\n    } else {\n      code.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\")\n    }\n  } else {\n    code.push(\";if(\", predicate, \"){i=m;\")\n  }\n  if(reversed) {\n    code.push(\"l=m+1}else{h=m-1}\")\n  } else {\n    code.push(\"h=m-1}else{l=m+1}\")\n  }\n  code.push(\"}\")\n  if(earlyOut) {\n    code.push(\"return -1};\")\n  } else {\n    code.push(\"return i};\")\n  }\n  return code.join(\"\")\n}\n\nfunction compileBoundsSearch(predicate, reversed, suffix, earlyOut) {\n  var result = new Function([\n  compileSearch(\"A\", \"x\" + predicate + \"y\", reversed, [\"y\"], false, earlyOut),\n  compileSearch(\"B\", \"x\" + predicate + \"y\", reversed, [\"y\"], true, earlyOut),\n  compileSearch(\"P\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], false, earlyOut),\n  compileSearch(\"Q\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], true, earlyOut),\n\"function dispatchBsearch\", suffix, \"(a,y,c,l,h){\\\nif(a.shape){\\\nif(typeof(c)==='function'){\\\nreturn Q(a,(l===undefined)?0:l|0,(h===undefined)?a.shape[0]-1:h|0,y,c)\\\n}else{\\\nreturn B(a,(c===undefined)?0:c|0,(l===undefined)?a.shape[0]-1:l|0,y)\\\n}}else{\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===undefined)?0:l|0,(h===undefined)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===undefined)?0:c|0,(l===undefined)?a.length-1:l|0,y)\\\n}}}\\\nreturn dispatchBsearch\", suffix].join(\"\"))\n  return result()\n}\n\nmodule.exports = {\n  ge: compileBoundsSearch(\">=\", false, \"GE\"),\n  gt: compileBoundsSearch(\">\", false, \"GT\"),\n  lt: compileBoundsSearch(\"<\", true, \"LT\"),\n  le: compileBoundsSearch(\"<=\", true, \"LE\"),\n  eq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/binary-search-bounds/search-bounds.js?");

/***/ }),

/***/ "../../node_modules/bit-twiddle/twiddle.js":
/*!*********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/bit-twiddle/twiddle.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/bit-twiddle/twiddle.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/index.js":
/*!*********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = boxIntersectWrapper\n\nvar pool = __webpack_require__(/*! @jpweeks/typedarray-pool */ \"../../node_modules/@jpweeks/typedarray-pool/pool.js\")\nvar sweep = __webpack_require__(/*! ./lib/sweep */ \"../../node_modules/box-intersect/lib/sweep.js\")\nvar boxIntersectIter = __webpack_require__(/*! ./lib/intersect */ \"../../node_modules/box-intersect/lib/intersect.js\")\n\nfunction boxEmpty(d, box) {\n  for(var j=0; j<d; ++j) {\n    if(!(box[j] <= box[j+d])) {\n      return true\n    }\n  }\n  return false\n}\n\n//Unpack boxes into a flat typed array, remove empty boxes\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0\n  var count = 0\n  for(var i=0, n=boxes.length; i<n; ++i) {\n    var b = boxes[i]\n    if(boxEmpty(d, b)) {\n      continue\n    }\n    for(var j=0; j<2*d; ++j) {\n      data[ptr++] = b[j]\n    }\n    ids[count++] = i\n  }\n  return count\n}\n\n//Perform type conversions, check bounds\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length\n  var m = blue.length\n\n  //If either array is empty, then we can skip this whole thing\n  if(n <= 0 || m <= 0) {\n    return\n  }\n\n  //Compute dimension, if it is 0 then we skip\n  var d = (red[0].length)>>>1\n  if(d <= 0) {\n    return\n  }\n\n  var retval\n\n  //Convert red boxes\n  var redList  = pool.mallocDouble(2*d*n)\n  var redIds   = pool.mallocInt32(n)\n  n = convertBoxes(red, d, redList, redIds)\n\n  if(n > 0) {\n    if(d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n)\n      retval = sweep.sweepComplete(\n        d, visit, \n        0, n, redList, redIds,\n        0, n, redList, redIds)\n    } else {\n\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2*d*m)\n      var blueIds  = pool.mallocInt32(m)\n      m = convertBoxes(blue, d, blueList, blueIds)\n\n      if(m > 0) {\n        sweep.init(n+m)\n\n        if(d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(\n            d, visit, \n            0, n, redList,  redIds,\n            0, m, blueList, blueIds)\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(\n            d, visit,    full,\n            n, redList,  redIds,\n            m, blueList, blueIds)\n        }\n\n        pool.free(blueList)\n        pool.free(blueIds)\n      }\n    }\n\n    pool.free(redList)\n    pool.free(redIds)\n  }\n\n  return retval\n}\n\n\nvar RESULT\n\nfunction appendItem(i,j) {\n  RESULT.push([i,j])\n}\n\nfunction intersectFullArray(x) {\n  RESULT = []\n  boxIntersect(x, x, appendItem, true)\n  return RESULT\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = []\n  boxIntersect(x, y, appendItem, false)\n  return RESULT\n}\n\n//User-friendly wrapper, handle full input and no-visitor cases\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result\n  switch(arguments.length) {\n    case 1:\n      return intersectFullArray(arg0)\n    case 2:\n      if(typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true)\n      } else {\n        return intersectBipartiteArray(arg0, arg1)\n      }\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false)\n    default:\n      throw new Error('box-intersect: Invalid arguments')\n  }\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/index.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/lib/brute.js":
/*!*************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/lib/brute.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar DIMENSION   = 'd'\nvar AXIS        = 'ax'\nvar VISIT       = 'vv'\nvar FLIP        = 'fp'\n\nvar ELEM_SIZE   = 'es'\n\nvar RED_START   = 'rs'\nvar RED_END     = 're'\nvar RED_BOXES   = 'rb'\nvar RED_INDEX   = 'ri'\nvar RED_PTR     = 'rp'\n\nvar BLUE_START  = 'bs'\nvar BLUE_END    = 'be'\nvar BLUE_BOXES  = 'bb'\nvar BLUE_INDEX  = 'bi'\nvar BLUE_PTR    = 'bp'\n\nvar RETVAL      = 'rv'\n\nvar INNER_LABEL = 'Q'\n\nvar ARGS = [\n  DIMENSION,\n  AXIS,\n  VISIT,\n  RED_START,\n  RED_END,\n  RED_BOXES,\n  RED_INDEX,\n  BLUE_START,\n  BLUE_END,\n  BLUE_BOXES,\n  BLUE_INDEX\n]\n\nfunction generateBruteForce(redMajor, flip, full) {\n  var funcName = 'bruteForce' + \n    (redMajor ? 'Red' : 'Blue') + \n    (flip ? 'Flip' : '') +\n    (full ? 'Full' : '')\n\n  var code = ['function ', funcName, '(', ARGS.join(), '){',\n    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']\n\n  var redLoop = \n    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +\n        'i<' + RED_END +';' +\n        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +\n        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +\n            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +\n            'xi=' + RED_INDEX + '[i];'\n\n  var blueLoop = \n    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +\n        'j<' + BLUE_END + ';' +\n        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +\n        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +\n            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +\n            'yi=' + BLUE_INDEX + '[j];'\n\n  if(redMajor) {\n    code.push(redLoop, INNER_LABEL, ':', blueLoop)\n  } else {\n    code.push(blueLoop, INNER_LABEL, ':', redLoop)\n  }\n\n  if(full) {\n    code.push('if(y1<x0||x1<y0)continue;')\n  } else if(flip) {\n    code.push('if(y0<=x0||x1<y0)continue;')\n  } else {\n    code.push('if(y0<x0||x1<y0)continue;')\n  }\n\n  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+\n    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+\n        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+\n        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+\n        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+\n      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +\n      'var ' + RETVAL + '=' + VISIT + '(')\n\n  if(flip) {\n    code.push('yi,xi')\n  } else {\n    code.push('xi,yi')\n  }\n\n  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')\n\n  return {\n    name: funcName, \n    code: code.join('')\n  }\n}\n\nfunction bruteForcePlanner(full) {\n  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')\n  var prefix = []\n  var fargs = ARGS.slice()\n  if(!full) {\n    fargs.splice(3, 0, FLIP)\n  }\n\n  var code = ['function ' + funcName + '(' + fargs.join() + '){']\n\n  function invoke(redMajor, flip) {\n    var res = generateBruteForce(redMajor, flip, full)\n    prefix.push(res.code)\n    code.push('return ' + res.name + '(' + ARGS.join() + ');')\n  }\n\n  code.push('if(' + RED_END + '-' + RED_START + '>' +\n                    BLUE_END + '-' + BLUE_START + '){')\n\n  if(full) {\n    invoke(true, false)\n    code.push('}else{')\n    invoke(false, false)\n  } else {\n    code.push('if(' + FLIP + '){')\n    invoke(true, true)\n    code.push('}else{')\n    invoke(true, false)\n    code.push('}}else{if(' + FLIP + '){')\n    invoke(false, true)\n    code.push('}else{')\n    invoke(false, false)\n    code.push('}')\n  }\n  code.push('}}return ' + funcName)\n\n  var codeStr = prefix.join('') + code.join('')\n  var proc = new Function(codeStr)\n  return proc()\n}\n\n\nexports.partial = bruteForcePlanner(false)\nexports.full    = bruteForcePlanner(true)\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/lib/brute.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/lib/intersect.js":
/*!*****************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/lib/intersect.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = boxIntersectIter\n\nvar pool = __webpack_require__(/*! @jpweeks/typedarray-pool */ \"../../node_modules/@jpweeks/typedarray-pool/pool.js\")\nvar bits = __webpack_require__(/*! bit-twiddle */ \"../../node_modules/bit-twiddle/twiddle.js\")\nvar bruteForce = __webpack_require__(/*! ./brute */ \"../../node_modules/box-intersect/lib/brute.js\")\nvar bruteForcePartial = bruteForce.partial\nvar bruteForceFull = bruteForce.full\nvar sweep = __webpack_require__(/*! ./sweep */ \"../../node_modules/box-intersect/lib/sweep.js\")\nvar findMedian = __webpack_require__(/*! ./median */ \"../../node_modules/box-intersect/lib/median.js\")\nvar genPartition = __webpack_require__(/*! ./partition */ \"../../node_modules/box-intersect/lib/partition.js\")\n\n//Twiddle parameters\nvar BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search\nvar SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan\nvar SCAN_COMPLETE_CUTOFF  = (1<<22)  \n\n//Partition functions\nvar partitionInteriorContainsInterval = genPartition(\n  '!(lo>=p0)&&!(p1>=hi)', \n  ['p0', 'p1'])\n\nvar partitionStartEqual = genPartition(\n  'lo===p0',\n  ['p0'])\n\nvar partitionStartLessThan = genPartition(\n  'lo<p0',\n  ['p0'])\n\nvar partitionEndLessThanEqual = genPartition(\n  'hi<=p0',\n  ['p0'])\n\nvar partitionContainsPoint = genPartition(\n  'lo<=p0&&p0<=hi',\n  ['p0'])\n\nvar partitionContainsPointProper = genPartition(\n  'lo<p0&&p0<=hi',\n  ['p0'])\n\n//Frame size for iterative loop\nvar IFRAME_SIZE = 6\nvar DFRAME_SIZE = 2\n\n//Data for box statck\nvar INIT_CAPACITY = 1024\nvar BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)\nvar BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)\n\n//Initialize iterative loop queue\nfunction iterInit(d, count) {\n  var levels = (8 * bits.log2(count+1) * (d+1))|0\n  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)\n  if(BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK)\n    BOX_ISTACK = pool.mallocInt32(maxInts)\n  }\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)\n  if(BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK)\n    BOX_DSTACK = pool.mallocDouble(maxDoubles)\n  }\n}\n\n//Append item to queue\nfunction iterPush(ptr,\n  axis, \n  redStart, redEnd, \n  blueStart, blueEnd, \n  state, \n  lo, hi) {\n\n  var iptr = IFRAME_SIZE * ptr\n  BOX_ISTACK[iptr]   = axis\n  BOX_ISTACK[iptr+1] = redStart\n  BOX_ISTACK[iptr+2] = redEnd\n  BOX_ISTACK[iptr+3] = blueStart\n  BOX_ISTACK[iptr+4] = blueEnd\n  BOX_ISTACK[iptr+5] = state\n\n  var dptr = DFRAME_SIZE * ptr\n  BOX_DSTACK[dptr]   = lo\n  BOX_DSTACK[dptr+1] = hi\n}\n\n//Special case:  Intersect single point with list of intervals\nfunction onePointPartial(\n  d, axis, visit, flip,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    if(flip && blueX === r0) {\n      continue\n    }\n    var redId = redIndex[i]\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval\n    if(flip) {\n      retval = visit(blueId, redId)\n    } else {\n      retval = visit(redId, blueId)\n    }\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//Special case:  Intersect one point with list of intervals\nfunction onePointFull(\n  d, axis, visit,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var redId = redIndex[i]\n    if(redId === blueId) {\n      continue\n    }\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval = visit(redId, blueId)\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//The main box intersection routine\nfunction boxIntersectIter(\n  d, visit, initFull,\n  xSize, xBoxes, xIndex,\n  ySize, yBoxes, yIndex) {\n\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize)\n\n  var top  = 0\n  var elemSize = 2 * d\n  var retval\n\n  iterPush(top++,\n      0,\n      0, xSize,\n      0, ySize,\n      initFull ? 16 : 0, \n      -Infinity, Infinity)\n  if(!initFull) {\n    iterPush(top++,\n      0,\n      0, ySize,\n      0, xSize,\n      1, \n      -Infinity, Infinity)\n  }\n\n  while(top > 0) {\n    top  -= 1\n\n    var iptr = top * IFRAME_SIZE\n    var axis      = BOX_ISTACK[iptr]\n    var redStart  = BOX_ISTACK[iptr+1]\n    var redEnd    = BOX_ISTACK[iptr+2]\n    var blueStart = BOX_ISTACK[iptr+3]\n    var blueEnd   = BOX_ISTACK[iptr+4]\n    var state     = BOX_ISTACK[iptr+5]\n\n    var dptr = top * DFRAME_SIZE\n    var lo        = BOX_DSTACK[dptr]\n    var hi        = BOX_DSTACK[dptr+1]\n\n    //Unpack state info\n    var flip      = (state & 1)\n    var full      = !!(state & 16)\n\n    //Unpack indices\n    var red       = xBoxes\n    var redIndex  = xIndex\n    var blue      = yBoxes\n    var blueIndex = yIndex\n    if(flip) {\n      red         = yBoxes\n      redIndex    = yIndex\n      blue        = xBoxes\n      blueIndex   = xIndex\n    }\n\n    if(state & 2) {\n      redEnd = partitionStartLessThan(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        hi)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    if(state & 4) {\n      redStart = partitionEndLessThanEqual(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        lo)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    \n    var redCount  = redEnd  - redStart\n    var blueCount = blueEnd - blueStart\n\n    if(full) {\n      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(\n          d, axis, visit, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    } else {\n      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(\n            d, axis, visit, flip,\n            redStart,  redEnd,  red,  redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      } else if(d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(\n          d, axis, visit, flip, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    }\n    \n    //First, find all red intervals whose interior contains (lo,hi)\n    var red0 = partitionInteriorContainsInterval(\n      d, axis, \n      redStart, redEnd, red, redIndex,\n      lo, hi)\n\n    //Lower dimensional case\n    if(redStart < red0) {\n\n      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(\n          d, axis+1, visit,\n          redStart, red0, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(axis === d-2) {\n        if(flip) {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            blueStart, blueEnd, blue, blueIndex,\n            redStart, red0, red, redIndex)\n        } else {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            redStart, red0, red, redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else {\n        iterPush(top++,\n          axis+1,\n          redStart, red0,\n          blueStart, blueEnd,\n          flip,\n          -Infinity, Infinity)\n        iterPush(top++,\n          axis+1,\n          blueStart, blueEnd,\n          redStart, red0,\n          flip^1,\n          -Infinity, Infinity)\n      }\n    }\n\n    //Divide and conquer phase\n    if(red0 < redEnd) {\n\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(\n        d, axis, \n        blueStart, blueEnd, blue, blueIndex)\n      var mid = blue[elemSize * blue0 + axis]\n      var blue1 = partitionStartEqual(\n        d, axis,\n        blue0, blueEnd, blue, blueIndex,\n        mid)\n\n      //Right case\n      if(blue1 < blueEnd) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blue1, blueEnd,\n          (flip|4) + (full ? 16 : 0),\n          mid, hi)\n      }\n\n      //Left case\n      if(blueStart < blue0) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blueStart, blue0,\n          (flip|2) + (full ? 16 : 0),\n          lo, mid)\n      }\n\n      //Center case (the hard part)\n      if(blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if(full) {\n          retval = onePointFull(\n            d, axis, visit,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        } else {\n          retval = onePointPartial(\n            d, axis, visit, flip,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(blue0 < blue1) {\n        var red1\n        if(full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(\n            d, axis,\n            red0, redEnd, red, redIndex,\n            mid)\n          if(red0 < red1) {\n            var redX = partitionStartEqual(\n              d, axis,\n              red0, red1, red, redIndex,\n              mid)\n            if(axis === d-2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if(red0 < redX) {\n                retval = sweep.sweepComplete(\n                  d, visit,\n                  red0, redX, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n\n              //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n              if(redX < red1) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  redX, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n            } else {\n              if(red0 < redX) {\n                iterPush(top++,\n                  axis+1,\n                  red0, redX,\n                  blue0, blue1,\n                  16,\n                  -Infinity, Infinity)\n              }\n              if(redX < red1) {\n                iterPush(top++,\n                  axis+1,\n                  redX, red1,\n                  blue0, blue1,\n                  0,\n                  -Infinity, Infinity)\n                iterPush(top++,\n                  axis+1,\n                  blue0, blue1,\n                  redX, red1,\n                  1,\n                  -Infinity, Infinity)\n              }\n            }\n          }\n        } else {\n          if(flip) {\n            red1 = partitionContainsPointProper(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          } else {\n            red1 = partitionContainsPoint(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          }\n          if(red0 < red1) {\n            if(axis === d-2) {\n              if(flip) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  blue0, blue1, blue, blueIndex,\n                  red0, red1, red, redIndex)\n              } else {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  red0, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n              }\n            } else {\n              iterPush(top++,\n                axis+1,\n                red0, red1,\n                blue0, blue1,\n                flip,\n                -Infinity, Infinity)\n              iterPush(top++,\n                axis+1,\n                blue0, blue1,\n                red0, red1,\n                flip^1,\n                -Infinity, Infinity)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/lib/intersect.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/lib/median.js":
/*!**************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/lib/median.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = findMedian\n\nvar genPartition = __webpack_require__(/*! ./partition */ \"../../node_modules/box-intersect/lib/partition.js\")\n\nvar partitionStartLessThan = genPartition('lo<p0', ['p0'])\n\nvar PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian\n\n//Base case for median finding:  Use insertion sort\nfunction insertionSort(d, axis, start, end, boxes, ids) {\n  var elemSize = 2 * d\n  var boxPtr = elemSize * (start+1) + axis\n  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {\n    var x = boxes[boxPtr]\n    for(var j=i, ptr=elemSize*(i-1); \n        j>start && boxes[ptr+axis] > x; \n        --j, ptr-=elemSize) {\n      //Swap\n      var aPtr = ptr\n      var bPtr = ptr+elemSize\n      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {\n        var y = boxes[aPtr]\n        boxes[aPtr] = boxes[bPtr]\n        boxes[bPtr] = y\n      }\n      var tmp = ids[j]\n      ids[j] = ids[j-1]\n      ids[j-1] = tmp\n    }\n  }\n}\n\n//Find median using quick select algorithm\n//  takes O(n) time with high probability\nfunction findMedian(d, axis, start, end, boxes, ids) {\n  if(end <= start+1) {\n    return start\n  }\n\n  var lo       = start\n  var hi       = end\n  var mid      = ((end + start) >>> 1)\n  var elemSize = 2*d\n  var pivot    = mid\n  var value    = boxes[elemSize*mid+axis]\n  \n  while(lo < hi) {\n    if(hi - lo < PARTITION_THRESHOLD) {\n      insertionSort(d, axis, lo, hi, boxes, ids)\n      value = boxes[elemSize*mid+axis]\n      break\n    }\n    \n    //Select pivot using median-of-3\n    var count  = hi - lo\n    var pivot0 = (Math.random()*count+lo)|0\n    var value0 = boxes[elemSize*pivot0 + axis]\n    var pivot1 = (Math.random()*count+lo)|0\n    var value1 = boxes[elemSize*pivot1 + axis]\n    var pivot2 = (Math.random()*count+lo)|0\n    var value2 = boxes[elemSize*pivot2 + axis]\n    if(value0 <= value1) {\n      if(value2 >= value1) {\n        pivot = pivot1\n        value = value1\n      } else if(value0 >= value2) {\n        pivot = pivot0\n        value = value0\n      } else {\n        pivot = pivot2\n        value = value2\n      }\n    } else {\n      if(value1 >= value2) {\n        pivot = pivot1\n        value = value1\n      } else if(value2 >= value0) {\n        pivot = pivot0\n        value = value0\n      } else {\n        pivot = pivot2\n        value = value2\n      }\n    }\n\n    //Swap pivot to end of array\n    var aPtr = elemSize * (hi-1)\n    var bPtr = elemSize * pivot\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr]\n      boxes[aPtr] = boxes[bPtr]\n      boxes[bPtr] = x\n    }\n    var y = ids[hi-1]\n    ids[hi-1] = ids[pivot]\n    ids[pivot] = y\n\n    //Partition using pivot\n    pivot = partitionStartLessThan(\n      d, axis, \n      lo, hi-1, boxes, ids,\n      value)\n\n    //Swap pivot back\n    var aPtr = elemSize * (hi-1)\n    var bPtr = elemSize * pivot\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr]\n      boxes[aPtr] = boxes[bPtr]\n      boxes[bPtr] = x\n    }\n    var y = ids[hi-1]\n    ids[hi-1] = ids[pivot]\n    ids[pivot] = y\n\n    //Swap pivot to last pivot\n    if(mid < pivot) {\n      hi = pivot-1\n      while(lo < hi && \n        boxes[elemSize*(hi-1)+axis] === value) {\n        hi -= 1\n      }\n      hi += 1\n    } else if(pivot < mid) {\n      lo = pivot + 1\n      while(lo < hi &&\n        boxes[elemSize*lo+axis] === value) {\n        lo += 1\n      }\n    } else {\n      break\n    }\n  }\n\n  //Make sure pivot is at start\n  return partitionStartLessThan(\n    d, axis, \n    start, mid, boxes, ids,\n    boxes[elemSize*mid+axis])\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/lib/median.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/lib/partition.js":
/*!*****************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/lib/partition.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = genPartition\n\nvar code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'\n\nfunction genPartition(predicate, args) {\n  var fargs ='abcdef'.split('').concat(args)\n  var reads = []\n  if(predicate.indexOf('lo') >= 0) {\n    reads.push('lo=e[k+n]')\n  }\n  if(predicate.indexOf('hi') >= 0) {\n    reads.push('hi=e[k+o]')\n  }\n  fargs.push(\n    code.replace('_', reads.join())\n        .replace('$', predicate))\n  return Function.apply(void 0, fargs)\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/lib/partition.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/lib/sort.js":
/*!************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/lib/sort.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//This code is extracted from ndarray-sort\n//It is inlined here as a temporary workaround\n\nmodule.exports = wrapper;\n\nvar INSERT_SORT_CUTOFF = 32\n\nfunction wrapper(data, n0) {\n  if (n0 <= 4*INSERT_SORT_CUTOFF) {\n    insertionSort(0, n0 - 1, data);\n  } else {\n    quickSort(0, n0 - 1, data);\n  }\n}\n\nfunction insertionSort(left, right, data) {\n  var ptr = 2*(left+1)\n  for(var i=left+1; i<=right; ++i) {\n    var a = data[ptr++]\n    var b = data[ptr++]\n    var j = i\n    var jptr = ptr-2\n    while(j-- > left) {\n      var x = data[jptr-2]\n      var y = data[jptr-1]\n      if(x < a) {\n        break\n      } else if(x === a && y < b) {\n        break\n      }\n      data[jptr]   = x\n      data[jptr+1] = y\n      jptr -= 2\n    }\n    data[jptr]   = a\n    data[jptr+1] = b\n  }\n}\n\nfunction swap(i, j, data) {\n  i *= 2\n  j *= 2\n  var x = data[i]\n  var y = data[i+1]\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n  data[j] = x\n  data[j+1] = y\n}\n\nfunction move(i, j, data) {\n  i *= 2\n  j *= 2\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n}\n\nfunction rotate(i, j, k, data) {\n  i *= 2\n  j *= 2\n  k *= 2\n  var x = data[i]\n  var y = data[i+1]\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n  data[j] = data[k]\n  data[j+1] = data[k+1]\n  data[k] = x\n  data[k+1] = y\n}\n\nfunction shufflePivot(i, j, px, py, data) {\n  i *= 2\n  j *= 2\n  data[i] = data[j]\n  data[j] = px\n  data[i+1] = data[j+1]\n  data[j+1] = py\n}\n\nfunction compare(i, j, data) {\n  i *= 2\n  j *= 2\n  var x = data[i],\n      y = data[j]\n  if(x < y) {\n    return false\n  } else if(x === y) {\n    return data[i+1] > data[j+1]\n  }\n  return true\n}\n\nfunction comparePivot(i, y, b, data) {\n  i *= 2\n  var x = data[i]\n  if(x < y) {\n    return true\n  } else if(x === y) {\n    return data[i+1] < b\n  }\n  return false\n}\n\nfunction quickSort(left, right, data) {\n  var sixth = (right - left + 1) / 6 | 0, \n      index1 = left + sixth, \n      index5 = right - sixth, \n      index3 = left + right >> 1, \n      index2 = index3 - sixth, \n      index4 = index3 + sixth, \n      el1 = index1, \n      el2 = index2, \n      el3 = index3, \n      el4 = index4, \n      el5 = index5, \n      less = left + 1, \n      great = right - 1, \n      tmp = 0\n  if(compare(el1, el2, data)) {\n    tmp = el1\n    el1 = el2\n    el2 = tmp\n  }\n  if(compare(el4, el5, data)) {\n    tmp = el4\n    el4 = el5\n    el5 = tmp\n  }\n  if(compare(el1, el3, data)) {\n    tmp = el1\n    el1 = el3\n    el3 = tmp\n  }\n  if(compare(el2, el3, data)) {\n    tmp = el2\n    el2 = el3\n    el3 = tmp\n  }\n  if(compare(el1, el4, data)) {\n    tmp = el1\n    el1 = el4\n    el4 = tmp\n  }\n  if(compare(el3, el4, data)) {\n    tmp = el3\n    el3 = el4\n    el4 = tmp\n  }\n  if(compare(el2, el5, data)) {\n    tmp = el2\n    el2 = el5\n    el5 = tmp\n  }\n  if(compare(el2, el3, data)) {\n    tmp = el2\n    el2 = el3\n    el3 = tmp\n  }\n  if(compare(el4, el5, data)) {\n    tmp = el4\n    el4 = el5\n    el5 = tmp\n  }\n\n  var pivot1X = data[2*el2]\n  var pivot1Y = data[2*el2+1]\n  var pivot2X = data[2*el4]\n  var pivot2Y = data[2*el4+1]\n\n  var ptr0 = 2 * el1;\n  var ptr2 = 2 * el3;\n  var ptr4 = 2 * el5;\n  var ptr5 = 2 * index1;\n  var ptr6 = 2 * index3;\n  var ptr7 = 2 * index5;\n  for (var i1 = 0; i1 < 2; ++i1) {\n    var x = data[ptr0+i1];\n    var y = data[ptr2+i1];\n    var z = data[ptr4+i1];\n    data[ptr5+i1] = x;\n    data[ptr6+i1] = y;\n    data[ptr7+i1] = z;\n  }\n\n  move(index2, left, data)\n  move(index4, right, data)\n  for (var k = less; k <= great; ++k) {\n    if (comparePivot(k, pivot1X, pivot1Y, data)) {\n      if (k !== less) {\n        swap(k, less, data)\n      }\n      ++less;\n    } else {\n      if (!comparePivot(k, pivot2X, pivot2Y, data)) {\n        while (true) {\n          if (!comparePivot(great, pivot2X, pivot2Y, data)) {\n            if (--great < k) {\n              break;\n            }\n            continue;\n          } else {\n            if (comparePivot(great, pivot1X, pivot1Y, data)) {\n              rotate(k, less, great, data)\n              ++less;\n              --great;\n            } else {\n              swap(k, great, data)\n              --great;\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  shufflePivot(left, less-1, pivot1X, pivot1Y, data)\n  shufflePivot(right, great+1, pivot2X, pivot2Y, data)\n  if (less - 2 - left <= INSERT_SORT_CUTOFF) {\n    insertionSort(left, less - 2, data);\n  } else {\n    quickSort(left, less - 2, data);\n  }\n  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {\n    insertionSort(great + 2, right, data);\n  } else {\n    quickSort(great + 2, right, data);\n  }\n  if (great - less <= INSERT_SORT_CUTOFF) {\n    insertionSort(less, great, data);\n  } else {\n    quickSort(less, great, data);\n  }\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/lib/sort.js?");

/***/ }),

/***/ "../../node_modules/box-intersect/lib/sweep.js":
/*!*************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/box-intersect/lib/sweep.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  init:           sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete:  sweepComplete,\n  scanBipartite:  scanBipartite,\n  scanComplete:   scanComplete\n}\n\nvar pool  = __webpack_require__(/*! @jpweeks/typedarray-pool */ \"../../node_modules/@jpweeks/typedarray-pool/pool.js\")\nvar bits  = __webpack_require__(/*! bit-twiddle */ \"../../node_modules/bit-twiddle/twiddle.js\")\nvar isort = __webpack_require__(/*! ./sort */ \"../../node_modules/box-intersect/lib/sort.js\")\n\n//Flag for blue\nvar BLUE_FLAG = (1<<28)\n\n//1D sweep event queue stuff (use pool to save space)\nvar INIT_CAPACITY      = 1024\nvar RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)\nvar RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)\nvar SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)\n\n//Reserves memory for the 1D sweep data structures\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count)\n  if(RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE)\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX)\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE)\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX)\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE)\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX)\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  var eventLength = 8 * rcount\n  if(SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS)\n    SWEEP_EVENTS = pool.mallocDouble(eventLength)\n  }\n}\n\n//Remove an item from the active queue in O(1)\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item]\n  var top = queue[count-1]\n  queue[idx] = top\n  index[top] = idx\n}\n\n//Insert an item into the active queue in O(1)\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item\n  index[item]  = count\n}\n\n//Recursion base case: use 1D sweep algorithm\nfunction sweepBipartite(\n    d, visit,\n    redStart,  redEnd, red, redIndex,\n    blueStart, blueEnd, blue, blueIndex) {\n\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = redIndex[i]\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -(idx+1)\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = blueIndex[i]+BLUE_FLAG\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive  = 0\n  var blueActive = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e >= BLUE_FLAG) {\n      //blue destroy event\n      e = (e-BLUE_FLAG)|0\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)\n    } else if(e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)\n    } else if(e <= -BLUE_FLAG) {\n      //blue create event\n      e = (-e-BLUE_FLAG)|0\n      for(var j=0; j<redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)\n    } else {\n      //red create event\n      e = (-e-1)|0\n      for(var j=0; j<blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j])\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)\n    }\n  }\n}\n\n//Complete sweep\nfunction sweepComplete(d, visit, \n  redStart, redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = (redIndex[i]+1)<<1\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = (blueIndex[i]+1)<<1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = (-idx)|1\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx|1\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  var blueActive   = 0\n  var commonActive = 0\n  for(var i=0; i<n; ++i) {\n    var e     = SWEEP_EVENTS[2*i+1]|0\n    var color = e&1\n    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {\n      color = 2\n      i += 1\n    }\n    \n    if(e < 0) {\n      //Create event\n      var id = -(e>>1) - 1\n\n      //Intersect with common\n      for(var j=0; j<commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n\n      if(color !== 0) {\n        //Intersect with red\n        for(var j=0; j<redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color !== 1) {\n        //Intersect with blue\n        for(var j=0; j<blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)\n      } else if(color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)\n      } else if(color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)\n      }\n    } else {\n      //Destroy event\n      var id = (e>>1) - 1\n      if(color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)\n      } else if(color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)\n      } else if(color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)\n      }\n    }\n  }\n}\n\n//Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\nfunction scanBipartite(\n  d, axis, visit, flip,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n  \n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  var redShift  = 1\n  var blueShift = 1\n  if(flip) {\n    blueShift = BLUE_FLAG\n  } else {\n    redShift  = BLUE_FLAG\n  }\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + redShift\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + blueShift\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      var isRed = false\n      if(idx >= BLUE_FLAG) {\n        isRed = !flip\n        idx -= BLUE_FLAG \n      } else {\n        isRed = !!flip\n        idx -= 1\n      }\n      if(isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)\n      } else {\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n        \n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redPtr = elemSize * oidx\n\n          if(b1 < red[redPtr+axis+1] || \n             red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var redId  = redIndex[oidx]\n          var retval\n          if(flip) {\n            retval = visit(blueId, redId)\n          } else {\n            retval = visit(redId, blueId)\n          }\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)\n    }\n  }\n}\n\nfunction scanComplete(\n  d, axis, visit,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + BLUE_FLAG\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + 1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      if(idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG\n      } else {\n        idx -= 1\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n\n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redId  = redIndex[oidx]\n\n          if(redId === blueId) {\n            break\n          }\n\n          var redPtr = elemSize * oidx\n          if(b1 < red[redPtr+axis+1] || \n            red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d]   < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var retval = visit(redId, blueId)\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG\n      for(var j=redActive-1; j>=0; --j) {\n        if(RED_SWEEP_QUEUE[j] === idx) {\n          for(var k=j+1; k<redActive; ++k) {\n            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]\n          }\n          break\n        }\n      }\n      --redActive\n    }\n  }\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/box-intersect/lib/sweep.js?");

/***/ }),

/***/ "../../node_modules/dexie/dist/dexie.mjs":
/*!*******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/dexie/dist/dexie.mjs ***!
  \*******************************************************************/
/*! exports provided: Dexie, RangeSet, default, liveQuery, mergeRanges, rangesOverlap */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n__webpack_require__.r(__webpack_exports__);\n__webpack_require__.r(__webpack_exports__);\n__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dexie\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeSet\", function() { return RangeSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"liveQuery\", function() { return liveQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeRanges\", function() { return mergeRanges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangesOverlap\", function() { return rangesOverlap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dexie\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeSet\", function() { return RangeSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"liveQuery\", function() { return liveQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeRanges\", function() { return mergeRanges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangesOverlap\", function() { return rangesOverlap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dexie\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeSet\", function() { return RangeSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"liveQuery\", function() { return liveQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeRanges\", function() { return mergeRanges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangesOverlap\", function() { return rangesOverlap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dexie\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RangeSet\", function() { return RangeSet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Dexie$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"liveQuery\", function() { return liveQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeRanges\", function() { return mergeRanges; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangesOverlap\", function() { return rangesOverlap; });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.7, Wed Mar 20 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nvar _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nvar keys = Object.keys;\nvar isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nvar getProto = Object.getPrototypeOf;\nvar _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {\n        setProp(proto, key, extension[key]);\n    });\n}\nvar defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    var pd = getOwnPropertyDescriptor(obj, prop);\n    var proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nvar _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce(function (result, item, i) {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath))\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nvar concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nvar intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return [\"Int\", \"Uint\", \"Float\"].map(function (t) { return t + num + \"Array\"; }); }))).filter(function (t) { return _global[t]; });\nvar intrinsicTypes = intrinsicTypeNames.map(function (t) { return _global[t]; });\narrayToObject(intrinsicTypeNames, function (x) { return [x, true]; });\nvar circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    var rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    var rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        var proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nvar toString = {}.toString;\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nvar iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nvar getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nvar NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nvar isAsyncFunction = typeof Symbol !== 'undefined'\n    ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }\n    : function () { return false; };\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = function () { return true; };\nvar NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(function (frame) { return \"\\n\" + frame; })\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(function (key) { return failures[key].toString(); })\n        .filter(function (v, i, s) { return s.indexOf(v) === i; })\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + \"Error\", obj); }, {});\nvar BaseException = DexieError;\nvar exceptions = errorList.reduce(function (obj, name) {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = \"\" + msgOrInner + (!inner ? '' : '\\n ' + inner);\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = msgOrInner.name + \" \" + msgOrInner.message;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce(function (obj, name) {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce(function (obj, name) {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nvar LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?\n    [] :\n    (function () {\n        var globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        var nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nvar NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nvar patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    function () { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                function () {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(function () {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                function () { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(function (uh) {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nvar thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var _this = this;\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            var cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise(function (resolve, reject) {\n                propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, function (err) {\n            return err instanceof type ? handler(err) : PromiseReject(err);\n        })\n            : this.then(null, function (err) {\n                return err && err.name === type ? handler(err) : PromiseReject(err);\n            });\n    },\n    finally: function (onFinally) {\n        return this.then(function (value) {\n            onFinally();\n            return value;\n        }, function (err) {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        var _this = this;\n        return ms < Infinity ?\n            new DexiePromise(function (resolve, reject) {\n                var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);\n                _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject); });\n        });\n    },\n    resolve: function (value) {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise(function (resolve, reject) {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });\n        });\n    },\n    PSD: {\n        get: function () { return PSD; },\n        set: function (value) { return PSD = value; }\n    },\n    totalEchoes: { get: function () { return totalEchoes; } },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: function () { return asap; },\n        set: function (value) { asap = value; }\n    },\n    rejectionMapper: {\n        get: function () { return rejectionMapper; },\n        set: function (value) { rejectionMapper = value; }\n    },\n    follow: function (fn, zoneProps) {\n        return new DexiePromise(function (resolve, reject) {\n            return newScope(function (resolve, reject) {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    var _this = this;\n                    run_at_end_of_this_or_next_physical_tick(function () {\n                        _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve) {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                var remaining = possiblePromises.length;\n                var results = new Array(remaining);\n                possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: \"fulfilled\", value: value }; }, function (reason) { return results[i] = { status: \"rejected\", reason: reason }; })\n                    .then(function () { return --remaining || resolve(results); }); });\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(function (resolve, reject) {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                var remaining = possiblePromises.length;\n                var failures = new Array(remaining);\n                possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }); });\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(function (value) {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, function (resolve, reject) {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(function () {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: function () {\n                return stack_being_generated ?\n                    origProp && (origProp.get ?\n                        origProp.get.apply(reason) :\n                        origProp.value) :\n                    promise.stack;\n            }\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(function () {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(function (p) {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(function () {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nvar task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(function (x) {\n            decrementExpectedAwaits();\n            return x;\n        }, function (e) {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise_1 = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise_1.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise_1.all = targetEnv.all;\n            GlobalPromise_1.race = targetEnv.race;\n            GlobalPromise_1.resolve = targetEnv.resolve;\n            GlobalPromise_1.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise_1.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise_1.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nvar UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(\"Unhandled rejection: \" + (err.stack || err));\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        }\n        catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn('Dexie: Need to reopen db');\n                db._close();\n                return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, function (resolve, reject) {\n            return newScope(function () {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(function (result) {\n            return trans._completion.then(function () { return result; });\n        });\n    }\n}\n\nvar DEXIE_VERSION = '3.2.7';\nvar maxString = String.fromCharCode(65535);\nvar minKey = -Infinity;\nvar INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nvar STRING_EXPECTED = \"String expected.\";\nvar connections = [];\nvar isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nvar hasIEDeleteObjectStoreBug = isIEOrEdge;\nvar hangsOnDeleteLargeKeyRange = isIEOrEdge;\nvar dexieStackFrameFilter = function (frame) { return !/(dexie\\.js|dexie\\.min\\.js)/.test(frame); };\nvar DBNAMES_DB = '__dbnames';\nvar READONLY = 'readonly';\nvar READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nvar AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? function (obj) {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : function (obj) { return obj; };\n}\n\nvar Table =  (function () {\n    function Table() {\n    }\n    Table.prototype._trans = function (mode, fn, writeLocked) {\n        var trans = this._tx || PSD.trans;\n        var tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        var wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n    Table.prototype.get = function (keyOrCrit, cb) {\n        var _this = this;\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', function (trans) {\n            return _this.core.get({ trans: trans, key: keyOrCrit })\n                .then(function (res) { return _this.hook.reading.fire(res); });\n        }).then(cb);\n    };\n    Table.prototype.where = function (indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, \"[\" + indexOrCrit.join('+') + \"]\");\n        var keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {\n            if (ix.compound &&\n                keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {\n                for (var i = 0; i < keyPaths.length; ++i) {\n                    if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                        return false;\n                }\n                return true;\n            }\n            return false;\n        }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];\n        if (compoundIndex && this.db._maxKey !== maxString) {\n            var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n            return this\n                .where(keyPathsInValidOrder)\n                .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));\n        }\n        if (!compoundIndex && debug)\n            console.warn(\"The query \" + JSON.stringify(indexOrCrit) + \" on \" + this.name + \" would benefit of a \" +\n                (\"compound index [\" + keyPaths.join('+') + \"]\"));\n        var idxByName = this.schema.idxByName;\n        var idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        var _a = keyPaths.reduce(function (_a, keyPath) {\n            var prevIndex = _a[0], prevFilterFn = _a[1];\n            var index = idxByName[keyPath];\n            var value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        function (x) {\n                            var prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(function (item) { return equals(value, item); });\n                        } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })\n                    : prevFilterFn\n            ];\n        }, [null, null]), idx = _a[0], filterFunction = _a[1];\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    };\n    Table.prototype.filter = function (filterFunction) {\n        return this.toCollection().and(filterFunction);\n    };\n    Table.prototype.count = function (thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    };\n    Table.prototype.offset = function (offset) {\n        return this.toCollection().offset(offset);\n    };\n    Table.prototype.limit = function (numRows) {\n        return this.toCollection().limit(numRows);\n    };\n    Table.prototype.each = function (callback) {\n        return this.toCollection().each(callback);\n    };\n    Table.prototype.toArray = function (thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    };\n    Table.prototype.toCollection = function () {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    };\n    Table.prototype.orderBy = function (index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            \"[\" + index.join('+') + \"]\" :\n            index));\n    };\n    Table.prototype.reverse = function () {\n        return this.toCollection().reverse();\n    };\n    Table.prototype.mapToClass = function (constructor) {\n        this.schema.mappedClass = constructor;\n        var readHook = function (obj) {\n            if (!obj)\n                return obj;\n            var res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    };\n    Table.prototype.defineClass = function () {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    };\n    Table.prototype.add = function (obj, key) {\n        var _this = this;\n        var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n        var objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', function (trans) {\n            return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n            .then(function (lastResult) {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    };\n    Table.prototype.update = function (keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(function (keyPath) {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    };\n    Table.prototype.put = function (obj, key) {\n        var _this = this;\n        var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n        var objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })\n            .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })\n            .then(function (lastResult) {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    };\n    Table.prototype.delete = function (key) {\n        var _this = this;\n        return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] }); })\n            .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n    };\n    Table.prototype.clear = function () {\n        var _this = this;\n        return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange }); })\n            .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });\n    };\n    Table.prototype.bulkGet = function (keys) {\n        var _this = this;\n        return this._trans('readonly', function (trans) {\n            return _this.core.getMany({\n                keys: keys,\n                trans: trans\n            }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });\n        });\n    };\n    Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {\n        var _this = this;\n        var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        var wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', function (trans) {\n            var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            var numObjects = objects.length;\n            var objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })\n                .then(function (_a) {\n                var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                var result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(_this.name + \".bulkAdd(): \" + numFailures + \" of \" + numObjects + \" operations failed\", failures);\n            });\n        });\n    };\n    Table.prototype.bulkPut = function (objects, keysOrOptions, options) {\n        var _this = this;\n        var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        var wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', function (trans) {\n            var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            var numObjects = objects.length;\n            var objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })\n                .then(function (_a) {\n                var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;\n                var result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(_this.name + \".bulkPut(): \" + numFailures + \" of \" + numObjects + \" operations failed\", failures);\n            });\n        });\n    };\n    Table.prototype.bulkDelete = function (keys) {\n        var _this = this;\n        var numKeys = keys.length;\n        return this._trans('readwrite', function (trans) {\n            return _this.core.mutate({ trans: trans, type: 'delete', keys: keys });\n        }).then(function (_a) {\n            var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(_this.name + \".bulkDelete(): \" + numFailures + \" of \" + numKeys + \" operations failed\", failures);\n        });\n    };\n    return Table;\n}());\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype: prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    var index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    var index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans: trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index: index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        var set_1 = {};\n        var union = function (item, cursor, advance) {\n            if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set_1, key)) {\n                    set_1[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(function (cursor) {\n        if (cursor) {\n            return cursor.start(function () {\n                var c = function () { return cursor.continue(); };\n                if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        var ta = type(a);\n        var tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    var al = a.length;\n    var bl = b.length;\n    var l = al < bl ? al : bl;\n    for (var i = 0; i < l; ++i) {\n        var res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    var al = a.length;\n    var bl = b.length;\n    var l = al < bl ? al : bl;\n    for (var i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    var t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    var tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nvar Collection =  (function () {\n    function Collection() {\n    }\n    Collection.prototype._read = function (fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    };\n    Collection.prototype._write = function (fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    };\n    Collection.prototype._addAlgorithm = function (fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    };\n    Collection.prototype._iterate = function (fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    };\n    Collection.prototype.clone = function (props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    };\n    Collection.prototype.raw = function () {\n        this._ctx.valueMapper = null;\n        return this;\n    };\n    Collection.prototype.each = function (fn) {\n        var ctx = this._ctx;\n        return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });\n    };\n    Collection.prototype.count = function (cb) {\n        var _this = this;\n        return this._read(function (trans) {\n            var ctx = _this._ctx;\n            var coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans: trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(function (count) { return Math.min(count, ctx.limit); });\n            }\n            else {\n                var count = 0;\n                return iter(ctx, function () { ++count; return false; }, trans, coreTable)\n                    .then(function () { return count; });\n            }\n        }).then(cb);\n    };\n    Collection.prototype.sortBy = function (keyPath, cb) {\n        var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    };\n    Collection.prototype.toArray = function (cb) {\n        var _this = this;\n        return this._read(function (trans) {\n            var ctx = _this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                var valueMapper_1 = ctx.valueMapper;\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans: trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index: index,\n                        range: ctx.range\n                    }\n                }).then(function (_a) {\n                    var result = _a.result;\n                    return valueMapper_1 ? result.map(valueMapper_1) : result;\n                });\n            }\n            else {\n                var a_1 = [];\n                return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });\n            }\n        }, cb);\n    };\n    Collection.prototype.offset = function (offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, function () {\n                var offsetLeft = offset;\n                return function (cursor, advance) {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(function () {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, function () {\n                var offsetLeft = offset;\n                return function () { return (--offsetLeft < 0); };\n            });\n        }\n        return this;\n    };\n    Collection.prototype.limit = function (numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, function () {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    };\n    Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    };\n    Collection.prototype.first = function (cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    };\n    Collection.prototype.last = function (cb) {\n        return this.reverse().first(cb);\n    };\n    Collection.prototype.filter = function (filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    };\n    Collection.prototype.and = function (filter) {\n        return this.filter(filter);\n    };\n    Collection.prototype.or = function (indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    };\n    Collection.prototype.reverse = function () {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    };\n    Collection.prototype.desc = function () {\n        return this.reverse();\n    };\n    Collection.prototype.eachKey = function (cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    };\n    Collection.prototype.eachUniqueKey = function (cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    };\n    Collection.prototype.eachPrimaryKey = function (cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    };\n    Collection.prototype.keys = function (cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    };\n    Collection.prototype.primaryKeys = function (cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(function (trans) {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans: trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index: index,\n                        range: ctx.range\n                    }\n                });\n            }).then(function (_a) {\n                var result = _a.result;\n                return result;\n            }).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    };\n    Collection.prototype.uniqueKeys = function (cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    };\n    Collection.prototype.firstKey = function (cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    };\n    Collection.prototype.lastKey = function (cb) {\n        return this.reverse().firstKey(cb);\n    };\n    Collection.prototype.distinct = function () {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    };\n    Collection.prototype.modify = function (changes) {\n        var _this = this;\n        var ctx = this._ctx;\n        return this._write(function (trans) {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            var coreTable = ctx.table.core;\n            var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;\n            var limit = _this.db._options.modifyChunkSize || 200;\n            var totalFailures = [];\n            var successCount = 0;\n            var failedKeys = [];\n            var applyMutateResult = function (expectedCount, res) {\n                var failures = res.failures, numFailures = res.numFailures;\n                successCount += expectedCount - numFailures;\n                for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {\n                    var pos = _a[_i];\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return _this.clone().primaryKeys().then(function (keys) {\n                var nextChunk = function (offset) {\n                    var count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans: trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(function (values) {\n                        var addValues = [];\n                        var putValues = [];\n                        var putKeys = outbound ? [] : null;\n                        var deleteKeys = [];\n                        for (var i = 0; i < count; ++i) {\n                            var origValue = values[i];\n                            var ctx_1 = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {\n                                if (ctx_1.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx_1.value);\n                                }\n                                else {\n                                    putValues.push(ctx_1.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        var criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans: trans, type: 'add', values: addValues })\n                                .then(function (res) {\n                                for (var pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans: trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria: criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans: trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria: criteria\n                            }).then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(function () {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    };\n    Collection.prototype.delete = function () {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(function (trans) {\n                var primaryKey = ctx.table.core.schema.primaryKey;\n                var coreRange = range;\n                return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {\n                    return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })\n                        .then(function (_a) {\n                        var failures = _a.failures; _a.lastResult; _a.results; var numFailures = _a.numFailures;\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    };\n    return Collection;\n}());\nvar deleteCallback = function (value, ctx) { return ctx.value = null; };\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        var keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        var whereCtx = whereClause._ctx;\n        var table = whereCtx.table;\n        var readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, function () { return rangeEqual(\"\"); }).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        function (s) { return s.toUpperCase(); } :\n        function (s) { return s.toLowerCase(); };\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        function (s) { return s.toLowerCase(); } :\n        function (s) { return s.toUpperCase(); };\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(function (s) { return typeof s === 'string'; })) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower: lower,\n        upper: upper,\n        lowerOpen: lowerOpen,\n        upperOpen: upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nvar WhereClause =  (function () {\n    function WhereClause() {\n    }\n    Object.defineProperty(WhereClause.prototype, \"Collection\", {\n        get: function () {\n            return this._ctx.table.db.Collection;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    };\n    WhereClause.prototype.equals = function (value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, function () { return rangeEqual(value); });\n    };\n    WhereClause.prototype.above = function (value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, function () { return createRange(value, undefined, true); });\n    };\n    WhereClause.prototype.aboveOrEqual = function (value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, function () { return createRange(value, undefined, false); });\n    };\n    WhereClause.prototype.below = function (value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, function () { return createRange(undefined, value, false, true); });\n    };\n    WhereClause.prototype.belowOrEqual = function (value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, function () { return createRange(undefined, value); });\n    };\n    WhereClause.prototype.startsWith = function (str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    };\n    WhereClause.prototype.startsWithIgnoreCase = function (str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);\n    };\n    WhereClause.prototype.equalsIgnoreCase = function (str) {\n        return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], \"\");\n    };\n    WhereClause.prototype.anyOfIgnoreCase = function () {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, \"\");\n    };\n    WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);\n    };\n    WhereClause.prototype.anyOf = function () {\n        var _this = this;\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        var compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });\n        c._ondirectionchange = function (direction) {\n            compare = (direction === \"next\" ?\n                _this._ascending :\n                _this._descending);\n            set.sort(compare);\n        };\n        var i = 0;\n        c._addAlgorithm(function (cursor, advance, resolve) {\n            var key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(function () { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    };\n    WhereClause.prototype.notEqual = function (value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    };\n    WhereClause.prototype.noneOf = function () {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        var ranges = set.reduce(function (res, val) { return res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]]; }, null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    };\n    WhereClause.prototype.inAnyRange = function (ranges, options) {\n        var _this = this;\n        var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(function (range) {\n            return range[0] !== undefined &&\n                range[1] !== undefined &&\n                ascending(range[0], range[1]) <= 0;\n        })) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        var includeLowers = !options || options.includeLowers !== false;\n        var includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            var i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                var range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        var sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        var set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        var rangePos = 0;\n        var keyIsBeyondCurrentEntry = includeUppers ?\n            function (key) { return ascending(key, set[rangePos][1]) > 0; } :\n            function (key) { return ascending(key, set[rangePos][1]) >= 0; };\n        var keyIsBeforeCurrentEntry = includeLowers ?\n            function (key) { return descending(key, set[rangePos][0]) > 0; } :\n            function (key) { return descending(key, set[rangePos][0]) >= 0; };\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        var checkKey = keyIsBeyondCurrentEntry;\n        var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });\n        c._ondirectionchange = function (direction) {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm(function (cursor, advance, resolve) {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(function () {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    };\n    WhereClause.prototype.startsWithAnyOf = function () {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(function (s) { return typeof s === 'string'; })) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));\n    };\n    return WhereClause;\n}());\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        var indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = function (a, b) { return indexedDB.cmp(b, a); };\n        this._max = function (a, b) { return indexedDB.cmp(a, b) > 0 ? a : b; };\n        this._min = function (a, b) { return indexedDB.cmp(a, b) < 0 ? a : b; };\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nvar DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nvar STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nvar globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nvar Transaction =  (function () {\n    function Transaction() {\n    }\n    Transaction.prototype._lock = function () {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    };\n    Transaction.prototype._unlock = function () {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    };\n    Transaction.prototype._locked = function () {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    };\n    Transaction.prototype.create = function (idbtrans) {\n        var _this = this;\n        if (!this.mode)\n            return this;\n        var idbdb = this.db.idbdb;\n        var dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(function (ev) {\n            preventDefault(ev);\n            _this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(function (ev) {\n            preventDefault(ev);\n            _this.active && _this._reject(new exceptions.Abort(idbtrans.error));\n            _this.active = false;\n            _this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(function () {\n            _this.active = false;\n            _this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    };\n    Transaction.prototype._promise = function (mode, fn, bWriteLock) {\n        var _this = this;\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise(function (resolve, reject) {\n                _this._blockedFuncs.push([function () {\n                        _this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(function () {\n                var p = new DexiePromise(function (resolve, reject) {\n                    _this._lock();\n                    var rv = fn(resolve, reject, _this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(function () { return _this._unlock(); });\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise(function (resolve, reject) {\n                var rv = fn(resolve, reject, _this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    };\n    Transaction.prototype._root = function () {\n        return this.parent ? this.parent._root() : this;\n    };\n    Transaction.prototype.waitFor = function (promiseLike) {\n        var root = this._root();\n        var promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(function () { return promise; });\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise(function (resolve, reject) {\n            promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    };\n    Transaction.prototype.abort = function () {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    };\n    Transaction.prototype.table = function (tableName) {\n        var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        var tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    };\n    return Transaction;\n}());\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        var _this = this;\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise(function (resolve, reject) {\n            _this._resolve = resolve;\n            _this._reject = reject;\n        });\n        this._completion.then(function () {\n            _this.active = false;\n            _this.on.complete.fire();\n        }, function (e) {\n            var wasActive = _this.active;\n            _this.active = false;\n            _this.on.error.fire(e);\n            _this.parent ?\n                _this.parent._reject(e) :\n                wasActive && _this.idbtrans && _this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name: name,\n        keyPath: keyPath,\n        unique: unique,\n        multi: multi,\n        auto: auto,\n        compound: compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name: name,\n        primKey: primKey,\n        indexes: indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; })\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nvar getMaxKey = function (IdbKeyRange) {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = function () { return [[]]; };\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = function () { return maxString; };\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return function () { return undefined; };\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return function (obj) { return getByKeyPath(obj, keyPath); };\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    var split = keyPath.split('.');\n    if (split.length === 1) {\n        return function (obj) { return obj[keyPath]; };\n    }\n    else {\n        return function (obj) { return getByKeyPath(obj, keyPath); };\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nvar _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            \"[\" + keyPath.join('+') + \"]\";\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        var tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {\n                    var keyPath = store.keyPath, autoIncrement = store.autoIncrement;\n                    var compound = isArray(keyPath);\n                    var outbound = keyPath == null;\n                    var indexByKeyPath = {};\n                    var result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound: outbound,\n                            compound: compound,\n                            keyPath: keyPath,\n                            autoIncrement: autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })\n                            .map(function (index) {\n                            var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;\n                            var compound = isArray(keyPath);\n                            var result = {\n                                name: name,\n                                compound: compound,\n                                keyPath: keyPath,\n                                unique: unique,\n                                multiEntry: multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;\n        var idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        var tableName = tableSchema.name;\n        function mutate(_a) {\n            var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;\n            return new Promise(function (resolve, reject) {\n                resolve = wrap(resolve);\n                var store = trans.objectStore(tableName);\n                var outbound = store.keyPath == null;\n                var isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                var length = (keys || values || { length: 1 }).length;\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                var req;\n                var reqs = [];\n                var failures = [];\n                var numFailures = 0;\n                var errorHandler = function (event) {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    var _a = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null], args1 = _a[0], args2 = _a[1];\n                    if (isAddOrPut) {\n                        for (var i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (var i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                var done = function (event) {\n                    var lastResult = event.target.result;\n                    reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });\n                    resolve({\n                        numFailures: numFailures,\n                        failures: failures,\n                        results: type === \"delete\" ? keys : reqs.map(function (req) { return req.result; }),\n                        lastResult: lastResult\n                    });\n                };\n                req.onerror = function (event) {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor(_a) {\n            var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;\n            return new Promise(function (resolve, reject) {\n                resolve = wrap(resolve);\n                var index = query.index, range = query.range;\n                var store = trans.objectStore(tableName);\n                var source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                var direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                var req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(function (ev) {\n                    var cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    var _cursorContinue = cursor.continue.bind(cursor);\n                    var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    var _cursorAdvance = cursor.advance.bind(cursor);\n                    var doThrowCursorIsNotStarted = function () { throw new Error(\"Cursor not started\"); };\n                    var doThrowCursorIsStopped = function () { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        var _this = this;\n                        var gotOne = 1;\n                        return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });\n                    };\n                    cursor.start = function (callback) {\n                        var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = function (value) {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        var guardedCallback = function () {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = function () { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(function (ev) {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return function (request) {\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var trans = request.trans, values = request.values, limit = request.limit, query = request.query;\n                    var nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    var index = query.index, range = query.range;\n                    var store = trans.objectStore(tableName);\n                    var source = index.isPrimaryKey ? store : store.index(index.name);\n                    var idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        var req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = function (event) { return resolve({ result: event.target.result }); };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        var count_1 = 0;\n                        var req_1 = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        var result_1 = [];\n                        req_1.onsuccess = function (event) {\n                            var cursor = req_1.result;\n                            if (!cursor)\n                                return resolve({ result: result_1 });\n                            result_1.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count_1 === limit)\n                                return resolve({ result: result_1 });\n                            cursor.continue();\n                        };\n                        req_1.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate: mutate,\n            getMany: function (_a) {\n                var trans = _a.trans, keys = _a.keys;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var store = trans.objectStore(tableName);\n                    var length = keys.length;\n                    var result = new Array(length);\n                    var keyCount = 0;\n                    var callbackCount = 0;\n                    var req;\n                    var successHandler = function (event) {\n                        var req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    var errorHandler = eventRejectHandler(reject);\n                    for (var i = 0; i < length; ++i) {\n                        var key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get: function (_a) {\n                var trans = _a.trans, key = _a.key;\n                return new Promise(function (resolve, reject) {\n                    resolve = wrap(resolve);\n                    var store = trans.objectStore(tableName);\n                    var req = store.get(key);\n                    req.onsuccess = function (event) { return resolve(event.target.result); };\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor: openCursor,\n            count: function (_a) {\n                var query = _a.query, trans = _a.trans;\n                var index = query.index, range = query.range;\n                return new Promise(function (resolve, reject) {\n                    var store = trans.objectStore(tableName);\n                    var source = index.isPrimaryKey ? store : store.index(index.name);\n                    var idbKeyRange = makeIDBKeyRange(range);\n                    var req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;\n    var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });\n    var tableMap = {};\n    tables.forEach(function (table) { return tableMap[table.name] = table; });\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table: function (name) {\n            var result = tableMap[name];\n            if (!result)\n                throw new Error(\"Table '\" + name + \"' not found\");\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema: schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce(function (down, _a) {\n        var create = _a.create;\n        return (__assign(__assign({}, down), create(down)));\n    }, stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {\n    var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;\n    var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore: dbcore\n    };\n}\nfunction generateMiddlewareStacks(_a, tmpTrans) {\n    var db = _a._novip;\n    var idbdb = tmpTrans.db;\n    var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(function (table) {\n        var tableName = table.name;\n        if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace(_a, objs, tableNames, dbschema) {\n    var db = _a._novip;\n    tableNames.forEach(function (tableName) {\n        var schema = dbschema[tableName];\n        objs.forEach(function (obj) {\n            var propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get: function () { return this.table(tableName); },\n                        set: function (value) {\n                            defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi(_a, objs) {\n    var db = _a._novip;\n    objs.forEach(function (obj) {\n        for (var key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    var globalSchema = db._dbSchema;\n    var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    var rejectTransaction = trans._reject.bind(trans);\n    var transless = PSD.transless || PSD;\n    newScope(function () {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(function (tableName) {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes(_a, oldVersion, trans, idbUpgradeTrans) {\n    var db = _a._novip;\n    var queue = [];\n    var versions = db._versions;\n    var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    var anyContentUpgraderHasRun = false;\n    var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });\n    versToRun.forEach(function (version) {\n        queue.push(function () {\n            var oldSchema = globalSchema;\n            var newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            var diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(function (tuple) {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(function (change) {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    var store_1 = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(function (idx) { return addIndex(store_1, idx); });\n                    change.change.forEach(function (idx) {\n                        store_1.deleteIndex(idx.name);\n                        addIndex(store_1, idx);\n                    });\n                    change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });\n                }\n            });\n            var contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                var upgradeSchema_1 = shallowClone(newSchema);\n                diff.del.forEach(function (table) {\n                    upgradeSchema_1[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);\n                trans.schema = upgradeSchema_1;\n                var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync_1) {\n                    incrementExpectedAwaits();\n                }\n                var returnValue_1;\n                var promiseFollowed = DexiePromise.follow(function () {\n                    returnValue_1 = contentUpgrade(trans);\n                    if (returnValue_1) {\n                        if (contentUpgradeIsAsync_1) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue_1.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue_1 && typeof returnValue_1.then === 'function' ?\n                    DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));\n            }\n        });\n        queue.push(function (idbtrans) {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                var newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(function () {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    var diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    var table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        var oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            var change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                var oldIndexes = oldDef.idxByName;\n                var newIndexes = newDef.idxByName;\n                var idxName = void 0;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(function (idx) { return addIndex(store, idx); });\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(function (tableName) {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {\n        return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);\n    });\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    var globalSchema = {};\n    var dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(function (storeName) {\n        var store = tmpTrans.objectStore(storeName);\n        var keyPath = store.keyPath;\n        var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        var indexes = [];\n        for (var j = 0; j < store.indexNames.length; ++j) {\n            var idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema(_a, idbdb, tmpTrans) {\n    var db = _a._novip;\n    db.verno = idbdb.version / 10;\n    var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    var diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));\n}\nfunction adjustToExistingIndexNames(_a, schema, idbtrans) {\n    var db = _a._novip;\n    var storeNames = idbtrans.db.objectStoreNames;\n    for (var i = 0; i < storeNames.length; ++i) {\n        var storeName = storeNames[i];\n        var store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (var j = 0; j < store.indexNames.length; ++j) {\n            var indexName = store.indexNames[j];\n            var keyPath = store.index(indexName).keyPath;\n            var dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                var indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map(function (index, indexNum) {\n        index = index.trim();\n        var name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        var keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nvar Version =  (function () {\n    function Version() {\n    }\n    Version.prototype._parseStoresSpec = function (stores, outSchema) {\n        keys(stores).forEach(function (tableName) {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(function (idx) {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    };\n    Version.prototype.stores = function (stores) {\n        var db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        var versions = db._versions;\n        var storesSpec = {};\n        var dbschema = {};\n        versions.forEach(function (version) {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    };\n    Version.prototype.upgrade = function (upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    };\n    return Version;\n}());\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    var dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB: indexedDB,\n            IDBKeyRange: IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames(_a) {\n    var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then(function (infos) {\n            return infos\n                .map(function (info) { return info.name; })\n                .filter(function (name) { return name !== DBNAMES_DB; });\n        })\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated(_a, name) {\n    var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);\n}\nfunction _onDatabaseDeleted(_a, name) {\n    var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    var state = db._state;\n    var indexedDB = db._deps.indexedDB;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(function () { return state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db; });\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    var openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    var resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {\n        throwIfCancelled();\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        var dbName = db.name;\n        var req = state.autoSchema ?\n            indexedDB.open(dbName) :\n            indexedDB.open(dbName, Math.round(db.verno * 10));\n        if (!req)\n            throw new exceptions.MissingAPI();\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = wrap(db._fireOnBlocked);\n        req.onupgradeneeded = wrap(function (e) {\n            upgradeTransaction = req.transaction;\n            if (state.autoSchema && !db._options.allowEmptyDB) {\n                req.onerror = preventDefault;\n                upgradeTransaction.abort();\n                req.result.close();\n                var delreq = indexedDB.deleteDatabase(dbName);\n                delreq.onsuccess = delreq.onerror = wrap(function () {\n                    reject(new exceptions.NoSuchDatabase(\"Database \" + dbName + \" doesnt exist\"));\n                });\n            }\n            else {\n                upgradeTransaction.onerror = eventRejectHandler(reject);\n                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                wasCreated = oldVer < 1;\n                db._novip.idbdb = req.result;\n                runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n            }\n        }, reject);\n        req.onsuccess = wrap(function () {\n            upgradeTransaction = null;\n            var idbdb = db._novip.idbdb = req.result;\n            var objectStoreNames = slice(idbdb.objectStoreNames);\n            if (objectStoreNames.length > 0)\n                try {\n                    var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                    if (state.autoSchema)\n                        readGlobalSchema(db, idbdb, tmpTrans);\n                    else {\n                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                        if (!verifyInstalledSchema(db, tmpTrans)) {\n                            console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\");\n                        }\n                    }\n                    generateMiddlewareStacks(db, tmpTrans);\n                }\n                catch (e) {\n                }\n            connections.push(db);\n            idbdb.onversionchange = wrap(function (ev) {\n                state.vcFired = true;\n                db.on(\"versionchange\").fire(ev);\n            });\n            idbdb.onclose = wrap(function (ev) {\n                db.on(\"close\").fire(ev);\n            });\n            if (wasCreated)\n                _onDatabaseCreated(db._deps, dbName);\n            resolve();\n        }, reject);\n    }).catch(function (err) {\n        if (err && err.name === 'UnknownError' && state.PR1398_maxLoop > 0) {\n            state.PR1398_maxLoop--;\n            console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n            return tryOpenDB();\n        }\n        else {\n            return DexiePromise.reject(err);\n        }\n    }); };\n    return DexiePromise.race([\n        openCanceller,\n        (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n    ]).then(function () {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);\n            }\n        });\n    }).finally(function () {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(function () {\n        return db;\n    }).catch(function (err) {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(function () {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return function (val) {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(function () {\n        var transless = PSD.transless || PSD;\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        var zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db._close();\n                    return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });\n                }\n                return rejection(ex);\n            }\n        }\n        var scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        var returnValue;\n        var promiseFollowed = DexiePromise.follow(function () {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")); })\n            : promiseFollowed.then(function () { return returnValue; })).then(function (x) {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(function () { return x; });\n        }).catch(function (e) {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    var result = isArray(a) ? a.slice() : [a];\n    for (var i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return __assign(__assign({}, down), { table: function (tableName) {\n            var table = down.table(tableName);\n            var schema = table.schema;\n            var indexLookup = {};\n            var allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                var keyPathAlias = getKeyPathAlias(keyPath);\n                var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                var isVirtual = keyTail > 0;\n                var virtualIndex = __assign(__assign({}, lowLevelIndex), { isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    var virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });\n                return virtualIndex;\n            }\n            var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {\n                var index = _a[_i];\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                var result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                var index = req.query.index;\n                return index.isVirtual ? __assign(__assign({}, req), { query: {\n                        index: index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    } }) : req;\n            }\n            var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {\n                    return table.count(translateRequest(req));\n                }, query: function (req) {\n                    return table.query(translateRequest(req));\n                }, openCursor: function (req) {\n                    var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        var virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value: function (key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get: function () {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get: function () {\n                                    var key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get: function () {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(function (cursor) { return cursor && createVirtualCursor(cursor); });\n                } });\n            return result;\n        } });\n}\nvar virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach(function (prop) {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                var apTypeName = toStringTag(ap);\n                var bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach(function (prop) {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nvar hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {\n            var downTable = downCore.table(tableName);\n            var primaryKey = downTable.schema.primaryKey;\n            var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {\n                    var dxTrans = PSD.trans;\n                    var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        var dxTrans = PSD.trans;\n                        var keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);\n                        if (req.type !== 'delete')\n                            req.values = __spreadArray([], req.values, true);\n                        if (req.keys)\n                            req.keys = __spreadArray([], req.keys, true);\n                        return getExistingValues(downTable, req, keys).then(function (existingValues) {\n                            var contexts = keys.map(function (key, i) {\n                                var existingValue = existingValues[i];\n                                var ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    var objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges_1) {\n                                        var requestedValue_1 = req.values[i];\n                                        Object.keys(additionalChanges_1).forEach(function (keyPath) {\n                                            if (hasOwn(requestedValue_1, keyPath)) {\n                                                requestedValue_1[keyPath] = additionalChanges_1[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(function (_a) {\n                                var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;\n                                for (var i = 0; i < keys.length; ++i) {\n                                    var primKey = results ? results[i] : keys[i];\n                                    var ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };\n                            }).catch(function (error) {\n                                contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })\n                            .then(function (_a) {\n                            var result = _a.result;\n                            return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);\n                                }\n                            });\n                        });\n                    }\n                } });\n            return tableMiddleware;\n        } })); }\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        var result = [];\n        for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nvar cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: function (core) {\n        return {\n            table: function (tableName) {\n                var table = core.table(tableName);\n                return __assign(__assign({}, table), { getMany: function (req) {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        var cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then(function (res) {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    }, mutate: function (req) {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    } });\n            },\n        };\n    },\n};\n\nvar _a;\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nvar RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        var rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, (_a = {\n        add: function (rangeSet) {\n            mergeRanges(this, rangeSet);\n            return this;\n        },\n        addKey: function (key) {\n            addRange(this, key, key);\n            return this;\n        },\n        addKeys: function (keys) {\n            var _this = this;\n            keys.forEach(function (key) { return addRange(_this, key, key); });\n            return this;\n        }\n    },\n    _a[iteratorSymbol] = function () {\n        return getRangeSetIterator(this);\n    },\n    _a));\nfunction addRange(target, from, to) {\n    var diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from: from, to: to, d: 1 });\n    var left = target.l;\n    var right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from: from, to: to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from: from, to: to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    var rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, _a) {\n        var from = _a.from, to = _a.to, l = _a.l, r = _a.r;\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    var i1 = getRangeSetIterator(rangeSet2);\n    var nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    var a = nextResult1.value;\n    var i2 = getRangeSetIterator(rangeSet1);\n    var nextResult2 = i2.next(a.from);\n    var b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    var state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next: function (key) {\n            var keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    var r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        var l = r === \"r\" ? \"l\" : \"r\";\n        var rootClone = __assign({}, target);\n        var oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth(_a) {\n    var r = _a.r, l = _a.l;\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nvar observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: function (core) {\n        var dbName = core.schema.name;\n        var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return __assign(__assign({}, core), { table: function (tableName) {\n                var table = core.table(tableName);\n                var schema = table.schema;\n                var primaryKey = schema.primaryKey;\n                var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;\n                var tableClone = __assign(__assign({}, table), { mutate: function (req) {\n                        var trans = req.trans;\n                        var mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        var getRangeSet = function (indexName) {\n                            var part = \"idb://\" + dbName + \"/\" + tableName + \"/\" + indexName;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        var pkRangeSet = getRangeSet(\"\");\n                        var delsRangeSet = getRangeSet(\":dels\");\n                        var type = req.type;\n                        var _a = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [], keys = _a[0], newObjs = _a[1];\n                        var oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then(function (res) {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                var oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                var range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });\n                            }\n                            return res;\n                        });\n                    } });\n                var getRange = function (_a) {\n                    var _b, _c;\n                    var _d = _a.query, index = _d.index, range = _d.range;\n                    return [\n                        index,\n                        new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),\n                    ];\n                };\n                var readSubscribers = {\n                    get: function (req) { return [primaryKey, new RangeSet(req.key)]; },\n                    getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(function (method) {\n                    tableClone[method] = function (req) {\n                        var subscr = PSD.subscr;\n                        if (subscr) {\n                            var getRangeSet = function (indexName) {\n                                var part = \"idb://\" + dbName + \"/\" + tableName + \"/\" + indexName;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            var pkRangeSet_1 = getRangeSet(\"\");\n                            var delsRangeSet_1 = getRangeSet(\":dels\");\n                            var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet_1.add(FULL_RANGE);\n                                }\n                                else {\n                                    var keysPromise_1 = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query(__assign(__assign({}, req), { values: false }));\n                                    return table[method].apply(this, arguments).then(function (res) {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise_1.then(function (_a) {\n                                                    var resultingKeys = _a.result;\n                                                    pkRangeSet_1.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            var pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet_1.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet_1.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            var cursor_1 = res;\n                                            var wantValues_1 = req.values;\n                                            return (cursor_1 &&\n                                                Object.create(cursor_1, {\n                                                    key: {\n                                                        get: function () {\n                                                            delsRangeSet_1.addKey(cursor_1.primaryKey);\n                                                            return cursor_1.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get: function () {\n                                                            var pkey = cursor_1.primaryKey;\n                                                            delsRangeSet_1.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get: function () {\n                                                            wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);\n                                                            return cursor_1.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            } });\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        var rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)\n            ? key.forEach(function (key) { return rangeSet.addKey(key); })\n            : rangeSet.addKey(key); };\n        (oldObjs || newObjs).forEach(function (_, i) {\n            var oldKey = oldObjs && extractKey(oldObjs[i]);\n            var newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nvar Dexie$1 =  (function () {\n    function Dexie(name, options) {\n        var _this = this;\n        this._middlewares = {};\n        this.verno = 0;\n        var deps = Dexie.dependencies;\n        this._options = options = __assign({\n            addons: Dexie.addons, autoOpen: true,\n            indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange }, options);\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        var addons = options.addons;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        var state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise(function (resolve) {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise(function (_, reject) {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {\n            return function (subscriber, bSticky) {\n                Dexie.vip(function () {\n                    var state = _this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        var db_1 = _this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db_1.on.ready.unsubscribe(subscriber);\n                                db_1.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", function (ev) {\n            if (ev.newVersion > 0)\n                console.warn(\"Another connection wants to upgrade database '\" + _this.name + \"'. Closing db now to resume the upgrade.\");\n            else\n                console.warn(\"Another connection wants to delete database '\" + _this.name + \"'. Closing db now to resume the delete request.\");\n            _this.close();\n        });\n        this.on(\"blocked\", function (ev) {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(\"Dexie.delete('\" + _this.name + \"') was blocked\");\n            else\n                console.warn(\"Upgrade '\" + _this.name + \"' blocked by other connection holding version \" + ev.oldVersion / 10);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };\n        this._fireOnBlocked = function (ev) {\n            _this.on(\"blocked\").fire(ev);\n            connections\n                .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })\n                .map(function (c) { return c.on(\"versionchange\").fire(ev); });\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(function (addon) { return addon(_this); });\n    }\n    Dexie.prototype.version = function (versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(\"Given version is not a positive number\");\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        var versions = this._versions;\n        var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    };\n    Dexie.prototype._whenReady = function (fn) {\n        var _this = this;\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {\n            if (_this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));\n            }\n            if (!_this._state.isBeingOpened) {\n                if (!_this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                _this.open().catch(nop);\n            }\n            _this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    };\n    Dexie.prototype.use = function (_a) {\n        var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;\n        if (name)\n            this.unuse({ stack: stack, name: name });\n        var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });\n        middlewares.sort(function (a, b) { return a.level - b.level; });\n        return this;\n    };\n    Dexie.prototype.unuse = function (_a) {\n        var stack = _a.stack, name = _a.name, create = _a.create;\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {\n                return create ? mw.create !== create :\n                    name ? mw.name !== name :\n                        false;\n            });\n        }\n        return this;\n    };\n    Dexie.prototype.open = function () {\n        return dexieOpen(this);\n    };\n    Dexie.prototype._close = function () {\n        var state = this._state;\n        var idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(function (resolve) {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise(function (_, reject) {\n            state.cancelOpen = reject;\n        });\n    };\n    Dexie.prototype.close = function () {\n        this._close();\n        var state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    };\n    Dexie.prototype.delete = function () {\n        var _this = this;\n        var hasArguments = arguments.length > 0;\n        var state = this._state;\n        return new DexiePromise(function (resolve, reject) {\n            var doDelete = function () {\n                _this.close();\n                var req = _this._deps.indexedDB.deleteDatabase(_this.name);\n                req.onsuccess = wrap(function () {\n                    _onDatabaseDeleted(_this._deps, _this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = _this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    };\n    Dexie.prototype.backendDB = function () {\n        return this.idbdb;\n    };\n    Dexie.prototype.isOpen = function () {\n        return this.idbdb !== null;\n    };\n    Dexie.prototype.hasBeenClosed = function () {\n        var dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    };\n    Dexie.prototype.hasFailed = function () {\n        return this._state.dbOpenError !== null;\n    };\n    Dexie.prototype.dynamicallyOpened = function () {\n        return this._state.autoSchema;\n    };\n    Object.defineProperty(Dexie.prototype, \"tables\", {\n        get: function () {\n            var _this = this;\n            return keys(this._allTables).map(function (name) { return _this._allTables[name]; });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Dexie.prototype.transaction = function () {\n        var args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    };\n    Dexie.prototype._transaction = function (mode, tables, scopeFunc) {\n        var _this = this;\n        var parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        var onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        var idbMode, storeNames;\n        try {\n            storeNames = tables.map(function (table) {\n                var storeName = table instanceof _this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(function (storeName) {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, function (_, reject) { reject(e); }) :\n                rejection(e);\n        }\n        var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :\n                this._whenReady(enterTransaction));\n    };\n    Dexie.prototype.table = function (tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(\"Table \" + tableName + \" does not exist\");\n        }\n        return this._allTables[tableName];\n    };\n    return Dexie;\n}());\n\nvar symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nvar Observable =  (function () {\n    function Observable(subscribe) {\n        this._subscribe = subscribe;\n    }\n    Observable.prototype.subscribe = function (x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error: error, complete: complete } : x);\n    };\n    Observable.prototype[symbolObservable] = function () {\n        return this;\n    };\n    return Observable;\n}());\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(function (part) {\n        var rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    var hasValue = false;\n    var currentValue = undefined;\n    var observable = new Observable(function (observer) {\n        var scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            var exec = function () { return newScope(querier, { subscr: subscr, trans: null }); };\n            var rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        var closed = false;\n        var accumMuts = {};\n        var currentObs = {};\n        var subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: function () {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        var querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some(function (key) {\n                return accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]);\n            });\n        }\n        var mutationListener = function (parts) {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        var doQuery = function () {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            var subscr = {};\n            var ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then(function (result) {\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, function (err) {\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = function () { return hasValue; };\n    observable.getValue = function () { return currentValue; };\n    return observable;\n}\n\nvar domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nvar Dexie = Dexie$1;\nprops(Dexie, __assign(__assign({}, fullNameExceptions), {\n    delete: function (databaseName) {\n        var db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists: function (name) {\n        return new Dexie(name, { addons: [] }).open().then(function (db) {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', function () { return false; });\n    },\n    getDatabaseNames: function (cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass: function () {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    }, ignoreTransaction: function (scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    }, vip: vip, async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    }, spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: function () { return PSD.trans || null; }\n    }, waitFor: function (promiseOrFunction, optionalTimeout) {\n        var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: function () { return debug; },\n        set: function (value) {\n            setDebug(value, value === 'dexie' ? function () { return true; } : dexieStackFrameFilter);\n        }\n    },\n    derive: derive, extend: extend, props: props, override: override,\n    Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,\n    getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')\n        .map(function (n) { return parseInt(n); })\n        .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {\n        if (!propagatingLocally) {\n            var event_1;\n            if (isIEOrEdge) {\n                event_1 = document.createEvent('CustomEvent');\n                event_1.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event_1);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {\n        var detail = _a.detail;\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    var wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nvar propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    var bc_1 = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc_1.unref === 'function') {\n        bc_1.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n        if (!propagatingLocally) {\n            bc_1.postMessage(changedParts);\n        }\n    });\n    bc_1.onmessage = function (ev) {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts: changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    __spreadArray([], self['clients'].matchAll({ includeUncontrolled: true }), true).forEach(function (client) {\n                        return client.postMessage({\n                            type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                            changedParts: changedParts,\n                        });\n                    });\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('storage', function (ev) {\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                var data = JSON.parse(ev.newValue);\n                if (data)\n                    propagateLocally(data.changedParts);\n            }\n        });\n    }\n    var swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally(_a) {\n    var data = _a.data;\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\n\n//# sourceMappingURL=dexie.mjs.map\n\n/* WEBPACK VAR INJECTION */}.call(this, require(\"./../../webpack/buildin/global.js\"), require(\"./../../timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/dexie/dist/dexie.mjs?");

/***/ }),

/***/ "../../node_modules/domready/ready.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/domready/ready.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n  * domready (c) Dustin Diaz 2014 - License MIT\n  */\n!function (name, definition) {\n\n  if (true) module.exports = definition()\n  else {}\n\n}('domready', function () {\n\n  var fns = [], listener\n    , doc = document\n    , hack = doc.documentElement.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)\n\n\n  if (!loaded)\n  doc.addEventListener(domContentLoaded, listener = function () {\n    doc.removeEventListener(domContentLoaded, listener)\n    loaded = 1\n    while (listener = fns.shift()) listener()\n  })\n\n  return function (fn) {\n    loaded ? setTimeout(fn, 0) : fns.push(fn)\n  }\n\n});\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/domready/ready.js?");

/***/ }),

/***/ "../../node_modules/dup/dup.js":
/*!*********************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/dup/dup.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction dupe_array(count, value, i) {\n  var c = count[i]|0\n  if(c <= 0) {\n    return []\n  }\n  var result = new Array(c), j\n  if(i === count.length-1) {\n    for(j=0; j<c; ++j) {\n      result[j] = value\n    }\n  } else {\n    for(j=0; j<c; ++j) {\n      result[j] = dupe_array(count, value, i+1)\n    }\n  }\n  return result\n}\n\nfunction dupe_number(count, value) {\n  var result, i\n  result = new Array(count)\n  for(i=0; i<count; ++i) {\n    result[i] = value\n  }\n  return result\n}\n\nfunction dupe(count, value) {\n  if(typeof value === \"undefined\") {\n    value = 0\n  }\n  switch(typeof count) {\n    case \"number\":\n      if(count > 0) {\n        return dupe_number(count|0, value)\n      }\n    break\n    case \"object\":\n      if(typeof (count.length) === \"number\") {\n        return dupe_array(count, value, 0)\n      }\n    break\n  }\n  return []\n}\n\nmodule.exports = dupe\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/dup/dup.js?");

/***/ }),

/***/ "../../node_modules/ent-comp/src/ECS.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/ent-comp/src/ECS.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = ECS\nvar DataStore = __webpack_require__(/*! ./dataStore */ \"../../node_modules/ent-comp/src/dataStore.js\")\n\n\n\n/**\n * \n * # ent-comp API Documentation:\n * \n*/\n\n\n\n/**\n * @class ECS\n * \n * Creates a new entity-component-system manager.\n * \n * ```js\n * var ECS = require('ent-comp')\n * var ecs = new ECS()\n * ```\n*/\n\nfunction ECS() {\n\tvar self = this\n\n\t/** \n\t * Hash of component definitions. Also aliased to `comps`.\n\t * \n\t * ```js\n\t * var comp = { name: 'foo' }\n\t * ecs.createComponent(comp)\n\t * ecs.components['foo'] === comp // true\n\t * ecs.comps['foo'] // same\n\t * ```\n\t*/\n\tthis.components = {}\n\tthis.comps = this.components\n\n\n\n\t/*\n\t * \n\t * \t\tinternals:\n\t * \n\t*/\n\n\tvar components = this.components\n\n\t// counter for entity IDs\n\tvar UID = 1\n\n\t// Storage for all component state data:\n\t// storage['component-name'] = { hash:{}, list:[] }\n\tvar storage = {}\n\n\t// flat arrays of names of components with systems\n\tvar systems = []\n\tvar renderSystems = []\n\n\t// queues for deferred operations\n\tvar deferredEntityRemovals = []\n\tvar deferredCompRemovals = []\n\tvar deferredMultiCompRemovals = []\n\n\n\n\t/*\n\t * \n\t * \n\t * \t\t\t\tPublic API\n\t * \n\t * \n\t*/\n\n\n\n\n\t/**\n\t * Creates a new entity id (currently just an incrementing integer).\n\t * \n\t * Optionally takes a list of component names to add to the entity (with default state data).\n\t * \n\t * ```js\n\t * var id1 = ecs.createEntity()\n\t * var id2 = ecs.createEntity([ 'some-component', 'other-component' ])\n\t * ```\n\t*/\n\tthis.createEntity = function (compList) {\n\t\tvar id = UID++\n\t\tif (compList && compList.length) {\n\t\t\tcompList.forEach(compName => self.addComponent(id, compName))\n\t\t}\n\t\treturn id\n\t}\n\n\n\n\t/**\n\t * Deletes an entity, which in practice just means removing all its components.\n\t * By default the actual removal is deferred (since entities will tend to \n\t * call this on themselves during event handlers, etc).\n\t * Pass a truthy second parameter to force immediate removal.\n\t * \n\t * ```js\n\t * ecs.deleteEntity(id)\n\t * ecs.deleteEntity(id2, true) // deletes immediately\n\t * ```\n\t * \n\t * Note that if you need to delete large numbers of entities at once,\n\t * and you know which components they have, this method will be a bit \n\t * slower than removing the components manually.\n\t*/\n\tthis.deleteEntity = function (entID, immediately) {\n\t\tif (immediately) {\n\t\t\tdeleteEntityNow(entID)\n\t\t} else {\n\t\t\tdeferredEntityRemovals.push(entID)\n\t\t\tmakeDeferralTimeout()\n\t\t}\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\t/**\n\t * Creates a new component from a definition object. \n\t * The definition must have a `name`; all other properties are optional.\n\t * \n\t * Returns the component name, to make it easy to grab when the component\n\t * is being `require`d from a module.\n\t * \n\t * ```js\n\t * var comp = {\n\t * \t name: 'some-unique-string',\n\t * \t state: {},\n\t * \t onAdd:        function(id, state){ },\n\t * \t onRemove:     function(id, state){ },\n\t * \t system:       function(dt, states){ },\n\t * \t renderSystem: function(dt, states){ },\n\t * \t multi: false,\n\t * }\n\t * \n\t * var name = ecs.createComponent( comp )\n\t * // name == 'a-unique-string'\n\t * ```\n\t * \n\t * Note the `multi` flag - for components where this is true, a given \n\t * entity can have multiple state objects for that component.\n\t * For multi-components, APIs that would normally return a state object \n\t * (like `getState`) will instead return an array of them.\n\t*/\n\tthis.createComponent = function (compDefn) {\n\t\tif (!compDefn) throw 'Missing component definition'\n\t\tvar name = compDefn.name\n\t\tif (!name) throw 'Component definition must have a name property.'\n\t\tif (typeof name !== 'string') throw 'Component name must be a string.'\n\t\tif (name === '') throw 'Component name must be a non-empty string.'\n\t\tif (storage[name]) throw `Component ${name} already exists.`\n\n\t\t// rebuild definition object for monomorphism\n\t\tvar internalDef = {}\n\t\tinternalDef.name = name\n\t\tinternalDef.state = compDefn.state || {}\n\t\tinternalDef.onAdd = compDefn.onAdd || null\n\t\tinternalDef.onRemove = compDefn.onRemove || null\n\t\tinternalDef.system = compDefn.system || null\n\t\tinternalDef.renderSystem = compDefn.renderSystem || null\n\t\tinternalDef.multi = !!compDefn.multi\n\n\t\tcomponents[name] = internalDef\n\t\tstorage[name] = DataStore.create()\n\n\t\tif (internalDef.system) systems.push(name)\n\t\tif (internalDef.renderSystem) renderSystems.push(name)\n\n\t\treturn name\n\t}\n\n\n\n\n\n\t/**\n\t * Deletes the component definition with the given name. \n\t * First removes the component from all entities that have it.\n\t * This probably shouldn't be called in real-world usage\n\t * (better to define all components when you begin and leave them be)\n\t * but it's here if you need it.\n\t * \n\t * ```js\n\t * ecs.deleteComponent( comp.name )\n\t * ```\n\t*/\n\tthis.deleteComponent = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}`\n\n\t\tdata.list.forEach(obj => {\n\t\t\tvar id = obj.__id || obj[0].__id\n\t\t\tself.removeComponent(id, compName, true)\n\t\t})\n\n\t\tvar i = systems.indexOf(compName)\n\t\tvar j = renderSystems.indexOf(compName)\n\t\tif (i > -1) systems.splice(i, 1)\n\t\tif (j > -1) renderSystems.splice(j, 1)\n\n\t\tdelete components[compName]\n\t\tdelete storage[compName]\n\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Adds a component to an entity, optionally initializing the state object.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'foo', {val:20})\n\t * ecs.getState(id, 'foo').val // 20\n\t * ```\n\t*/\n\tthis.addComponent = function (entID, compName, state) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\n\t\t// if the component is pending removal, remove it so it can be readded\n\t\tvar pendingRemoval = false\n\t\tdeferredCompRemovals.forEach(obj => {\n\t\t\tif (obj.id === entID && obj.compName === compName) pendingRemoval = true\n\t\t})\n\t\tif (pendingRemoval) doDeferredComponentRemovals()\n\n\t\tif (data.hash[entID] && !def.multi) throw `Entity ${entID} already has component: ${compName}.`\n\n\t\t// create new component state object for this entity\n\t\tvar newState = Object.assign({}, { __id: entID }, def.state, state)\n\n\t\t// just in case passed-in state object had an __id property\n\t\tnewState.__id = entID\n\n\t\t// add to dataStore - for multi components, may already be present\n\t\tif (def.multi) {\n\t\t\tvar statesArr = data.hash[entID]\n\t\t\tif (!statesArr) {\n\t\t\t\tstatesArr = []\n\t\t\t\tDataStore.add(data, entID, statesArr)\n\t\t\t}\n\t\t\tstatesArr.push(newState)\n\t\t} else {\n\t\t\tDataStore.add(data, entID, newState)\n\t\t}\n\n\t\t// call handler and return\n\t\tif (def.onAdd) def.onAdd(entID, newState)\n\n\t\treturn this\n\t}\n\n\n\n\t/**\n\t * Checks if an entity has a component.\n\t * \n\t * ```js\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.hasComponent(id, 'foo') // true\n\t * ```\n\t*/\n\n\tthis.hasComponent = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn (data.hash[entID] !== undefined)\n\t}\n\n\n\n\n\n\t/**\n\t * Removes a component from an entity, deleting any state data.\n\t * \n\t * ```js\n\t * ecs.removeComponent(id, 'foo', true) // final arg means \"immediately\"\n\t * ecs.hasComponent(id, 'foo') // false\n\t * ecs.removeComponent(id, 'bar')\n\t * ecs.hasComponent(id, 'bar') // true - by default the removal is asynchronous\n\t * ```\n\t*/\n\tthis.removeComponent = function (entID, compName, immediately) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\n\t\t// if comp isn't present, fail silently for multi or throw otherwise\n\t\tif (!data.hash[entID]) {\n\t\t\tif (def.multi) return self\n\t\t\telse throw `Entity ${entID} does not have component: ${compName} to remove.`\n\t\t}\n\n\t\t// defer or remove\n\t\tif (immediately) {\n\t\t\tremoveComponentNow(entID, compName)\n\t\t} else {\n\t\t\tdeferredCompRemovals.push({\n\t\t\t\tid: entID,\n\t\t\t\tcompName: compName,\n\t\t\t})\n\t\t\tmakeDeferralTimeout()\n\t\t}\n\n\t\treturn self\n\t}\n\n\n\n\n\n\t/**\n\t * Get the component state for a given entity.\n\t * It will automatically have an `__id` property for the entity id.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.getState(id, 'foo').val  // 0\n\t * ecs.getState(id, 'foo').__id // equals id\n\t * ```\n\t*/\n\n\tthis.getState = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn data.hash[entID]\n\t}\n\n\n\n\n\t/**\n\t * Get an array of state objects for every entity with the given component. \n\t * Each one will have an `__id` property for the entity id it refers to.\n\t * Don't add or remove elements from the returned list!\n\t * \n\t * ```js\n\t * var arr = ecs.getStatesList('foo')\n\t * // returns something shaped like:\n\t * //   [ {__id:0, x:1}, {__id:7, x:2}  ]\n\t * ```  \n\t*/\n\n\tECS.prototype.getStatesList = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn data.list\n\t}\n\n\n\n\n\t/**\n\t * Returns a `getState`-like accessor bound to a given component name. \n\t * The accessor is much faster than `getState`, so you should create an accessor \n\t * for any component whose state you'll be accessing a lot.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'size',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'size')\n\t * var getSize = ecs.getStateAccessor('size')\n\t * getSize(id).val // 0\n\t * ```  \n\t*/\n\n\tthis.getStateAccessor = function (compName) {\n\t\tif (!storage[compName]) throw `Unknown component: ${compName}.`\n\t\tvar hash = storage[compName].hash\n\t\treturn function (entID) {\n\t\t\treturn hash[entID]\n\t\t}\n\t}\n\n\n\n\n\t/**\n\t * Returns a `hasComponent`-like accessor function bound to a given component name. \n\t * The accessor is much faster than `hasComponent`.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * })\n\t * ecs.addComponent(id, 'foo')\n\t * var hasFoo = ecs.getComponentAccessor('foo')\n\t * hasFoo(id) // true\n\t * ```  \n\t*/\n\n\tthis.getComponentAccessor = function (compName) {\n\t\tif (!storage[compName]) throw `Unknown component: ${compName}.`\n\t\tvar hash = storage[compName].hash\n\t\treturn function (entID) {\n\t\t\treturn (hash[entID] !== undefined) // TODO\n\t\t}\n\t}\n\n\n\n\n\n\t/**\n\t * Tells the ECS that a game tick has occurred, causing component \n\t * `system` functions to get called.\n\t * \n\t * The optional parameter simply gets passed to the system functions. \n\t * It's meant to be a timestep, but can be used (or not used) as you like.    \n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \tsystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t\tstates.forEach(state => {\n\t * \t\t\tconsole.log('Entity ID: ', state.__id)\n\t * \t\t})\n\t * \t}\n\t * })\n\t * ecs.tick(30) // triggers log statements\n\t * ```\n\t*/\n\n\tthis.tick = function (dt) {\n\t\trunAllDeferredRemovals()\n\t\tsystems.forEach(compName => {\n\t\t\tvar list = storage[compName].list\n\t\t\tvar comp = components[compName]\n\t\t\tcomp.system(dt, list)\n\t\t})\n\t\trunAllDeferredRemovals()\n\t\treturn self\n\t}\n\n\n\n\t/**\n\t * Functions exactly like `tick`, but calls `renderSystem` functions.\n\t * this effectively gives you a second set of systems that are \n\t * called with separate timing, in case you want to \n\t * [tick and render in separate loops](http://gafferongames.com/game-physics/fix-your-timestep/)\n\t * (which you should!).\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \trenderSystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t}\n\t * })\n\t * ecs.render(16.666)\n\t * ```\n\t*/\n\n\tthis.render = function (dt) {\n\t\trunAllDeferredRemovals()\n\t\trenderSystems.forEach(compName => {\n\t\t\tvar list = storage[compName].list\n\t\t\tvar comp = components[compName]\n\t\t\tcomp.renderSystem(dt, list)\n\t\t})\n\t\trunAllDeferredRemovals()\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Removes a particular state instance of a multi-component.\n\t * Pass a final truthy argument to make this happen synchronously - \n\t * but be careful, that will splice an element out of the multi-component array,\n\t * changing the indexes of subsequent elements.\n\t * \n\t * ```js\n\t * ecs.getState(id, 'foo')   // [ state1, state2, state3 ]\n\t * ecs.removeMultiComponent(id, 'foo', 1, true)  // true means: immediately\n\t * ecs.getState(id, 'foo')   // [ state1, state3 ]\n\t * ```\n\t */\n\tthis.removeMultiComponent = function (entID, compName, index, immediately) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\tif (!def.multi) throw 'removeMultiComponent called on non-multi component'\n\n\t\t// throw if comp isn't present, or multicomp isn't present at index\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr || !statesArr[index]) {\n\t\t\tthrow `Multicomponent ${compName} instance not found at index ${index}`\n\t\t}\n\n\t\t// index removals by object, in case indexes change later\n\t\tvar stateToRemove = statesArr[index]\n\t\tif (immediately) {\n\t\t\tremoveMultiCompNow(entID, compName, stateToRemove)\n\t\t} else {\n\t\t\tdeferredMultiCompRemovals.push({\n\t\t\t\tid: entID,\n\t\t\t\tcompName: compName,\n\t\t\t\tstate: stateToRemove,\n\t\t\t})\n\t\t}\n\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t *\t\tinternal implementation of various delete operations\n\t * \n\t * \n\t*/\n\n\n\t// delete entity - meaning simply remove all its components\n\tfunction deleteEntityNow(entID) {\n\t\t// For now loop over all components\n\t\t// Could speed this up by keeping a hash of components held by each entity?\n\t\tObject.keys(storage).forEach(compName => {\n\t\t\tvar data = storage[compName]\n\t\t\tif (data.hash[entID]) removeComponentNow(entID, compName)\n\t\t})\n\t}\n\n\n\t// remove given component from an entity\n\tfunction removeComponentNow(entID, compName) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) return\n\t\tif (!data.hash[entID]) return // probably got removed twice during deferral\n\n\t\t// call onRemove handler - on each instance for multi components\n\t\tif (def.onRemove) {\n\t\t\tif (def.multi) {\n\t\t\t\tdata.hash[entID].forEach(state => {\n\t\t\t\t\tdef.onRemove(entID, state)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tdef.onRemove(entID, data.hash[entID])\n\t\t\t}\n\t\t}\n\n\t\t// if multi, kill the states array to hopefully free the objects\n\t\tif (def.multi) data.hash[entID].length = 0\n\n\t\t// actual removal from data store\n\t\tDataStore.remove(data, entID)\n\t}\n\n\n\n\t// remove one state from a multi component\n\tfunction removeMultiCompNow(entID, compName, stateObj) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr) return\n\n\t\tvar i = statesArr.indexOf(stateObj)\n\t\tif (i < 0) return\n\t\tif (def.onRemove) {\n\t\t\tdef.onRemove(entID, stateObj)\n\t\t}\n\t\tstatesArr.splice(i, 1)\n\n\t\t// if this leaves the states list empty, remove the whole component\n\t\tif (statesArr.length === 0) {\n\t\t\tremoveComponentNow(entID, compName)\n\t\t}\n\t}\n\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t *\t\tinternals for handling deferrals\n\t * \n\t * \n\t*/\n\n\n\n\t// debouncer - called whenever a deferral is queued\n\tfunction makeDeferralTimeout() {\n\t\tif (deferralTimeoutPending) return\n\t\tdeferralTimeoutPending = true\n\t\tsetTimeout(function () {\n\t\t\tdeferralTimeoutPending = false\n\t\t\trunAllDeferredRemovals()\n\t\t}, 1)\n\t}\n\tvar deferralTimeoutPending = false\n\n\n\t// Ping all removal queues. \n\t// called before and after tick/render, and after deferrals are queued\n\tfunction runAllDeferredRemovals() {\n\t\tdoDeferredComponentRemovals()\n\t\tdoDeferredMultiComponentRemovals()\n\t\tdoDeferredEntityRemovals()\n\t}\n\n\n\t// entities - queue of entity IDs\n\tfunction doDeferredEntityRemovals() {\n\t\twhile (deferredEntityRemovals.length) {\n\t\t\tvar entID = deferredEntityRemovals.pop()\n\t\t\tdeleteEntityNow(entID)\n\t\t}\n\t}\n\n\n\t// components - queue of { id, compName }\n\tfunction doDeferredComponentRemovals() {\n\t\twhile (deferredCompRemovals.length) {\n\t\t\tvar obj = deferredCompRemovals.pop()\n\t\t\tremoveComponentNow(obj.id, obj.compName)\n\t\t}\n\t}\n\n\n\t// multi components - queue of { id, compName, state }\n\tfunction doDeferredMultiComponentRemovals(ecs) {\n\t\twhile (deferredMultiCompRemovals.length) {\n\t\t\tvar obj = deferredMultiCompRemovals.pop()\n\t\t\tremoveMultiCompNow(obj.id, obj.compName, obj.state)\n\t\t\tobj.state = null\n\t\t}\n\t}\n\n\n\n}\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/ent-comp/src/ECS.js?");

/***/ }),

/***/ "../../node_modules/ent-comp/src/dataStore.js":
/*!************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/ent-comp/src/dataStore.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n/*\n * \n *      Encapsulates (mostly) a collection of objects, \n *      exposed both as a hash and as an array\n *      _map maps hash id to list index\n * \n *      Note this is a dumb store, it doesn't check any inputs at all.\n *      It also assumes every stored data object is stored like:\n *          DataStore.add(data, 37, {__id:37} )\n * \n*/\n\n\nmodule.exports = {\n\n    create: function () {\n        return {\n            list: [],\n            hash: {},\n            _map: {},\n        }\n    },\n\n\n    add: function (data, id, object) {\n        data.list.push(object)\n        data.hash[id] = object\n        data._map[id] = data.list.length - 1\n    },\n\n\n    remove: function (data, id) {\n        // splice out of list\n        var index = data._map[id]\n        if (index === data.list.length - 1) {\n            data.list.pop()\n        } else {\n            // replace element to be spliced with element from end\n            var movedItem = data.list.pop()\n            data.list[index] = movedItem\n            // watch out, this bit breaks encapsulation by assuming object's contents\n            // alternative would be to look through map for movedID's index\n            var movedID = movedItem.__id || movedItem[0].__id\n            data._map[movedID] = index\n        }\n        // finish\n        delete data.hash[id]\n        delete data._map[id]\n    },\n\n\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/ent-comp/src/dataStore.js?");

/***/ }),

/***/ "../../node_modules/events/events.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/events/events.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/events/events.js?");

/***/ }),

/***/ "../../node_modules/fast-voxel-raycast/index.js":
/*!**************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/fast-voxel-raycast/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction traceRay_impl( getVoxel,\n\tpx, py, pz,\n\tdx, dy, dz,\n\tmax_d, hit_pos, hit_norm) {\n\t\n\t// consider raycast vector to be parametrized by t\n\t//   vec = [px,py,pz] + t * [dx,dy,dz]\n\t\n\t// algo below is as described by this paper:\n\t// http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\t\n\tvar t = 0.0\n\t\t, floor = Math.floor\n\t\t, ix = floor(px) | 0\n\t\t, iy = floor(py) | 0\n\t\t, iz = floor(pz) | 0\n\n\t\t, stepx = (dx > 0) ? 1 : -1\n\t\t, stepy = (dy > 0) ? 1 : -1\n\t\t, stepz = (dz > 0) ? 1 : -1\n\t\t\n\t// dx,dy,dz are already normalized\n\t\t, txDelta = Math.abs(1 / dx)\n\t\t, tyDelta = Math.abs(1 / dy)\n\t\t, tzDelta = Math.abs(1 / dz)\n\n\t\t, xdist = (stepx > 0) ? (ix + 1 - px) : (px - ix)\n\t\t, ydist = (stepy > 0) ? (iy + 1 - py) : (py - iy)\n\t\t, zdist = (stepz > 0) ? (iz + 1 - pz) : (pz - iz)\n\t\t\n\t// location of nearest voxel boundary, in units of t \n\t\t, txMax = (txDelta < Infinity) ? txDelta * xdist : Infinity\n\t\t, tyMax = (tyDelta < Infinity) ? tyDelta * ydist : Infinity\n\t\t, tzMax = (tzDelta < Infinity) ? tzDelta * zdist : Infinity\n\n\t\t, steppedIndex = -1\n\t\n\t// main loop along raycast vector\n\twhile (t <= max_d) {\n\t\t\n\t\t// exit check\n\t\tvar b = getVoxel(ix, iy, iz)\n\t\tif (b) {\n\t\t\tif (hit_pos) {\n\t\t\t\thit_pos[0] = px + t * dx\n\t\t\t\thit_pos[1] = py + t * dy\n\t\t\t\thit_pos[2] = pz + t * dz\n\t\t\t}\n\t\t\tif (hit_norm) {\n\t\t\t\thit_norm[0] = hit_norm[1] = hit_norm[2] = 0\n\t\t\t\tif (steppedIndex === 0) hit_norm[0] = -stepx\n\t\t\t\tif (steppedIndex === 1) hit_norm[1] = -stepy\n\t\t\t\tif (steppedIndex === 2) hit_norm[2] = -stepz\n\t\t\t}\n\t\t\treturn b\n\t\t}\n\t\t\n\t\t// advance t to next nearest voxel boundary\n\t\tif (txMax < tyMax) {\n\t\t\tif (txMax < tzMax) {\n\t\t\t\tix += stepx\n\t\t\t\tt = txMax\n\t\t\t\ttxMax += txDelta\n\t\t\t\tsteppedIndex = 0\n\t\t\t} else {\n\t\t\t\tiz += stepz\n\t\t\t\tt = tzMax\n\t\t\t\ttzMax += tzDelta\n\t\t\t\tsteppedIndex = 2\n\t\t\t}\n\t\t} else {\n\t\t\tif (tyMax < tzMax) {\n\t\t\t\tiy += stepy\n\t\t\t\tt = tyMax\n\t\t\t\ttyMax += tyDelta\n\t\t\t\tsteppedIndex = 1\n\t\t\t} else {\n\t\t\t\tiz += stepz\n\t\t\t\tt = tzMax\n\t\t\t\ttzMax += tzDelta\n\t\t\t\tsteppedIndex = 2\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t// no voxel hit found\n\tif (hit_pos) {\n\t\thit_pos[0] = px + t * dx\n\t\thit_pos[1] = py + t * dy\n\t\thit_pos[2] = pz + t * dz\n\t}\n\tif (hit_norm) {\n\t\thit_norm[0] = hit_norm[1] = hit_norm[2] = 0\n\t}\n\n\treturn 0\n\n}\n\n\n// conform inputs\n\nfunction traceRay(getVoxel, origin, direction, max_d, hit_pos, hit_norm) {\n\tvar px = +origin[0]\n\t\t, py = +origin[1]\n\t\t, pz = +origin[2]\n\t\t, dx = +direction[0]\n\t\t, dy = +direction[1]\n\t\t, dz = +direction[2]\n\t\t, ds = Math.sqrt(dx * dx + dy * dy + dz * dz)\n\n\tif (ds === 0) {\n\t\tthrow new Error(\"Can't raycast along a zero vector\")\n\t}\n\n\tdx /= ds\n\tdy /= ds\n\tdz /= ds\n\tif (typeof (max_d) === \"undefined\") {\n\t\tmax_d = 64.0\n\t} else {\n\t\tmax_d = +max_d\n\t}\n\treturn traceRay_impl(getVoxel, px, py, pz, dx, dy, dz, max_d, hit_pos, hit_norm)\n}\n\nmodule.exports = traceRay\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/fast-voxel-raycast/index.js?");

/***/ }),

/***/ "../../node_modules/game-inputs/inputs.js":
/*!********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-inputs/inputs.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vkey = __webpack_require__(/*! vkey */ \"../../node_modules/vkey/index.js\")\nvar EventEmitter = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter;\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = __webpack_require__(/*! ./lib/mousewheel-polyfill.js */ \"../../node_modules/game-inputs/lib/mousewheel-polyfill.js\")\n\nmodule.exports = function(domElement, options) {\n  return new Inputs(domElement, options)\n}\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from) \n *        game-shell: https://github.com/mikolalysenko/game-shell\n *  \n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *  \n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n*/\n\n\nfunction Inputs(element, opts) {\n\n  // settings\n  this.element = element || document\n  opts = opts || {}\n  this.preventDefaults = !!opts.preventDefaults\n  this.stopPropagation = !!opts.stopPropagation\n\n  // emitters\n  this.down = new EventEmitter()\n  this.up = new EventEmitter()\n\n  // state object to be queried\n  this.state = {\n    dx: 0, dy: 0, \n    scrollx: 0, scrolly: 0, scrollz: 0\n  }\n\n  // internal state\n  this._keybindmap = {}       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n  this._keyStates = {}        // { 'vkeycode' : boolean }\n  this._bindPressCounts = {}  // { 'binding' : int }\n\n  // register for dom events\n  this.initEvents()\n}\n\n\n/*\n *\n *   PUBLIC API \n *\n*/ \n\nInputs.prototype.initEvents = function() {\n  // keys\n  window.addEventListener( 'keydown', onKeyEvent.bind(undefined,this,true), false )\n  window.addEventListener( 'keyup', onKeyEvent.bind(undefined,this,false), false )\n  // mouse buttons\n  this.element.addEventListener(\"mousedown\", onMouseEvent.bind(undefined,this,true), false)\n  this.element.addEventListener(\"mouseup\", onMouseEvent.bind(undefined,this,false), false)\n  this.element.oncontextmenu = onContextMenu.bind(undefined,this)\n  // treat dragstart like mouseup - idiotically, mouseup doesn't fire after a drag starts (!)\n  this.element.addEventListener(\"dragstart\", onMouseEvent.bind(undefined,this,false), false)\n  // touch/mouse movement\n  this.element.addEventListener(\"mousemove\", onMouseMove.bind(undefined,this), false)\n  this.element.addEventListener(\"touchmove\", onMouseMove.bind(undefined,this), false)\n  this.element.addEventListener(\"touchstart\", onTouchStart.bind(undefined,this), false)\n  // scroll/mousewheel\n  addMouseWheel(this.element, onMouseWheel.bind(undefined,this), false)\n}\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function(binding) {\n  for (var i=1; i<arguments.length; ++i) {\n    var vkeyCode = arguments[i]\n    var arr = this._keybindmap[vkeyCode] || []\n    if (arr.indexOf(binding) == -1) {\n      arr.push(binding)\n    }\n    this._keybindmap[vkeyCode] = arr\n  }\n  this.state[binding] = !!this.state[binding]\n}\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function(binding) {\n  for (var b in this._keybindmap) {\n    var arr = this._keybindmap[b]\n    var i = arr.indexOf(binding)\n    if (i>-1) { arr.splice(i,1) }\n  }\n}\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function() {\n  this.state.dx = this.state.dy = 0\n  this.state.scrollx = this.state.scrolly = this.state.scrollz = 0\n}\n\n\n\nInputs.prototype.getBoundKeys = function() {\n  var arr = []\n  for (var b in this._keybindmap) { arr.push(b) }\n  return arr\n}\n\n\n\n/*\n *   INTERNALS - DOM EVENT HANDLERS\n*/ \n\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n  handleKeyEvent( ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev )\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n  // simulate a code out of range of vkey\n  var keycode = -1 - ev.button\n  var vkeycode = '<mouse '+ (ev.button+1) +'>' \n  handleKeyEvent( keycode, vkeycode, wasDown, inputs, ev )\n  return false\n}\n\nfunction onContextMenu(inputs) {\n  // cancel context menu if there's a binding for right mousebutton\n  var arr = inputs._keybindmap['<mouse 3>']\n  if (arr) { return false }\n}\n\nfunction onMouseMove(inputs, ev) {\n  // for now, just populate the state object with mouse movement\n  var dx = ev.movementX || ev.mozMovementX || 0,\n      dy = ev.movementY || ev.mozMovementY || 0\n  // ad-hoc experimental touch support\n  if (ev.touches && (dx|dy)===0) {\n    var xy = getTouchMovement(ev)\n    dx = xy[0]\n    dy = xy[1]\n  }\n  inputs.state.dx += dx\n  inputs.state.dy += dy\n}\n\n// experimental - for touch events, extract useful dx/dy\nvar lastTouchX = 0\nvar lastTouchY = 0\nvar lastTouchID = null\n\nfunction onTouchStart(inputs, ev) {\n  var touch = ev.changedTouches[0]\n  lastTouchX = touch.clientX\n  lastTouchY = touch.clientY\n  lastTouchID = touch.identifier\n}\n\nfunction getTouchMovement(ev) {\n  var touch\n  var touches = ev.changedTouches\n  for (var i=0; i<touches.length; ++i) {\n    if (touches[i].identifier == lastTouchID) touch = touches[i]\n  }\n  if (!touch) return [0,0]\n  var res = [ touch.clientX-lastTouchX, touch.clientY-lastTouchY ]\n  lastTouchX = touch.clientX\n  lastTouchY = touch.clientY\n  return res\n}\n\nfunction onMouseWheel(inputs, ev) {\n  // basically borrowed from game-shell\n  var scale = 1\n  switch(ev.deltaMode) {\n    case 0: scale=1;   break;  // Pixel\n    case 1: scale=12;  break;  // Line\n    case 2:  // page\n      // TODO: investigagte when this happens, what correct handling is\n      scale = inputs.element.clientHeight || window.innerHeight\n      break;\n  }\n  // accumulate state\n  inputs.state.scrollx += ev.deltaX * scale\n  inputs.state.scrolly += ev.deltaY * scale\n  inputs.state.scrollz +=(ev.deltaZ * scale) || 0\n  return false\n}\n\n\n/*\n *   KEY BIND HANDLING\n*/ \n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n  var arr = inputs._keybindmap[vcode]\n  // don't prevent defaults if there's no binding\n  if (!arr) { return }\n  if (inputs.preventDefaults) ev.preventDefault()\n  if (inputs.stopPropagation) ev.stopPropagation()\n\n  // if the key's state has changed, handle an event for all bindings\n  var currstate = inputs._keyStates[keycode]\n  if ( XOR(currstate, wasDown) ) {\n    // for each binding: emit an event, and update cached state information\n    for (var i=0; i<arr.length; ++i) {\n      handleBindingEvent( arr[i], wasDown, inputs, ev )\n    }\n  }\n  inputs._keyStates[keycode] = wasDown\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n  // keep count of presses mapped by binding\n  // (to handle two keys with the same binding pressed at once)\n  var ct = inputs._bindPressCounts[binding] || 0\n  ct += wasDown ? 1 : -1\n  if (ct<0) { ct = 0 } // shouldn't happen\n  inputs._bindPressCounts[binding] = ct\n\n  // emit event if binding's state has changed\n  var currstate = inputs.state[binding]\n  if ( XOR(currstate, ct) ) {\n    var emitter = wasDown ? inputs.down : inputs.up\n    emitter.emit( binding, ev )\n  }\n  inputs.state[binding] = !!ct\n}\n\n\n/*\n *    HELPERS\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a,b) {\n  return a ? !b : b\n}\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-inputs/inputs.js?");

/***/ }),

/***/ "../../node_modules/game-inputs/lib/mousewheel-polyfill.js":
/*!*************************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-inputs/lib/mousewheel-polyfill.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support == \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n    \n    // calculate deltaY (and deltaX) according to the event\n    if ( support == \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support == \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-inputs/lib/mousewheel-polyfill.js?");

/***/ }),

/***/ "../../node_modules/game-shell/lib/hrtime-polyfill.js":
/*!********************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-shell/lib/hrtime-polyfill.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if(typeof window.performance === \"object\") {\n  if(window.performance.now) {\n    module.exports = function() { return window.performance.now() }\n  } else if(window.performance.webkitNow) {\n    module.exports = function() { return window.performance.webkitNow() }\n  }\n} else if(Date.now) {\n  module.exports = Date.now\n} else {\n  module.exports = function() { return (new Date()).getTime() }\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-shell/lib/hrtime-polyfill.js?");

/***/ }),

/***/ "../../node_modules/game-shell/lib/mousewheel-polyfill.js":
/*!************************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-shell/lib/mousewheel-polyfill.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support == \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n    \n    // calculate deltaY (and deltaX) according to the event\n    if ( support == \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support == \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-shell/lib/mousewheel-polyfill.js?");

/***/ }),

/***/ "../../node_modules/game-shell/lib/raf-polyfill.js":
/*!*****************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-shell/lib/raf-polyfill.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n \n// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n \n// MIT license\nvar lastTime = 0;\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] \n                               || window[vendors[x]+'CancelRequestAnimationFrame'];\n}\n\nif (!window.requestAnimationFrame)\n    window.requestAnimationFrame = function(callback, element) {\n        var currTime = new Date().getTime();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n          timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n\nif (!window.cancelAnimationFrame)\n    window.cancelAnimationFrame = function(id) {\n        clearTimeout(id);\n    };\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-shell/lib/raf-polyfill.js?");

/***/ }),

/***/ "../../node_modules/game-shell/node_modules/vkey/index.js":
/*!************************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-shell/node_modules/vkey/index.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-shell/node_modules/vkey/index.js?");

/***/ }),

/***/ "../../node_modules/game-shell/shell.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/game-shell/shell.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar EventEmitter = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter\n  , util         = __webpack_require__(/*! util */ \"../../node_modules/util/util.js\")\n  , domready     = __webpack_require__(/*! domready */ \"../../node_modules/domready/ready.js\")\n  , vkey         = __webpack_require__(/*! vkey */ \"../../node_modules/game-shell/node_modules/vkey/index.js\")\n  , invert       = __webpack_require__(/*! invert-hash */ \"../../node_modules/invert-hash/invert.js\")\n  , uniq         = __webpack_require__(/*! uniq */ \"../../node_modules/uniq/uniq.js\")\n  , bsearch      = __webpack_require__(/*! binary-search-bounds */ \"../../node_modules/binary-search-bounds/search-bounds.js\")\n  , iota         = __webpack_require__(/*! iota-array */ \"../../node_modules/iota-array/iota.js\")\n  , min          = Math.min\n\n//Browser compatibility hacks\n__webpack_require__(/*! ./lib/raf-polyfill.js */ \"../../node_modules/game-shell/lib/raf-polyfill.js\")\nvar addMouseWheel = __webpack_require__(/*! ./lib/mousewheel-polyfill.js */ \"../../node_modules/game-shell/lib/mousewheel-polyfill.js\")\nvar hrtime = __webpack_require__(/*! ./lib/hrtime-polyfill.js */ \"../../node_modules/game-shell/lib/hrtime-polyfill.js\")\n\n//Remove angle braces and other useless crap\nvar filtered_vkey = (function() {\n  var result = new Array(256)\n    , i, j, k\n  for(i=0; i<256; ++i) {\n    result[i] = \"UNK\"\n  }\n  for(i in vkey) {\n    k = vkey[i]\n    if(k.charAt(0) === '<' && k.charAt(k.length-1) === '>') {\n      k = k.substring(1, k.length-1)\n    }\n    k = k.replace(/\\s/g, \"-\")\n    result[parseInt(i)] = k\n  }\n  return result\n})()\n\n//Compute minimal common set of keyboard functions\nvar keyNames = uniq(Object.keys(invert(filtered_vkey)))\n\n//Translates a virtual keycode to a normalized keycode\nfunction virtualKeyCode(key) {\n  return bsearch.eq(keyNames, key)\n}\n\n//Maps a physical keycode to a normalized keycode\nfunction physicalKeyCode(key) {\n  return virtualKeyCode(filtered_vkey[key])\n}\n\n//Game shell\nfunction GameShell() {\n  EventEmitter.call(this)\n  this._curKeyState  = new Array(keyNames.length)\n  this._pressCount   = new Array(keyNames.length)\n  this._releaseCount = new Array(keyNames.length)\n  \n  this._tickInterval = null\n  this._rafHandle = null\n  this._tickRate = 0\n  this._lastTick = hrtime()\n  this._frameTime = 0.0\n  this._paused = true\n  this._width = 0\n  this._height = 0\n  \n  this._wantFullscreen = false\n  this._wantPointerLock = false\n  this._fullscreenActive = false\n  this._pointerLockActive = false\n  \n  this._rafFunction = tickOrRender.bind(undefined, this, true)\n\n  this.preventDefaults = true\n  this.stopPropagation = false\n  \n  for(var i=0; i<keyNames.length; ++i) {\n    this._curKeyState[i] = false\n    this._pressCount[i] = this._releaseCount[i] = 0\n  }\n  \n  //Public members\n  this.element = null\n  this.bindings = {}\n  this.frameSkip = 100.0\n  this.tickCount = 0\n  this.frameCount = 0\n  this.startTime = hrtime()\n  this.tickTime = this._tickRate\n  this.frameTime = 10.0\n  this.stickyFullscreen = false\n  this.stickyPointerLock = false\n  \n  //Scroll stuff\n  this.scroll = [0,0,0]\n    \n  //Mouse state\n  this.mouseX = 0\n  this.mouseY = 0\n  this.prevMouseX = 0\n  this.prevMouseY = 0\n}\n\nutil.inherits(GameShell, EventEmitter)\n\nvar proto = GameShell.prototype\n\n//Bind keynames\nproto.keyNames = keyNames\n\n//Binds a virtual keyboard event to a physical key\nproto.bind = function(virtual_key) {\n  //Look up previous key bindings\n  var arr\n  if(virtual_key in this.bindings) {\n    arr = this.bindings[virtual_key]\n  } else {\n    arr = []\n  }\n  //Add keys to list\n  var physical_key\n  for(var i=1, n=arguments.length; i<n; ++i) {\n    physical_key = arguments[i]\n    if(virtualKeyCode(physical_key) >= 0) {\n      arr.push(physical_key)\n    } else if(physical_key in this.bindings) {\n      var keybinds = this.bindings[physical_key]\n      for(var j=0; j<keybinds.length; ++j) {\n        arr.push(keybinds[j])\n      }\n    }\n  }\n  //Remove any duplicate keys\n  arr = uniq(arr)\n  if(arr.length > 0) {\n    this.bindings[virtual_key] = arr\n  }\n  this.emit('bind', virtual_key, arr)\n}\n\n//Unbinds a virtual keyboard event\nproto.unbind = function(virtual_key) {\n  if(virtual_key in this.bindings) {\n    delete this.bindings[virtual_key]\n  }\n  this.emit('unbind', virtual_key)\n}\n\n//Checks if a key is set in a given state\nfunction lookupKey(state, bindings, key) {\n  if(key in bindings) {\n    var arr = bindings[key]\n    for(var i=0, n=arr.length; i<n; ++i) {\n      if(state[virtualKeyCode(arr[i])]) {\n        return true\n      }\n    }\n    return false\n  }\n  var kc = virtualKeyCode(key)\n  if(kc >= 0) {\n    return state[kc]\n  }\n  return false\n}\n\n//Checks if a key is set in a given state\nfunction lookupCount(state, bindings, key) {\n  if(key in bindings) {\n    var arr = bindings[key], r = 0\n    for(var i=0, n=arr.length; i<n; ++i) {\n      r += state[virtualKeyCode(arr[i])]\n    }\n    return r\n  }\n  var kc = virtualKeyCode(key)\n  if(kc >= 0) {\n    return state[kc]\n  }\n  return 0\n}\n\n//Checks if a key (either physical or virtual) is currently held down\nproto.down = function(key) {\n  return lookupKey(this._curKeyState, this.bindings, key)\n}\n\n//Checks if a key was ever down\nproto.wasDown = function(key) {\n  return this.down(key) || !!this.press(key)\n}\n\n//Opposite of down\nproto.up = function(key) {\n  return !this.down(key)\n}\n\n//Checks if a key was released during previous frame\nproto.wasUp = function(key) {\n  return this.up(key) || !!this.release(key)\n}\n\n//Returns the number of times a key was pressed since last tick\nproto.press = function(key) {\n  return lookupCount(this._pressCount, this.bindings, key)\n}\n\n//Returns the number of times a key was released since last tick\nproto.release = function(key) {\n  return lookupCount(this._releaseCount, this.bindings, key)\n}\n\n//Pause/unpause the game loop\nObject.defineProperty(proto, \"paused\", {\n  get: function() {\n    return this._paused\n  },\n  set: function(state) {\n    var ns = !!state\n    if(ns !== this._paused) {\n      if(!this._paused) {\n        this._paused = true\n        this._frameTime = min(1.0, (hrtime() - this._lastTick) / this._tickRate)\n        clearInterval(this._tickInterval)\n        //cancelAnimationFrame(this._rafHandle)\n      } else {\n        this._paused = false\n        this._lastTick = hrtime() - Math.floor(this._frameTime * this._tickRate)\n        this._tickInterval = setInterval(tickOrRender, this._tickRate, this, false)\n        this._rafHandle = requestAnimationFrame(this._rafFunction)\n      }\n    }\n  }\n})\n\n//Fullscreen state toggle\n\nfunction tryFullscreen(shell) {\n  //Request full screen\n  var elem = shell.element\n  \n  if(shell._wantFullscreen && !shell._fullscreenActive) {\n    var fs = elem.requestFullscreen ||\n             elem.requestFullScreen ||\n             elem.webkitRequestFullscreen ||\n             elem.webkitRequestFullScreen ||\n             elem.mozRequestFullscreen ||\n             elem.mozRequestFullScreen ||\n             function() {}\n    fs.call(elem)\n  }\n  if(shell._wantPointerLock && !shell._pointerLockActive) {\n    var pl =  elem.requestPointerLock ||\n              elem.webkitRequestPointerLock ||\n              elem.mozRequestPointerLock ||\n              elem.msRequestPointerLock ||\n              elem.oRequestPointerLock ||\n              function() {}\n    pl.call(elem)\n  }\n}\n\nvar cancelFullscreen = document.exitFullscreen ||\n                       document.cancelFullscreen ||  //Why can no one agree on this?\n                       document.cancelFullScreen ||\n                       document.webkitCancelFullscreen ||\n                       document.webkitCancelFullScreen ||\n                       document.mozCancelFullscreen ||\n                       document.mozCancelFullScreen ||\n                       function(){}\n\nObject.defineProperty(proto, \"fullscreen\", {\n  get: function() {\n    return this._fullscreenActive\n  },\n  set: function(state) {\n    var ns = !!state\n    if(!ns) {\n      this._wantFullscreen = false\n      var hasFS = document.fullscreen ||\n                  document.mozFullScreen ||\n                  document.webkitIsFullScreen ||\n                  false\n      if (hasFS) cancelFullscreen.call(document)\n    } else {\n      this._wantFullscreen = true\n      tryFullscreen(this)\n    }\n    return this._fullscreenActive\n  }\n})\n\nfunction handleFullscreen(shell) {\n  shell._fullscreenActive = document.fullscreen ||\n                            document.mozFullScreen ||\n                            document.webkitIsFullScreen ||\n                            false\n  if(!shell.stickyFullscreen && shell._fullscreenActive) {\n    shell._wantFullscreen = false\n  }\n}\n\n//Pointer lock state toggle\nvar exitPointerLock = document.exitPointerLock ||\n                      document.webkitExitPointerLock ||\n                      document.mozExitPointerLock ||\n                      function() {}\n\nObject.defineProperty(proto, \"pointerLock\", {\n  get: function() {\n    return this._pointerLockActive\n  },\n  set: function(state) {\n    var ns = !!state\n    if(!ns) {\n      this._wantPointerLock = false\n      exitPointerLock.call(document)\n    } else {\n      this._wantPointerLock = true\n      tryFullscreen(this)\n    }\n    return this._pointerLockActive\n  }\n})\n\nfunction handlePointerLockChange(shell, event) {\n  shell._pointerLockActive = shell.element === (\n      document.pointerLockElement ||\n      document.mozPointerLockElement ||\n      document.webkitPointerLockElement ||\n      null)\n  if(!shell.stickyPointerLock && shell._pointerLockActive) {\n    shell._wantPointerLock = false\n  }\n}\n\n//Width and height\nObject.defineProperty(proto, \"width\", {\n  get: function() {\n    return this.element.clientWidth\n  }\n})\nObject.defineProperty(proto, \"height\", {\n  get: function() {\n    return this.element.clientHeight\n  }\n})\n\n//Set key state\nfunction setKeyState(shell, key, state) {\n  var ps = shell._curKeyState[key]\n  if(ps !== state) {\n    if(state) {\n      shell._pressCount[key]++\n    } else {\n      shell._releaseCount[key]++\n    }\n    shell._curKeyState[key] = state\n  }\n}\n\nfunction tickOrRender(shell, doRender) {\n  tick(shell)\n  if (doRender) {\n    render(shell)\n  }\n}\n\n//Ticks the game state one update\nfunction tick(shell) {\n  var skip = hrtime() + shell.frameSkip\n    , pCount = shell._pressCount\n    , rCount = shell._releaseCount\n    , i, s, t\n    , tr = shell._tickRate\n    , n = keyNames.length\n  while(!shell._paused &&\n        hrtime() >= shell._lastTick + tr) {\n    \n    //Skip frames if we are over budget\n    if(hrtime() > skip) {\n      shell._lastTick = hrtime() + tr\n      return\n    }\n    \n    //Tick the game\n    s = hrtime()\n    shell.emit(\"tick\")\n    t = hrtime()\n    shell.tickTime = t - s\n    \n    //Update counters and time\n    ++shell.tickCount\n    shell._lastTick += tr\n    \n    //Shift input state\n    for(i=0; i<n; ++i) {\n      pCount[i] = rCount[i] = 0\n    }\n    if(shell._pointerLockActive) {\n      shell.prevMouseX = shell.mouseX = shell.width>>1\n      shell.prevMouseY = shell.mouseY = shell.height>>1\n    } else {\n      shell.prevMouseX = shell.mouseX\n      shell.prevMouseY = shell.mouseY\n    }\n    shell.scroll[0] = shell.scroll[1] = shell.scroll[2] = 0\n  }\n}\n\n//Render stuff\nfunction render(shell) {\n\n  //Request next frame\n  shell._rafHandle = requestAnimationFrame(shell._rafFunction)\n\n  //Compute frame time\n  var dt\n  if(shell._paused) {\n    dt = shell._frameTime\n  } else {\n    dt = min(1.0, (hrtime() - shell._lastTick) / shell._tickRate)\n  }\n  \n  //Draw a frame\n  ++shell.frameCount\n  var s = hrtime()\n  shell.emit(\"render\", dt)\n  var t = hrtime()\n  shell.frameTime = t - s\n  \n}\n\nfunction isFocused(shell) {\n  return (document.activeElement === document.body) ||\n         (document.activeElement === shell.element)\n}\n\nfunction handleEvent(shell, ev) {\n  if(shell.preventDefaults) {\n    ev.preventDefault()\n  }\n  if(shell.stopPropagation) {\n    ev.stopPropagation()\n  }\n}\n\n//Set key up\nfunction handleKeyUp(shell, ev) {\n  handleEvent(shell, ev)\n  var kc = physicalKeyCode(ev.keyCode || ev.char || ev.which || ev.charCode)\n  if(kc >= 0) {\n    setKeyState(shell, kc, false)\n  }\n}\n\n//Set key down\nfunction handleKeyDown(shell, ev) {\n  if(!isFocused(shell)) {\n    return\n  }\n  handleEvent(shell, ev)\n  if(ev.metaKey) {\n    //Hack: Clear key state when meta gets pressed to prevent keys sticking\n    handleBlur(shell, ev)\n  } else {\n    var kc = physicalKeyCode(ev.keyCode || ev.char || ev.which || ev.charCode)\n    if(kc >= 0) {\n      setKeyState(shell, kc, true)\n    }\n  }\n}\n\n//Mouse events are really annoying\nvar mouseCodes = iota(32).map(function(n) {\n  return virtualKeyCode(\"mouse-\" + (n+1))\n})\n\nfunction setMouseButtons(shell, buttons) {\n  for(var i=0; i<32; ++i) {\n    setKeyState(shell, mouseCodes[i], !!(buttons & (1<<i)))\n  }\n}\n\nfunction handleMouseMove(shell, ev) {\n  handleEvent(shell, ev)\n  if(shell._pointerLockActive) {\n    var movementX = ev.movementX       ||\n                    ev.mozMovementX    ||\n                    ev.webkitMovementX ||\n                    0,\n        movementY = ev.movementY       ||\n                    ev.mozMovementY    ||\n                    ev.webkitMovementY ||\n                    0\n    shell.mouseX += movementX\n    shell.mouseY += movementY\n  } else {\n    shell.mouseX = ev.clientX - shell.element.offsetLeft\n    shell.mouseY = ev.clientY - shell.element.offsetTop\n  }\n  return false\n}\n\nfunction handleMouseDown(shell, ev) {\n  handleEvent(shell, ev)\n  setKeyState(shell, mouseCodes[ev.button], true)\n  return false\n}\n\nfunction handleMouseUp(shell, ev) {\n  handleEvent(shell, ev)\n  setKeyState(shell, mouseCodes[ev.button], false)\n  return false\n}\n\nfunction handleMouseEnter(shell, ev) {\n  handleEvent(shell, ev)\n  if(shell._pointerLockActive) {\n    shell.prevMouseX = shell.mouseX = shell.width>>1\n    shell.prevMouseY = shell.mouseY = shell.height>>1\n  } else {\n    shell.prevMouseX = shell.mouseX = ev.clientX - shell.element.offsetLeft\n    shell.prevMouseY = shell.mouseY = ev.clientY - shell.element.offsetTop\n  }\n  return false\n}\n\nfunction handleMouseLeave(shell, ev) {\n  handleEvent(shell, ev)\n  setMouseButtons(shell, 0)\n  return false\n}\n\n//Handle mouse wheel events\nfunction handleMouseWheel(shell, ev) {\n  handleEvent(shell, ev)\n  var scale = 1\n  switch(ev.deltaMode) {\n    case 0: //Pixel\n      scale = 1\n    break\n    case 1: //Line\n      scale = 12\n    break\n    case 2: //Page\n       scale = shell.height\n    break\n  }\n  //Add scroll\n  shell.scroll[0] +=  ev.deltaX * scale\n  shell.scroll[1] +=  ev.deltaY * scale\n  shell.scroll[2] += (ev.deltaZ * scale)||0.0\n  return false\n}\n\nfunction handleContexMenu(shell, ev) {\n  handleEvent(shell, ev)\n  return false\n}\n\nfunction handleBlur(shell, ev) {\n  var n = keyNames.length\n    , c = shell._curKeyState\n    , r = shell._releaseCount\n    , i\n  for(i=0; i<n; ++i) {\n    if(c[i]) {\n      ++r[i]\n    }\n    c[i] = false\n  }\n  return false\n}\n\nfunction handleResizeElement(shell, ev) {\n  var w = shell.element.clientWidth|0\n  var h = shell.element.clientHeight|0\n  if((w !== shell._width) || (h !== shell._height)) {\n    shell._width = w\n    shell._height = h\n    shell.emit(\"resize\", w, h)\n  }\n}\n\nfunction makeDefaultContainer() {\n  var container = document.createElement(\"div\")\n  container.tabindex = 1\n  container.style.position = \"absolute\"\n  container.style.left = \"0px\"\n  container.style.right = \"0px\"\n  container.style.top = \"0px\"\n  container.style.bottom = \"0px\"\n  container.style.height = \"100%\"\n  container.style.overflow = \"hidden\"\n  document.body.appendChild(container)\n  document.body.style.overflow = \"hidden\" //Prevent bounce\n  document.body.style.height = \"100%\"\n  return container\n}\n\nfunction createShell(options) {\n  options = options || {}\n  \n  //Check fullscreen and pointer lock flags\n  var useFullscreen = !!options.fullscreen\n  var usePointerLock = useFullscreen\n  if(typeof options.pointerLock !== undefined) {\n    usePointerLock = !!options.pointerLock\n  }\n  \n  //Create initial shell\n  var shell = new GameShell()\n  shell._tickRate = options.tickRate || 30\n  shell.frameSkip = options.frameSkip || (shell._tickRate+5) * 5\n  shell.stickyFullscreen = !!options.stickyFullscreen || !!options.sticky\n  shell.stickyPointerLock = !!options.stickyPointerLock || !!options.sticky\n  \n  //Set bindings\n  if(options.bindings) {\n    shell.bindings = options.bindings\n  }\n  \n  //Wait for dom to intiailize\n  setTimeout(function() { domready(function initGameShell() {\n    \n    //Retrieve element\n    var element = options.element\n    if(typeof element === \"string\") {\n      var e = document.querySelector(element)\n      if(!e) {\n        e = document.getElementById(element)\n      }\n      if(!e) {\n        e = document.getElementByClass(element)[0]\n      }\n      if(!e) {\n        e = makeDefaultContainer()\n      }\n      shell.element = e\n    } else if(typeof element === \"object\" && !!element) {\n      shell.element = element\n    } else if(typeof element === \"function\") {\n      shell.element = element()\n    } else {\n      shell.element = makeDefaultContainer()\n    }\n    \n    //Disable user-select\n    if(shell.element.style) {\n      shell.element.style[\"-webkit-touch-callout\"] = \"none\"\n      shell.element.style[\"-webkit-user-select\"] = \"none\"\n      shell.element.style[\"-khtml-user-select\"] = \"none\"\n      shell.element.style[\"-moz-user-select\"] = \"none\"\n      shell.element.style[\"-ms-user-select\"] = \"none\"\n      shell.element.style[\"user-select\"] = \"none\"\n    }\n    \n    //Hook resize handler\n    shell._width = shell.element.clientWidth\n    shell._height = shell.element.clientHeight\n    var handleResize = handleResizeElement.bind(undefined, shell)\n    if(typeof MutationObserver !== \"undefined\") {\n      var observer = new MutationObserver(handleResize)\n      observer.observe(shell.element, {\n        attributes: true,\n        subtree: true\n      })\n    } else {\n      shell.element.addEventListener(\"DOMSubtreeModified\", handleResize, false)\n    }\n    window.addEventListener(\"resize\", handleResize, false)\n    \n    //Hook keyboard listener\n    window.addEventListener(\"keydown\", handleKeyDown.bind(undefined, shell), false)\n    window.addEventListener(\"keyup\", handleKeyUp.bind(undefined, shell), false)\n    \n    //Disable right click\n    shell.element.oncontextmenu = handleContexMenu.bind(undefined, shell)\n    \n    //Hook mouse listeners\n    shell.element.addEventListener(\"mousedown\", handleMouseDown.bind(undefined, shell), false)\n    shell.element.addEventListener(\"mouseup\", handleMouseUp.bind(undefined, shell), false)\n    shell.element.addEventListener(\"mousemove\", handleMouseMove.bind(undefined, shell), false)\n    shell.element.addEventListener(\"mouseenter\", handleMouseEnter.bind(undefined, shell), false)\n    \n    //Mouse leave\n    var leave = handleMouseLeave.bind(undefined, shell)\n    shell.element.addEventListener(\"mouseleave\", leave, false)\n    shell.element.addEventListener(\"mouseout\", leave, false)\n    window.addEventListener(\"mouseleave\", leave, false)\n    window.addEventListener(\"mouseout\", leave, false)\n    \n    //Blur event \n    var blur = handleBlur.bind(undefined, shell)\n    shell.element.addEventListener(\"blur\", blur, false)\n    shell.element.addEventListener(\"focusout\", blur, false)\n    shell.element.addEventListener(\"focus\", blur, false)\n    window.addEventListener(\"blur\", blur, false)\n    window.addEventListener(\"focusout\", blur, false)\n    window.addEventListener(\"focus\", blur, false)\n\n    //Mouse wheel handler\n    addMouseWheel(shell.element, handleMouseWheel.bind(undefined, shell), false)\n\n    //Fullscreen handler\n    var fullscreenChange = handleFullscreen.bind(undefined, shell)\n    document.addEventListener(\"fullscreenchange\", fullscreenChange, false)\n    document.addEventListener(\"mozfullscreenchange\", fullscreenChange, false)\n    document.addEventListener(\"webkitfullscreenchange\", fullscreenChange, false)\n\n    //Stupid fullscreen hack\n    shell.element.addEventListener(\"click\", tryFullscreen.bind(undefined, shell), false)\n\n    //Pointer lock change handler\n    var pointerLockChange = handlePointerLockChange.bind(undefined, shell)\n    document.addEventListener(\"pointerlockchange\", pointerLockChange, false)\n    document.addEventListener(\"mozpointerlockchange\", pointerLockChange, false)\n    document.addEventListener(\"webkitpointerlockchange\", pointerLockChange, false)\n    document.addEventListener(\"pointerlocklost\", pointerLockChange, false)\n    document.addEventListener(\"webkitpointerlocklost\", pointerLockChange, false)\n    document.addEventListener(\"mozpointerlocklost\", pointerLockChange, false)\n    \n    //Update flags\n    shell.fullscreen = useFullscreen\n    shell.pointerLock = usePointerLock\n  \n    //Default mouse button aliases\n    shell.bind(\"mouse-left\",   \"mouse-1\")\n    shell.bind(\"mouse-right\",  \"mouse-3\")\n    shell.bind(\"mouse-middle\", \"mouse-2\")\n    \n    //Initialize tick counter\n    shell._lastTick = hrtime()\n    shell.startTime = hrtime()\n\n    //Unpause shell\n    shell.paused = false\n    \n    //Emit initialize event\n    shell.emit(\"init\")\n  })}, 0)\n  \n  return shell\n}\n\nmodule.exports = createShell\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/game-shell/shell.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/add.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/add.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/angle.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/angle.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = angle\n\nvar fromValues = __webpack_require__(/*! ./fromValues */ \"../../node_modules/gl-vec3/fromValues.js\")\nvar normalize = __webpack_require__(/*! ./normalize */ \"../../node_modules/gl-vec3/normalize.js\")\nvar dot = __webpack_require__(/*! ./dot */ \"../../node_modules/gl-vec3/dot.js\")\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/angle.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/ceil.js":
/*!**************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/ceil.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/ceil.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/clone.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/clone.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/clone.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/copy.js":
/*!**************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/copy.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/create.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/create.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/cross.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/cross.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/cross.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/dist.js":
/*!**************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/dist.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./distance */ \"../../node_modules/gl-vec3/distance.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/dist.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/distance.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/distance.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/distance.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/div.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/div.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./divide */ \"../../node_modules/gl-vec3/divide.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/div.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/divide.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/divide.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/divide.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/dot.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/dot.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/dot.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/epsilon.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/epsilon.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/equals.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/equals.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"../../node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/exactEquals.js":
/*!*********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/exactEquals.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/exactEquals.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/floor.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/floor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/floor.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/forEach.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/forEach.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = forEach;\n\nvar vec = __webpack_require__(/*! ./create */ \"../../node_modules/gl-vec3/create.js\")()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/forEach.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/fromValues.js":
/*!********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/fromValues.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/fromValues.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/index.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  EPSILON: __webpack_require__(/*! ./epsilon */ \"../../node_modules/gl-vec3/epsilon.js\")\n  , create: __webpack_require__(/*! ./create */ \"../../node_modules/gl-vec3/create.js\")\n  , clone: __webpack_require__(/*! ./clone */ \"../../node_modules/gl-vec3/clone.js\")\n  , angle: __webpack_require__(/*! ./angle */ \"../../node_modules/gl-vec3/angle.js\")\n  , fromValues: __webpack_require__(/*! ./fromValues */ \"../../node_modules/gl-vec3/fromValues.js\")\n  , copy: __webpack_require__(/*! ./copy */ \"../../node_modules/gl-vec3/copy.js\")\n  , set: __webpack_require__(/*! ./set */ \"../../node_modules/gl-vec3/set.js\")\n  , equals: __webpack_require__(/*! ./equals */ \"../../node_modules/gl-vec3/equals.js\")\n  , exactEquals: __webpack_require__(/*! ./exactEquals */ \"../../node_modules/gl-vec3/exactEquals.js\")\n  , add: __webpack_require__(/*! ./add */ \"../../node_modules/gl-vec3/add.js\")\n  , subtract: __webpack_require__(/*! ./subtract */ \"../../node_modules/gl-vec3/subtract.js\")\n  , sub: __webpack_require__(/*! ./sub */ \"../../node_modules/gl-vec3/sub.js\")\n  , multiply: __webpack_require__(/*! ./multiply */ \"../../node_modules/gl-vec3/multiply.js\")\n  , mul: __webpack_require__(/*! ./mul */ \"../../node_modules/gl-vec3/mul.js\")\n  , divide: __webpack_require__(/*! ./divide */ \"../../node_modules/gl-vec3/divide.js\")\n  , div: __webpack_require__(/*! ./div */ \"../../node_modules/gl-vec3/div.js\")\n  , min: __webpack_require__(/*! ./min */ \"../../node_modules/gl-vec3/min.js\")\n  , max: __webpack_require__(/*! ./max */ \"../../node_modules/gl-vec3/max.js\")\n  , floor: __webpack_require__(/*! ./floor */ \"../../node_modules/gl-vec3/floor.js\")\n  , ceil: __webpack_require__(/*! ./ceil */ \"../../node_modules/gl-vec3/ceil.js\")\n  , round: __webpack_require__(/*! ./round */ \"../../node_modules/gl-vec3/round.js\")\n  , scale: __webpack_require__(/*! ./scale */ \"../../node_modules/gl-vec3/scale.js\")\n  , scaleAndAdd: __webpack_require__(/*! ./scaleAndAdd */ \"../../node_modules/gl-vec3/scaleAndAdd.js\")\n  , distance: __webpack_require__(/*! ./distance */ \"../../node_modules/gl-vec3/distance.js\")\n  , dist: __webpack_require__(/*! ./dist */ \"../../node_modules/gl-vec3/dist.js\")\n  , squaredDistance: __webpack_require__(/*! ./squaredDistance */ \"../../node_modules/gl-vec3/squaredDistance.js\")\n  , sqrDist: __webpack_require__(/*! ./sqrDist */ \"../../node_modules/gl-vec3/sqrDist.js\")\n  , length: __webpack_require__(/*! ./length */ \"../../node_modules/gl-vec3/length.js\")\n  , len: __webpack_require__(/*! ./len */ \"../../node_modules/gl-vec3/len.js\")\n  , squaredLength: __webpack_require__(/*! ./squaredLength */ \"../../node_modules/gl-vec3/squaredLength.js\")\n  , sqrLen: __webpack_require__(/*! ./sqrLen */ \"../../node_modules/gl-vec3/sqrLen.js\")\n  , negate: __webpack_require__(/*! ./negate */ \"../../node_modules/gl-vec3/negate.js\")\n  , inverse: __webpack_require__(/*! ./inverse */ \"../../node_modules/gl-vec3/inverse.js\")\n  , normalize: __webpack_require__(/*! ./normalize */ \"../../node_modules/gl-vec3/normalize.js\")\n  , dot: __webpack_require__(/*! ./dot */ \"../../node_modules/gl-vec3/dot.js\")\n  , cross: __webpack_require__(/*! ./cross */ \"../../node_modules/gl-vec3/cross.js\")\n  , lerp: __webpack_require__(/*! ./lerp */ \"../../node_modules/gl-vec3/lerp.js\")\n  , random: __webpack_require__(/*! ./random */ \"../../node_modules/gl-vec3/random.js\")\n  , transformMat4: __webpack_require__(/*! ./transformMat4 */ \"../../node_modules/gl-vec3/transformMat4.js\")\n  , transformMat3: __webpack_require__(/*! ./transformMat3 */ \"../../node_modules/gl-vec3/transformMat3.js\")\n  , transformQuat: __webpack_require__(/*! ./transformQuat */ \"../../node_modules/gl-vec3/transformQuat.js\")\n  , rotateX: __webpack_require__(/*! ./rotateX */ \"../../node_modules/gl-vec3/rotateX.js\")\n  , rotateY: __webpack_require__(/*! ./rotateY */ \"../../node_modules/gl-vec3/rotateY.js\")\n  , rotateZ: __webpack_require__(/*! ./rotateZ */ \"../../node_modules/gl-vec3/rotateZ.js\")\n  , forEach: __webpack_require__(/*! ./forEach */ \"../../node_modules/gl-vec3/forEach.js\")\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/index.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/inverse.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/inverse.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/inverse.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/len.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/len.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./length */ \"../../node_modules/gl-vec3/length.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/len.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/length.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/length.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/length.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/lerp.js":
/*!**************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/lerp.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/lerp.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/max.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/max.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/max.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/min.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/min.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/min.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/mul.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/mul.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./multiply */ \"../../node_modules/gl-vec3/multiply.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/mul.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/multiply.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/multiply.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/multiply.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/negate.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/negate.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/negate.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/normalize.js":
/*!*******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/normalize.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/random.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/random.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/random.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/rotateX.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/rotateX.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/rotateY.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/rotateY.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/rotateZ.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/rotateZ.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/rotateZ.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/round.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/round.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/round.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/scale.js":
/*!***************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/scale.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/scale.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/scaleAndAdd.js":
/*!*********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/scaleAndAdd.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/set.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/set.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/set.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/sqrDist.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/sqrDist.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredDistance */ \"../../node_modules/gl-vec3/squaredDistance.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/sqrDist.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/sqrLen.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/sqrLen.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredLength */ \"../../node_modules/gl-vec3/squaredLength.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/sqrLen.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/squaredDistance.js":
/*!*************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/squaredDistance.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/squaredDistance.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/squaredLength.js":
/*!***********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/squaredLength.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/squaredLength.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/sub.js":
/*!*************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/sub.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./subtract */ \"../../node_modules/gl-vec3/subtract.js\")\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/sub.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/subtract.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/subtract.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/subtract.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/transformMat3.js":
/*!***********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/transformMat3.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/transformMat3.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/transformMat4.js":
/*!***********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/transformMat4.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "../../node_modules/gl-vec3/transformQuat.js":
/*!***********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/gl-vec3/transformQuat.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n    return out\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/gl-vec3/transformQuat.js?");

/***/ }),

/***/ "../../node_modules/inherits/inherits_browser.js":
/*!***************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/inherits/inherits_browser.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "../../node_modules/invert-hash/invert.js":
/*!********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/invert-hash/invert.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction invert(hash) {\n  var result = {}\n  for(var i in hash) {\n    if(hash.hasOwnProperty(i)) {\n      result[hash[i]] = i\n    }\n  }\n  return result\n}\n\nmodule.exports = invert\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/invert-hash/invert.js?");

/***/ }),

/***/ "../../node_modules/iota-array/iota.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/iota-array/iota.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/iota-array/iota.js?");

/***/ }),

/***/ "../../node_modules/is-buffer/index.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/is-buffer/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/is-buffer/index.js?");

/***/ }),

/***/ "../../node_modules/ndarray-hash/ndhash.js":
/*!*********************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/ndarray-hash/ndhash.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar ndarray = __webpack_require__(/*! ndarray */ \"../../node_modules/ndarray/ndarray.js\")\r\nvar useMaps = !(typeof Map === \"undefined\")\r\n\r\nfunction HashMap(n) {\r\n  this.length = n\r\n  this.store = useMaps ? new Map() : {}\r\n}\r\n\r\nif (useMaps) {\r\n  HashMap.prototype.get = function(i) {\r\n    return this.store.get(i) || 0\r\n  }\r\n  HashMap.prototype.set = function(i,v) {\r\n    if (v===0) {\r\n      this.store.delete(i)\r\n    } else {\r\n      this.store.set(i, v)\r\n    }\r\n    return v\r\n  }\r\n} else { // Using a polyfill would be neater, but this works as well \r\n  HashMap.prototype.get = function(i) {\r\n    return this.store[i] || 0\r\n  }\r\n  HashMap.prototype.set = function(i,v) {\r\n    if (v===0) {\r\n      delete this.store[i]\r\n    } else {\r\n      this.store[i] = v\r\n    }\r\n    return v\r\n  }\r\n}\r\n\r\nfunction createNDHash(shape) {\r\n  var sz = 1\r\n  for(var i=0; i<shape.length; ++i) {\r\n    sz *= shape[i]\r\n  }\r\n  return ndarray(new HashMap(sz), shape)\r\n}\r\n\r\nmodule.exports = createNDHash\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/ndarray-hash/ndhash.js?");

/***/ }),

/***/ "../../node_modules/ndarray/ndarray.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/ndarray/ndarray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"../../node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"../../node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/ndarray/ndarray.js?");

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/process/browser.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/process/browser.js?");

/***/ }),

/***/ "../../node_modules/uniq/uniq.js":
/*!***********************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/uniq/uniq.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/uniq/uniq.js?");

/***/ }),

/***/ "../../node_modules/util/support/isBufferBrowser.js":
/*!******************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "../../node_modules/util/util.js":
/*!***********************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/util/util.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"../../node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"../../node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"../../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/util/util.js?");

/***/ }),

/***/ "../../node_modules/vkey/index.js":
/*!************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/vkey/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/vkey/index.js?");

/***/ }),

/***/ "../../node_modules/voxel-aabb-sweep/index.js":
/*!************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/voxel-aabb-sweep/index.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n// reused array instances\n\nvar tr_arr = []\nvar ldi_arr = []\nvar tri_arr = []\nvar step_arr = []\nvar tDelta_arr = []\nvar tNext_arr = []\nvar vec_arr = []\nvar normed_arr = []\nvar base_arr = []\nvar max_arr = []\nvar left_arr = []\nvar result_arr = []\n\n\n\n// core implementation:\n\nfunction sweep_impl(getVoxel, callback, vec, base, max, epsilon) {\n\n    // consider algo as a raycast along the AABB's leading corner\n    // as raycast enters each new voxel, iterate in 2D over the AABB's \n    // leading face in that axis looking for collisions\n    // \n    // original raycast implementation: https://github.com/andyhall/fast-voxel-raycast\n    // original raycast paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\n    var tr = tr_arr\n    var ldi = ldi_arr\n    var tri = tri_arr\n    var step = step_arr\n    var tDelta = tDelta_arr\n    var tNext = tNext_arr\n    var normed = normed_arr\n\n    var floor = Math.floor\n    var cumulative_t = 0.0\n    var t = 0.0\n    var max_t = 0.0\n    var axis = 0\n    var i = 0\n\n\n    // init for the current sweep vector and take first step\n    initSweep()\n    if (max_t === 0) return 0\n\n    axis = stepForward()\n\n    // loop along raycast vector\n    while (t <= max_t) {\n\n        // sweeps over leading face of AABB\n        if (checkCollision(axis)) {\n            // calls the callback and decides whether to continue\n            var done = handleCollision()\n            if (done) return cumulative_t\n        }\n\n        axis = stepForward()\n    }\n\n    // reached the end of the vector unobstructed, finish and exit\n    cumulative_t += max_t\n    for (i = 0; i < 3; i++) {\n        base[i] += vec[i]\n        max[i] += vec[i]\n    }\n    return cumulative_t\n\n\n\n\n\n    // low-level implementations of each step:\n    function initSweep() {\n\n        // parametrization t along raycast\n        t = 0.0\n        max_t = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2])\n        if (max_t === 0) return\n        for (var i = 0; i < 3; i++) {\n            var dir = (vec[i] >= 0)\n            step[i] = dir ? 1 : -1\n            // trailing / trailing edge coords\n            var lead = dir ? max[i] : base[i]\n            tr[i] = dir ? base[i] : max[i]\n            // int values of lead/trail edges\n            ldi[i] = leadEdgeToInt(lead, step[i])\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n            // normed vector\n            normed[i] = vec[i] / max_t\n            // distance along t required to move one voxel in each axis\n            tDelta[i] = Math.abs(1 / normed[i])\n            // location of nearest voxel boundary, in units of t \n            var dist = dir ? (ldi[i] + 1 - lead) : (lead - ldi[i])\n            tNext[i] = (tDelta[i] < Infinity) ? tDelta[i] * dist : Infinity\n        }\n\n    }\n\n\n    // check for collisions - iterate over the leading face on the advancing axis\n\n    function checkCollision(i_axis) {\n        var stepx = step[0]\n        var x0 = (i_axis === 0) ? ldi[0] : tri[0]\n        var x1 = ldi[0] + stepx\n\n        var stepy = step[1]\n        var y0 = (i_axis === 1) ? ldi[1] : tri[1]\n        var y1 = ldi[1] + stepy\n\n        var stepz = step[2]\n        var z0 = (i_axis === 2) ? ldi[2] : tri[2]\n        var z1 = ldi[2] + stepz\n\n        // var j_axis = (i_axis + 1) % 3\n        // var k_axis = (i_axis + 2) % 3\n        // var s = ['x', 'y', 'z'][i_axis]\n        // var js = ['x', 'y', 'z'][j_axis]\n        // var ks = ['x', 'y', 'z'][k_axis]\n        // var i0 = [x0, y0, z0][i_axis]\n        // var j0 = [x0, y0, z0][j_axis]\n        // var k0 = [x0, y0, z0][k_axis]\n        // var i1 = [x1 - stepx, y1 - stepy, z1 - stepz][i_axis]\n        // var j1 = [x1 - stepx, y1 - stepy, z1 - stepz][j_axis]\n        // var k1 = [x1 - stepx, y1 - stepy, z1 - stepz][k_axis]\n        // console.log('=== step', s, 'to', i0, '   sweep', js, j0 + ',' + j1, '   ', ks, k0 + ',' + k1)\n\n        for (var x = x0; x != x1; x += stepx) {\n            for (var y = y0; y != y1; y += stepy) {\n                for (var z = z0; z != z1; z += stepz) {\n                    if (getVoxel(x, y, z)) return true\n                }\n            }\n        }\n        return false\n    }\n\n\n    // on collision - call the callback and return or set up for the next sweep\n\n    function handleCollision() {\n\n        // set up for callback\n        cumulative_t += t\n        var dir = step[axis]\n\n        // vector moved so far, and left to move\n        var done = t / max_t\n        var left = left_arr\n        for (i = 0; i < 3; i++) {\n            var dv = vec[i] * done\n            base[i] += dv\n            max[i] += dv\n            left[i] = vec[i] - dv\n        }\n\n        // set leading edge of stepped axis exactly to voxel boundary\n        // else we'll sometimes rounding error beyond it\n        if (dir > 0) {\n            max[axis] = Math.round(max[axis])\n        } else {\n            base[axis] = Math.round(base[axis])\n        }\n        \n        // call back to let client update the \"left to go\" vector\n        var res = callback(cumulative_t, axis, dir, left)\n\n        // bail out out on truthy response\n        if (res) return true\n\n        // init for new sweep along vec\n        for (i = 0; i < 3; i++) vec[i] = left[i]\n        initSweep()\n        if (max_t === 0) return true // no vector left\n\n        return false\n    }\n\n\n    // advance to next voxel boundary, and return which axis was stepped\n\n    function stepForward() {\n        var axis = (tNext[0] < tNext[1]) ?\n            ((tNext[0] < tNext[2]) ? 0 : 2) :\n            ((tNext[1] < tNext[2]) ? 1 : 2)\n        var dt = tNext[axis] - t\n        t = tNext[axis]\n        ldi[axis] += step[axis]\n        tNext[axis] += tDelta[axis]\n        for (i = 0; i < 3; i++) {\n            tr[i] += dt * normed[i]\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n        }\n\n        return axis\n    }\n\n\n\n    function leadEdgeToInt(coord, step) {\n        return floor(coord - step * epsilon)\n    }\n    function trailEdgeToInt(coord, step) {\n        return floor(coord + step * epsilon)\n    }\n\n}\n\n\n\n\n\n// conform inputs\n\nfunction sweep(getVoxel, box, dir, callback, noTranslate, epsilon) {\n\n    var vec = vec_arr\n    var base = base_arr\n    var max = max_arr\n    var result = result_arr\n\n    // init parameter float arrays\n    for (var i = 0; i < 3; i++) {\n        vec[i] = +dir[i]\n        max[i] = +box.max[i]\n        base[i] = +box.base[i]\n    }\n\n    if (!epsilon) epsilon = 1e-10\n\n    // run sweep implementation\n    var dist = sweep_impl(getVoxel, callback, vec, base, max, epsilon)\n\n    // translate box by distance needed to updated base value\n    if (!noTranslate) {\n        for (i = 0; i < 3; i++) {\n            result[i] = (dir[i] > 0) ? max[i] - box.max[i] : base[i] - box.base[i]\n        }\n        box.translate(result)\n    }\n\n    // return value is total distance moved (not necessarily magnitude of [end]-[start])\n    return dist\n}\n\nmodule.exports = sweep\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/voxel-aabb-sweep/index.js?");

/***/ }),

/***/ "../../node_modules/voxel-physics-engine/src/index.js":
/*!********************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/voxel-physics-engine/src/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"../../node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\nvar sweep = __webpack_require__(/*! voxel-aabb-sweep */ \"../../node_modules/voxel-aabb-sweep/index.js\")\nvar RigidBody = __webpack_require__(/*! ./rigidBody */ \"../../node_modules/voxel-physics-engine/src/rigidBody.js\")\n\n\nvar DEBUG = 0\n\n\nmodule.exports = function (opts, testSolid, testFluid) {\n    return new Physics(opts, testSolid, testFluid)\n}\n\nvar defaults = {\n    gravity: [0, -10, 0],\n    minBounceImpulse: .5, // lowest collision impulse that bounces\n    airDrag: 0.1,\n    fluidDrag: 0.4,\n    fluidDensity: 2.0,\n}\n\n\n/* \n *    CONSTRUCTOR - represents a world of rigid bodies.\n * \n *  Takes testSolid(x,y,z) function to query block solidity\n *  Takes testFluid(x,y,z) function to query if a block is a fluid\n*/\nfunction Physics(opts, testSolid, testFluid) {\n    opts = Object.assign({}, defaults, opts)\n\n    this.gravity = opts.gravity\n    this.airDrag = opts.airDrag\n    this.fluidDensity = opts.fluidDensity\n    this.fluidDrag = opts.fluidDrag\n    this.minBounceImpulse = opts.minBounceImpulse\n    this.bodies = []\n\n    // collision function - TODO: abstract this into a setter?\n    this.testSolid = testSolid\n    this.testFluid = testFluid\n}\n\n\n/*\n *    ADDING AND REMOVING RIGID BODIES\n*/\n\nPhysics.prototype.addBody = function (_aabb, mass, friction,\n    restitution, gravMult, onCollide) {\n    _aabb = _aabb || new aabb([0, 0, 0], [1, 1, 1])\n    if (typeof mass == 'undefined') mass = 1\n    if (typeof friction == 'undefined') friction = 1\n    if (typeof restitution == 'undefined') restitution = 0\n    if (typeof gravMult == 'undefined') gravMult = 1\n    var b = new RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide)\n    this.bodies.push(b)\n    return b\n}\n\nPhysics.prototype.removeBody = function (b) {\n    var i = this.bodies.indexOf(b)\n    if (i < 0) return undefined\n    this.bodies.splice(i, 1)\n    b.aabb = b.onCollide = null\n}\n\n\n\n\n/*\n *    PHYSICS AND COLLISIONS\n*/\n\nvar a = vec3.create()\nvar dv = vec3.create()\nvar dx = vec3.create()\nvar impacts = vec3.create()\nvar oldResting = vec3.create()\n\n\n/*\n *    TICK HANDLER\n*/\nPhysics.prototype.tick = function (dt) {\n    // convert dt to seconds\n    dt = dt / 1000\n    var noGravity = equals(0, vec3.squaredLength(this.gravity))\n\n    this.bodies.forEach(b => iterateBody(this, b, dt, noGravity))\n}\n\n\n\n/*\n *    PER-BODY MAIN PHYSICS ROUTINE\n*/\n\nfunction iterateBody(self, b, dt, noGravity) {\n    vec3.copy(oldResting, b.resting)\n\n    // treat bodies with <= mass as static\n    if (b.mass <= 0) {\n        vec3.set(b.velocity, 0, 0, 0)\n        vec3.set(b._forces, 0, 0, 0)\n        vec3.set(b._impulses, 0, 0, 0)\n        return\n    }\n\n    // skip bodies if static or no velocity/forces/impulses\n    var localNoGrav = noGravity || (b.gravityMultiplier === 0)\n    if (bodyAsleep(self, b, dt, localNoGrav)) return\n    b._sleepFrameCount--\n\n    // check if under water, if so apply buoyancy and drag forces\n    applyFluidForces(self, b)\n\n    // debug hooks\n    sanityCheck(b._forces)\n    sanityCheck(b._impulses)\n    sanityCheck(b.velocity)\n    sanityCheck(b.resting)\n\n    // semi-implicit Euler integration\n\n    // a = f/m + gravity*gravityMultiplier\n    vec3.scale(a, b._forces, 1 / b.mass)\n    vec3.scaleAndAdd(a, a, self.gravity, b.gravityMultiplier)\n\n    // dv = i/m + a*dt\n    // v1 = v0 + dv\n    vec3.scale(dv, b._impulses, 1 / b.mass)\n    vec3.scaleAndAdd(dv, dv, a, dt)\n    vec3.add(b.velocity, b.velocity, dv)\n\n    // apply friction based on change in velocity this frame\n    if (b.friction) {\n        applyFrictionByAxis(0, b, dv)\n        applyFrictionByAxis(1, b, dv)\n        applyFrictionByAxis(2, b, dv)\n    }\n\n    // linear air or fluid friction - effectively v *= drag\n    // body settings override global settings\n    var drag = (b.airDrag >= 0) ? b.airDrag : self.airDrag\n    if (b.inFluid) {\n        drag = (b.fluidDrag >= 0) ? b.fluidDrag : self.fluidDrag\n        drag *= 1 - (1 - b.ratioInFluid) ** 2\n    }\n    var mult = Math.max(1 - drag * dt / b.mass, 0)\n    vec3.scale(b.velocity, b.velocity, mult)\n\n    // x1-x0 = v1*dt\n    vec3.scale(dx, b.velocity, dt)\n\n    // clear forces and impulses for next timestep\n    vec3.set(b._forces, 0, 0, 0)\n    vec3.set(b._impulses, 0, 0, 0)\n\n    // cache old position for use in autostepping\n    if (b.autoStep) {\n        cloneAABB(tmpBox, b.aabb)\n    }\n\n    // sweeps aabb along dx and accounts for collisions\n    processCollisions(self, b.aabb, dx, b.resting)\n\n    // if autostep, and on ground, run collisions again with stepped up aabb\n    if (b.autoStep) {\n        tryAutoStepping(self, b, tmpBox, dx)\n    }\n\n    // Collision impacts. b.resting shows which axes had collisions:\n    for (var i = 0; i < 3; ++i) {\n        impacts[i] = 0\n        if (b.resting[i]) {\n            // count impact only if wasn't collided last frame\n            if (!oldResting[i]) impacts[i] = -b.velocity[i]\n            b.velocity[i] = 0\n        }\n    }\n    var mag = vec3.length(impacts)\n    if (mag > .001) { // epsilon\n        // bounce if over minBounceImpulse\n        if (mag > self.minBounceImpulse && b.restitution) {\n            vec3.scale(impacts, impacts, b.restitution * b.mass)\n            b.applyImpulse(impacts)\n        }\n        // send collision event regardless\n        if (b.onCollide) b.onCollide(impacts)\n    }\n\n\n    // sleep check\n    var vsq = vec3.squaredLength(b.velocity)\n    if (vsq > 1e-5) b._markActive()\n}\n\n\n\n\n\n\n\n\n/*\n *    FLUIDS\n*/\n\nfunction applyFluidForces(self, body) {\n    // First pass at handling fluids. Assumes fluids are settled\n    //   thus, only check at corner of body, and only from bottom up\n    var box = body.aabb\n    var cx = Math.floor(box.base[0])\n    var cz = Math.floor(box.base[2])\n    var y0 = Math.floor(box.base[1])\n    var y1 = Math.floor(box.max[1])\n\n    if (!self.testFluid(cx, y0, cz)) {\n        body.inFluid = false\n        body.ratioInFluid = 0\n        return\n    }\n\n    // body is in a fluid - find out how much of body is submerged\n    var submerged = 1\n    var cy = y0 + 1\n    while (cy <= y1 && self.testFluid(cx, cy, cz)) {\n        submerged++\n        cy++\n    }\n    var fluidLevel = y0 + submerged\n    var heightInFluid = fluidLevel - box.base[1]\n    var ratioInFluid = heightInFluid / box.vec[1]\n    if (ratioInFluid > 1) ratioInFluid = 1\n    var vol = box.vec[0] * box.vec[1] * box.vec[2]\n    var displaced = vol * ratioInFluid\n    // bouyant force = -gravity * fluidDensity * volumeDisplaced\n    var f = _fluidVec\n    vec3.scale(f, self.gravity, -self.fluidDensity * displaced)\n    body.applyForce(f)\n\n    body.inFluid = true\n    body.ratioInFluid = ratioInFluid\n}\n\nvar _fluidVec = vec3.create()\n\n\n\n\n\n/*\n *    FRICTION\n*/\n\n\nfunction applyFrictionByAxis(axis, body, dvel) {\n    // friction applies only if moving into a touched surface\n    var restDir = body.resting[axis]\n    var vNormal = dvel[axis]\n    if (restDir === 0) return\n    if (restDir * vNormal <= 0) return\n\n    // current vel lateral to friction axis\n    vec3.copy(lateralVel, body.velocity)\n    lateralVel[axis] = 0\n    var vCurr = vec3.length(lateralVel)\n    if (equals(vCurr, 0)) return\n\n    // treat current change in velocity as the result of a pseudoforce\n    //        Fpseudo = m*dv/dt\n    // Base friction force on normal component of the pseudoforce\n    //        Ff = u * Fnormal\n    //        Ff = u * m * dvnormal / dt\n    // change in velocity due to friction force\n    //        dvF = dt * Ff / m\n    //            = dt * (u * m * dvnormal / dt) / m\n    //            = u * dvnormal\n    var dvMax = Math.abs(body.friction * vNormal)\n\n    // decrease lateral vel by dvMax (or clamp to zero)\n    var scaler = (vCurr > dvMax) ? (vCurr - dvMax) / vCurr : 0\n    body.velocity[(axis + 1) % 3] *= scaler\n    body.velocity[(axis + 2) % 3] *= scaler\n}\nvar lateralVel = vec3.create()\n\n\n\n\n\n\n/*\n *    COLLISION HANDLER\n*/\n\n// sweep aabb along velocity vector and set resting vector\nfunction processCollisions(self, box, velocity, resting) {\n    vec3.set(resting, 0, 0, 0)\n    return sweep(self.testSolid, box, velocity, function (dist, axis, dir, vec) {\n        resting[axis] = dir\n        vec[axis] = 0\n    })\n}\n\n\n\n\n\n/*\n *    AUTO-STEPPING\n*/\n\nvar tmpBox = new aabb([], [])\nvar tmpResting = vec3.create()\nvar targetPos = vec3.create()\nvar upvec = vec3.create()\nvar leftover = vec3.create()\n\nfunction tryAutoStepping(self, b, oldBox, dx) {\n    if (b.resting[1] >= 0 && !b.inFluid) return\n\n    // // direction movement was blocked before trying a step\n    var xBlocked = (b.resting[0] !== 0)\n    var zBlocked = (b.resting[2] !== 0)\n    if (!(xBlocked || zBlocked)) return\n\n    // continue autostepping only if headed sufficiently into obstruction\n    var ratio = Math.abs(dx[0] / dx[2])\n    var cutoff = 4\n    if (!xBlocked && ratio > cutoff) return\n    if (!zBlocked && ratio < 1 / cutoff) return\n\n    // original target position before being obstructed\n    vec3.add(targetPos, oldBox.base, dx)\n\n    // move towards the target until the first X/Z collision\n    var getVoxels = self.testSolid\n    sweep(getVoxels, oldBox, dx, function (dist, axis, dir, vec) {\n        if (axis === 1) vec[axis] = 0\n        else return true\n    })\n\n    var y = b.aabb.base[1]\n    var ydist = Math.floor(y + 1.001) - y\n    vec3.set(upvec, 0, ydist, 0)\n    var collided = false\n    // sweep up, bailing on any obstruction\n    sweep(getVoxels, oldBox, upvec, function (dist, axis, dir, vec) {\n        collided = true\n        return true\n    })\n    if (collided) return // could't move upwards\n\n    // now move in X/Z however far was left over before hitting the obstruction\n    vec3.subtract(leftover, targetPos, oldBox.base)\n    leftover[1] = 0\n    processCollisions(self, oldBox, leftover, tmpResting)\n\n    // bail if no movement happened in the originally blocked direction\n    if (xBlocked && !equals(oldBox.base[0], targetPos[0])) return\n    if (zBlocked && !equals(oldBox.base[2], targetPos[2])) return\n\n    // done - oldBox is now at the target autostepped position\n    cloneAABB(b.aabb, oldBox)\n    b.resting[0] = tmpResting[0]\n    b.resting[2] = tmpResting[2]\n    if (b.onStep) b.onStep()\n}\n\n\n\n\n\n/*\n *    SLEEP CHECK\n*/\n\nfunction bodyAsleep(self, body, dt, noGravity) {\n    if (body._sleepFrameCount > 0) return false\n    // without gravity bodies stay asleep until a force/impulse wakes them up\n    if (noGravity) return true\n    // otherwise check body is resting against something\n    // i.e. sweep along by distance d = 1/2 g*t^2\n    // and check there's still a collision\n    var isResting = false\n    var gmult = 0.5 * dt * dt * body.gravityMultiplier\n    vec3.scale(sleepVec, self.gravity, gmult)\n    sweep(self.testSolid, body.aabb, sleepVec, function () {\n        isResting = true\n        return true\n    }, true)\n    return isResting\n}\nvar sleepVec = vec3.create()\n\n\n\n\n\nfunction equals(a, b) { return Math.abs(a - b) < 1e-5 }\n\nfunction cloneAABB(tgt, src) {\n    for (var i = 0; i < 3; i++) {\n        tgt.base[i] = src.base[i]\n        tgt.max[i] = src.max[i]\n        tgt.vec[i] = src.vec[i]\n    }\n}\n\n\n\nvar sanityCheck = function () { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ', v\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/voxel-physics-engine/src/index.js?");

/***/ }),

/***/ "../../node_modules/voxel-physics-engine/src/rigidBody.js":
/*!************************************************************************************!*\
  !*** /home/sasogu/web/EduCraft/node_modules/voxel-physics-engine/src/rigidBody.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"../../node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\n\nvar DEBUG = 0\n\n\nmodule.exports = RigidBody\n\n\n\n/*\n *    RIGID BODY - internal data structure\n *  Only AABB bodies right now. Someday will likely need spheres?\n*/\n\nfunction RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide, autoStep) {\n    this.aabb = new aabb(_aabb.base, _aabb.vec) // clone\n    this.mass = mass\n    this.friction = friction\n    this.restitution = restitution\n    this.gravityMultiplier = gravMult\n    this.onCollide = onCollide\n    this.autoStep = !!autoStep\n    this.airDrag = -1   // overrides global airDrag when >= 0\n    this.fluidDrag = -1 // overrides global fluidDrag when >= 0\n    this.onStep = null\n    \n    // internals\n    this.velocity = vec3.create()\n    this.resting = [0, 0, 0]\n    this.inFluid = false\n    this._ratioInFluid = 0\n    this._forces = vec3.create()\n    this._impulses = vec3.create()\n    this._sleepFrameCount = 10 | 0\n}\n\nRigidBody.prototype.setPosition = function (p) {\n    sanityCheck(p)\n    vec3.subtract(p, p, this.aabb.base)\n    this.aabb.translate(p)\n    this._markActive()\n}\nRigidBody.prototype.getPosition = function () {\n    return vec3.clone(this.aabb.base)\n}\nRigidBody.prototype.applyForce = function (f) {\n    sanityCheck(f)\n    vec3.add(this._forces, this._forces, f)\n    this._markActive()\n}\nRigidBody.prototype.applyImpulse = function (i) {\n    sanityCheck(i)\n    vec3.add(this._impulses, this._impulses, i)\n    this._markActive()\n}\nRigidBody.prototype._markActive = function () {\n    this._sleepFrameCount = 10 | 0\n}\n\n\n\n// temp\nRigidBody.prototype.atRestX = function () { return this.resting[0] }\nRigidBody.prototype.atRestY = function () { return this.resting[1] }\nRigidBody.prototype.atRestZ = function () { return this.resting[2] }\n\n\n\n\n\nvar sanityCheck = function () { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ', v\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/node_modules/voxel-physics-engine/src/rigidBody.js?");

/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../../package.json":
/*!**********************************************!*\
  !*** /home/sasogu/web/EduCraft/package.json ***!
  \**********************************************/
/*! exports provided: name, version, description, main, scripts, author, keywords, license, dependencies, repository, bugs, devDependencies, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"noa-engine\",\"version\":\"0.25.1\",\"description\":\"Experimental voxel game engine\",\"main\":\"src/index.js\",\"scripts\":{\"start\":\"cd docs/hello-world && webpack-dev-server\",\"test\":\"cd docs/test && webpack-dev-server\",\"build\":\"cd docs/hello-world && webpack && cd ../test && webpack\"},\"author\":\"Andy Hall\",\"keywords\":[\"voxel\",\"game\",\"engine\"],\"license\":\"MIT\",\"dependencies\":{\"aabb-3d\":\"andyhall/aabb-3d\",\"box-intersect\":\"^1.0.1\",\"dexie\":\"^3.0.3\",\"ent-comp\":\"^0.7.0\",\"fast-voxel-raycast\":\"^0.1.1\",\"game-inputs\":\"^0.2.0\",\"game-shell\":\"andyhall/game-shell\",\"gl-vec3\":\"^1.1.3\",\"ndarray\":\"^1.0.16\",\"ndarray-hash\":\"^1.0.0\",\"noa-engine\":\"^0.33.0\",\"voxel-aabb-sweep\":\"^0.5.0\",\"voxel-physics-engine\":\"^0.9.0\"},\"repository\":\"https://github.com/andyhall/noa\",\"bugs\":{\"url\":\"https://github.com/andyhall/noa/issues\"},\"devDependencies\":{\"webpack\":\"^4.26.0\",\"webpack-cli\":\"^3.1.2\",\"webpack-dev-server\":\"^3.1.11\"}};\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/package.json?");

/***/ }),

/***/ "../../src/components/collideEntities.js":
/*!*******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/collideEntities.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar boxIntersect = __webpack_require__(/*! box-intersect */ \"../../node_modules/box-intersect/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\n\n/*\n * \tEvery frame, entities with this component will get mutually checked for colliions\n * \n *   * cylinder: flag for checking collisions as a vertical cylindar (rather than AABB)\n *   * collideBits: category for this entity\n *   * collideMask: categories this entity collides with\n *   * callback: function(other_id) - called when `own.collideBits & other.collideMask` is true\n * \n * \n * \t\tNotes:\n * \tSet collideBits=0 for entities like bullets, which can collide with things \n * \t\tbut are never the target of a collision.\n * \tSet collideMask=0 for things with no callback - things that get collided with,\n * \t\tbut don't themselves instigate collisions.\n * \n*/\n\n\n\nmodule.exports = function (noa) {\n\n\treturn {\n\n\t\tname: 'collideEntities',\n\n\t\tstate: {\n\t\t\tcylinder: false,\n\t\t\tcollideBits: 1 | 0,\n\t\t\tcollideMask: 1 | 0,\n\t\t\tcallback: null,\n\t\t},\n\n\t\tonAdd: null,\n\n\t\tonRemove: null,\n\n\n\t\tsystem: function entityCollider(dt, states) {\n\t\t\tvar ents = noa.ents\n\n\t\t\t// data struct that boxIntersect looks for\n\t\t\t// - array of [lo, lo, lo, hi, hi, hi] extents\n\t\t\tvar intervals = []\n\t\t\tfor (var i = 0; i < states.length; i++) {\n\t\t\t\tvar id = states[i].__id\n\t\t\t\tvar dat = ents.getPositionData(id)\n\t\t\t\tintervals[i] = dat._extents\n\t\t\t}\n\n\t\t\t// run the intersect library\n\t\t\tboxIntersect(intervals, function (a, b) {\n\t\t\t\tvar stateA = states[a]\n\t\t\t\tvar stateB = states[b]\n\t\t\t\tvar intervalA = intervals[a]\n\t\t\t\tvar intervalB = intervals[b]\n\t\t\t\tif (cylindricalHitTest(stateA, stateB, intervalA, intervalB)) {\n\t\t\t\t\thandleCollision(noa, stateA, stateB)\n\t\t\t\t}\n\t\t\t})\n\n\t\t}\n\t}\n\n\n\n\t/*\n\t * \n\t * \t\tIMPLEMENTATION\n\t * \n\t*/\n\n\n\tfunction handleCollision(noa, stateA, stateB) {\n\t\tvar idA = stateA.__id\n\t\tvar idB = stateB.__id\n\n\t\t// entities really do overlap, so check masks and call event handlers\n\t\tif (stateA.collideMask & stateB.collideBits) {\n\t\t\tif (stateA.callback) stateA.callback(idB)\n\t\t}\n\t\tif (stateB.collideMask & stateA.collideBits) {\n\t\t\tif (stateB.callback) stateB.callback(idA)\n\t\t}\n\n\t\t// general pairwise handler\n\t\tnoa.ents.onPairwiseEntityCollision(idA, idB)\n\t}\n\n\n\n\t// For entities whose extents overlap, \n\t// test if collision still happens when taking cylinder flags into account\n\n\tfunction cylindricalHitTest(stateA, stateB, intervalA, intervalB) {\n\t\tif (stateA.cylinder) {\n\t\t\tif (stateB.cylinder) {\n\t\t\t\treturn cylinderCylinderTest(intervalA, intervalB)\n\t\t\t} else {\n\t\t\t\treturn cylinderBoxTest(intervalA, intervalB)\n\t\t\t}\n\t\t} else if (stateB.cylinder) {\n\t\t\treturn cylinderBoxTest(intervalB, intervalA)\n\t\t}\n\t\treturn true\n\t}\n\n\n\n\n\t// Cylinder-cylinder hit test (AABBs are known to overlap)\n\t// given their extent arrays [lo, lo, lo, hi, hi, hi]\n\n\tfunction cylinderCylinderTest(a, b) {\n\t\t// distance between cylinder centers\n\t\tvar rada = (a[3] - a[0]) / 2\n\t\tvar radb = (b[3] - b[0]) / 2\n\t\tvar dx = a[0] + rada - (b[0] + radb)\n\t\tvar dz = a[2] + rada - (b[2] + radb)\n\t\t// collide if dist <= sum of radii\n\t\tvar distsq = dx * dx + dz * dz\n\t\tvar radsum = rada + radb\n\t\treturn (distsq <= radsum * radsum)\n\t}\n\n\n\n\n\t// Cylinder-Box hit test (AABBs are known to overlap)\n\t// given their extent arrays [lo, lo, lo, hi, hi, hi]\n\n\tfunction cylinderBoxTest(cyl, cube) {\n\t\t// X-z center of cylinder\n\t\tvar rad = (cyl[3] - cyl[0]) / 2\n\t\tvar cx = cyl[0] + rad\n\t\tvar cz = cyl[2] + rad\n\t\t// point in X-Z square closest to cylinder\n\t\tvar px = clamp(cx, cube[0], cube[3])\n\t\tvar pz = clamp(cz, cube[2], cube[5])\n\t\t// collision if distance from that point to circle <= cylinder radius\n\t\tvar dx = px - cx\n\t\tvar dz = pz - cz\n\t\tvar distsq = dx * dx + dz * dz\n\t\treturn (distsq <= rad * rad)\n\t}\n\n\tfunction clamp(val, lo, hi) {\n\t\treturn (val < lo) ? lo : (val > hi) ? hi : val\n\t}\n\n\n\n\n}\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/collideEntities.js?");

/***/ }),

/***/ "../../src/components/collideTerrain.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/collideTerrain.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (noa) {\n\treturn {\n\n\t\tname: 'collideTerrain',\n\n\t\tstate: {\n\t\t\tcallback: null\n\t\t},\n\n\t\tonAdd: function (eid, state) {\n\t\t\t// add collide handler for physics engine to call\n\t\t\tvar ents = noa.entities\n\t\t\tif (ents.hasPhysics(eid)) {\n\t\t\t\tvar body = ents.getPhysicsBody(eid)\n\t\t\t\tbody.onCollide = function bodyOnCollide(impulse) {\n\t\t\t\t\tvar cb = noa.ents.getCollideTerrain(eid).callback\n\t\t\t\t\tif (cb) cb(impulse, eid)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tonRemove: function (eid, state) {\n\t\t\tvar ents = noa.entities\n\t\t\tif (ents.hasPhysics(eid)) {\n\t\t\t\tents.getPhysicsBody(eid).onCollide = null\n\t\t\t}\n\t\t},\n\n\n\t\tsystem: null\n\n\n\t}\n}\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/collideTerrain.js?");

/***/ }),

/***/ "../../src/components/fadeOnZoom.js":
/*!**************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/fadeOnZoom.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Component for the player entity, when active hides the player's mesh \n * when camera zoom is less than a certain amount\n */\n\nmodule.exports = function (noa) {\n\treturn {\n\n\t\tname: 'fadeOnZoom',\n\n\t\tstate: {\n\t\t\tcutoff: 1.5,\n\t\t\t_showing: true\n\t\t},\n\n\t\tonAdd: null,\n\n\t\tonRemove: null,\n\n\t\tsystem: function fadeOnZoomProc(dt, states) {\n\t\t\tvar zoom = noa.rendering._currentZoom\n\t\t\tvar ents = noa.entities\n\t\t\tstates.forEach(state => {\n\t\t\t\tcheckZoom(state, state.__id, zoom, ents)\n\t\t\t})\n\t\t}\n\t}\n}\n\n\nfunction checkZoom(state, id, zoom, ents) {\n\tif (!ents.hasMesh(id)) return\n\n\tif (state._showing && zoom < state.cutoff || !state._showing && zoom > state.cutoff) {\n\t\tvar mesh = ents.getMeshData(id).mesh\n\t\tmesh.visibility = state._showing = (zoom > state.cutoff)\n\t}\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/fadeOnZoom.js?");

/***/ }),

/***/ "../../src/components/followsEntity.js":
/*!*****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/followsEntity.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\n\n/*\n * Indicates that an entity should be moved to another entity's position each tick,\n * possibly by a fixed offset, and the same for renderPositions each render\n*/\n\nmodule.exports = function (noa) {\n\n\treturn {\n\n\t\tname: 'followsEntity',\n\n\t\tstate: {\n\t\t\tentity: 0 | 0,\n\t\t\toffset: null,\n\t\t},\n\n\t\tonAdd: function (eid, state) {\n\t\t\tvar off = vec3.create()\n\t\t\tstate.offset = (state.offset) ? vec3.copy(off, state.offset) : off\n\t\t\tupdatePosition(state)\n\t\t\tupdateRenderPosition(state)\n\t\t},\n\n\t\tonRemove: null,\n\n\n\t\t// on tick, copy over regular positions\n\t\tsystem: function followEntity(dt, states) {\n\t\t\tstates.forEach(state => {\n\t\t\t\tupdatePosition(state)\n\t\t\t})\n\t\t},\n\n\n\t\t// on render, copy over render positions\n\t\trenderSystem: function followEntityMesh(dt, states) {\n\t\t\tstates.forEach(state => {\n\t\t\t\tupdateRenderPosition(state)\n\t\t\t})\n\t\t}\n\t}\n\n\n\n\tfunction updatePosition(state) {\n\t\tvar id = state.__id\n\t\tvar self = noa.ents.getPositionData(id)\n\t\tvar other = noa.ents.getPositionData(state.entity)\n\t\tif (other) {\n\t\t\tvec3.add(self.position, other.position, state.offset)\n\t\t\tself._extentsChanged = true\n\t\t} else {\n\t\t\tnoa.ents.removeComponent(id, noa.ents.names.followsEntity)\n\t\t}\n\t}\n\n\tfunction updateRenderPosition(state) {\n\t\tvar id = state.__id\n\t\tvar self = noa.ents.getPositionData(id)\n\t\tvar other = noa.ents.getPositionData(state.entity)\n\t\tif (other) {\n\t\t\tvec3.add(self.renderPosition, other.renderPosition, state.offset)\n\t\t} else {\n\t\t\tnoa.ents.removeComponent(id, noa.ents.names.followsEntity)\n\t\t}\n\t}\n\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/followsEntity.js?");

/***/ }),

/***/ "../../src/components/mesh.js":
/*!********************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/mesh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\nmodule.exports = function (noa) {\n\treturn {\n\n\t\tname: 'mesh',\n\n\t\tstate: {\n\t\t\tmesh: null,\n\t\t\toffset: null\n\t\t},\n\n\n\t\tonAdd: function (eid, state) {\n\t\t\tif (state.mesh) {\n\t\t\t\tnoa.rendering.addMeshToScene(state.mesh)\n\t\t\t} else {\n\t\t\t\tthrow new Error('Mesh component added without a mesh - probably a bug!')\n\t\t\t}\n\t\t\tif (!state.offset) {\n\t\t\t\tstate.offset = new vec3.create()\n\t\t\t}\n\n\t\t\t// initialize mesh to correct position\n\t\t\tvar pos = noa.ents.getPosition(eid)\n\t\t\tvar mpos = state.mesh.position\n\t\t\tmpos.x = pos[0] + state.offset[0]\n\t\t\tmpos.y = pos[1] + state.offset[1]\n\t\t\tmpos.z = pos[2] + state.offset[2]\n\t\t},\n\n\n\t\tonRemove: function (eid, state) {\n\t\t\tstate.mesh.dispose()\n\t\t},\n\n\n\t\tsystem: null,\n\n\n\n\t\trenderSystem: function (dt, states) {\n\t\t\t// before render move each mesh to its render position, \n\t\t\t// set by the physics engine or driving logic\n\n\t\t\tstates.forEach(state => {\n\t\t\t\tvar id = state.__id\n\n\t\t\t\tvar rpos = noa.ents.getPositionData(id).renderPosition\n\t\t\t\tvar x = rpos[0] + state.offset[0]\n\t\t\t\tvar y = rpos[1] + state.offset[1]\n\t\t\t\tvar z = rpos[2] + state.offset[2]\n\n\t\t\t\tstate.mesh.position.copyFromFloats(x, y, z)\n\t\t\t})\n\t\t}\n\n\n\t}\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/mesh.js?");

/***/ }),

/***/ "../../src/components/movement.js":
/*!************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/movement.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\n/**\n * \n * Movement component. State stores settings like jump height, etc.,\n * as well as current state (running, jumping, heading angle).\n * Processor checks state and applies movement/friction/jump forces\n * to the entity's physics body. \n * \n */\n\nmodule.exports = function (noa) {\n\treturn {\n\n\t\tname: 'movement',\n\n\t\tstate: {\n\t\t\t// current state\n\t\t\theading: 0, \t\t\t// radians\n\t\t\trunning: false,\n\t\t\tjumping: false,\n\n\t\t\t// options:\n\t\t\tmaxSpeed: 10,\n\t\t\tmoveForce: 30,\n\t\t\tresponsiveness: 15,\n\t\t\trunningFriction: 0,\n\t\t\tstandingFriction: 2,\n\n\t\t\tairMoveMult: 0.5,\n\t\t\tjumpImpulse: 10,\n\t\t\tjumpForce: 12,\n\t\t\tjumpTime: 500, \t\t\t// ms\n\t\t\tairJumps: 1,\n\n\t\t\t// internal state\n\t\t\t_jumpCount: 0,\n\t\t\t_isJumping: 0,\n\t\t\t_currjumptime: 0,\n\t\t},\n\n\t\tonAdd: null,\n\n\t\tonRemove: null,\n\n\n\t\tsystem: function movementProcessor(dt, states) {\n\t\t\tvar ents = noa.entities\n\n\t\t\tstates.forEach(state => {\n\t\t\t\tvar body = ents.getPhysicsBody(state.__id)\n\t\t\t\tapplyMovementPhysics(dt, state, body)\n\t\t\t})\n\n\t\t}\n\n\n\t}\n}\n\n\nvar tempvec = vec3.create()\nvar tempvec2 = vec3.create()\nvar zeroVec = vec3.create()\n\n\nfunction applyMovementPhysics(dt, state, body) {\n\t// move implementation originally written as external module\n\t//   see https://github.com/andyhall/voxel-fps-controller\n\t//   for original code\n\n\t// jumping\n\tvar onGround = (body.atRestY() < 0)\n\tvar canjump = (onGround || state._jumpCount < state.airJumps)\n\tif (onGround) {\n\t\tstate._isJumping = false\n\t\tstate._jumpCount = 0\n\t}\n\n\t// process jump input\n\tif (state.jumping) {\n\t\tif (state._isJumping) { // continue previous jump\n\t\t\tif (state._currjumptime > 0) {\n\t\t\t\tvar jf = state.jumpForce\n\t\t\t\tif (state._currjumptime < dt) jf *= state._currjumptime / dt\n\t\t\t\tbody.applyForce([0, jf, 0])\n\t\t\t\tstate._currjumptime -= dt\n\t\t\t}\n\t\t} else if (canjump) { // start new jump\n\t\t\tstate._isJumping = true\n\t\t\tif (!onGround) state._jumpCount++\n\t\t\tstate._currjumptime = state.jumpTime\n\t\t\tbody.applyImpulse([0, state.jumpImpulse, 0])\n\t\t\t// clear downward velocity on airjump\n\t\t\tif (!onGround && body.velocity[1] < 0) body.velocity[1] = 0\n\t\t}\n\t} else {\n\t\tstate._isJumping = false\n\t}\n\n\t// apply movement forces if entity is moving, otherwise just friction\n\tvar m = tempvec\n\tvar push = tempvec2\n\tif (state.running) {\n\n\t\tvar speed = state.maxSpeed\n\t\t// todo: add crouch/sprint modifiers if needed\n\t\t// if (state.sprint) speed *= state.sprintMoveMult\n\t\t// if (state.crouch) speed *= state.crouchMoveMult\n\t\tvec3.set(m, 0, 0, speed)\n\n\t\t// rotate move vector to entity's heading\n\t\tvec3.rotateY(m, m, zeroVec, state.heading)\n\n\t\t// push vector to achieve desired speed & dir\n\t\t// following code to adjust 2D velocity to desired amount is patterned on Quake: \n\t\t// https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/bg_pmove.c#L275\n\t\tvec3.subtract(push, m, body.velocity)\n\t\tpush[1] = 0\n\t\tvar pushLen = vec3.length(push)\n\t\tvec3.normalize(push, push)\n\n\t\tif (pushLen > 0) {\n\t\t\t// pushing force vector\n\t\t\tvar canPush = state.moveForce\n\t\t\tif (!onGround) canPush *= state.airMoveMult\n\n\t\t\t// apply final force\n\t\t\tvar pushAmt = state.responsiveness * pushLen\n\t\t\tif (canPush > pushAmt) canPush = pushAmt\n\n\t\t\tvec3.scale(push, push, canPush)\n\t\t\tbody.applyForce(push)\n\t\t}\n\n\t\t// different friction when not moving\n\t\t// idea from Sonic: http://info.sonicretro.org/SPG:Running\n\t\tbody.friction = state.runningFriction\n\t} else {\n\t\tbody.friction = state.standingFriction\n\t}\n\n\n\n}\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/movement.js?");

/***/ }),

/***/ "../../src/components/physics.js":
/*!***********************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/physics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\n\nmodule.exports = function (noa) {\n\n\n\treturn {\n\n\t\tname: 'physics',\n\n\n\t\tstate: {\n\t\t\tbody: null,\n\t\t},\n\n\n\t\tonAdd: function (entID, state) {\n\t\t\tstate.body = noa.physics.addBody()\n\t\t\t// implicitly assume body has a position component, to get size\n\t\t\tvar dat = noa.ents.getPositionData(state.__id)\n\t\t\tnoa.ents.setEntitySize(state.__id, dat.width, dat.height, dat.width)\n\t\t},\n\n\n\t\tonRemove: function (entID, state) {\n\t\t\t// update position before removing\n\t\t\t// this lets entity wind up at e.g. the result of a collision\n\t\t\t// even if physics component is removed in collision handler\n\t\t\tif (noa.ents.hasPosition(state.__id)) {\n\t\t\t\tvar pdat = noa.ents.getPositionData(state.__id)\n\t\t\t\tupdatePositionFromPhysics(state, pdat)\n\t\t\t\tbacktrackRenderPos(state, pdat, 0, false)\n\t\t\t}\n\t\t\tnoa.physics.removeBody(state.body)\n\t\t},\n\n\n\t\tsystem: function (dt, states) {\n\t\t\tstates.forEach(state => {\n\t\t\t\tvar pdat = noa.ents.getPositionData(state.__id)\n\t\t\t\tupdatePositionFromPhysics(state, pdat)\n\t\t\t})\n\t\t},\n\n\n\t\trenderSystem: function (dt, states) {\n\n\t\t\t// dt is time (ms) since physics engine tick\n\t\t\t// to avoid temporal aliasing, render the state as if lerping between\n\t\t\t// the last position and the next one \n\t\t\t// since the entity data is the \"next\" position this amounts to \n\t\t\t// offsetting each entity into the past by tickRate - dt\n\t\t\t// http://gafferongames.com/game-physics/fix-your-timestep/\n\n\t\t\tvar backtrackAmt = - (noa._tickRate - dt) / 1000\n\t\t\tstates.forEach(state => {\n\t\t\t\tvar id = state.__id\n\t\t\t\tvar pdat = noa.ents.getPositionData(id)\n\t\t\t\tvar smoothed = noa.ents.cameraSmoothed(id)\n\t\t\t\tbacktrackRenderPos(state, pdat, backtrackAmt, smoothed)\n\t\t\t})\n\t\t}\n\n\t}\n\n}\n\n\n\nvar offset = vec3.create()\nvar pos = vec3.create()\n\n\n\nfunction updatePositionFromPhysics(state, posDat) {\n\toffset[0] = offset[2] = posDat.width / 2\n\toffset[1] = 0\n\tvar pos = posDat.position\n\tvar base = state.body.aabb.base\n\tvar max = state.body.aabb.max\n\tvar ext = posDat._extents\n\tfor (var j = 0; j < 3; j++) {\n\t\tpos[j] = base[j] + offset[j]\n\t\text[j] = base[j]\n\t\text[j + 3] = max[j]\n\t}\n}\n\n\nfunction backtrackRenderPos(state, posDat, backtrackAmt, smoothed) {\n\t// pos = pos + backtrack * body.velocity\n\tvec3.scaleAndAdd(pos, posDat.position, state.body.velocity, backtrackAmt)\n\n\t// smooth out update if component is present\n\t// (this is set after sudden movements like auto-stepping)\n\tif (smoothed) vec3.lerp(pos, posDat.renderPosition, pos, 0.3)\n\n\t// copy values over to renderPosition, \n\tvec3.copy(posDat.renderPosition, pos)\n}\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/physics.js?");

/***/ }),

/***/ "../../src/components/position.js":
/*!************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/position.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\n\n\n/**\n * \n * \tComponent holding entity's position, width, and height.\n *  By convention, \"position\" is the bottom center of the entity's AABB\n * \n */\n\n\nmodule.exports = function (noa) {\n\n\tvar hasWarned = false\n\n\treturn {\n\n\t\tname: 'position',\n\n\t\tstate: {\n\t\t\tposition: null,\n\t\t\trenderPosition: null,\n\t\t\twidth: +0,\n\t\t\theight: +0,\n\t\t\t_extents: null,\n\t\t\t_extentsChanged: true,\n\t\t},\n\n\n\t\tonAdd: function (eid, state) {\n\t\t\tif (state.position) {\n\t\t\t\tif (!(state.position instanceof Float32Array) && !hasWarned) {\n\t\t\t\t\tconsole.warn('Better to set entity positions as instances of \"gl-vec3\"!')\n\t\t\t\t\thasWarned = true\n\t\t\t\t}\n\t\t\t} else state.position = vec3.create()\n\n\t\t\tstate.renderPosition = vec3.create()\n\t\t\tvec3.copy(state.renderPosition, state.position)\n\n\t\t\tstate._extents = new Float32Array(6)\n\t\t},\n\n\t\tonRemove: null,\n\n\n\n\t\tsystem: function (dt, states) {\n\t\t\tstates.forEach(state => {\n\t\t\t\tif (!state._extentsChanged) return\n\t\t\t\tupdateExtents(state._extents, state.position, state.height, state.width)\n\t\t\t\tstate._extentsChanged = false\n\t\t\t})\n\t\t},\n\n\n\t}\n}\n\n\nfunction updateExtents(ext, pos, height, width) {\n\tvar hw = width / 2\n\text[0] = pos[0] - hw\n\text[1] = pos[1]\n\text[2] = pos[2] - hw\n\text[3] = pos[0] + hw\n\text[4] = pos[1] + height\n\text[5] = pos[2] + hw\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/position.js?");

/***/ }),

/***/ "../../src/components/receivesInputs.js":
/*!******************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/receivesInputs.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * \n * Input processing component - gets (key) input state and  \n * applies it to receiving entities by updating their movement \n * component state (heading, movespeed, jumping, etc.)\n * \n */\n\nmodule.exports = function (noa) {\n\treturn {\n\n\t\tname: 'receivesInputs',\n\n\t\tstate: {},\n\n\t\tonAdd: null,\n\n\t\tonRemove: null,\n\n\t\tsystem: function inputProcessor(dt, states) {\n\t\t\tvar ents = noa.entities\n\t\t\tvar inputState = noa.inputs.state\n\t\t\tvar camHeading = noa.rendering.getCameraRotation()[1]\n\n\t\t\tstates.forEach(state => {\n\t\t\t\tvar moveState = ents.getMovement(state.__id)\n\t\t\t\tsetMovementState(moveState, inputState, camHeading)\n\t\t\t})\n\t\t}\n\n\t}\n}\n\n\n\nfunction setMovementState(state, inputs, camHeading) {\n\tstate.jumping = !!inputs.jump\n\n\tvar fb = inputs.forward ? (inputs.backward ? 0 : 1) : (inputs.backward ? -1 : 0)\n\tvar rl = inputs.right ? (inputs.left ? 0 : 1) : (inputs.left ? -1 : 0)\n\n\tif ((fb | rl) === 0) {\n\t\tstate.running = false\n\t} else {\n\t\tstate.running = true\n\t\tif (fb) {\n\t\t\tif (fb == -1) camHeading += Math.PI\n\t\t\tif (rl) {\n\t\t\t\tcamHeading += Math.PI / 4 * fb * rl // didn't plan this but it works!\n\t\t\t}\n\t\t} else {\n\t\t\tcamHeading += rl * Math.PI / 2\n\t\t}\n\t\tstate.heading = camHeading\n\t}\n\n}\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/receivesInputs.js?");

/***/ }),

/***/ "../../src/components/shadow.js":
/*!**********************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/shadow.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\nvar shadowDist\n\nmodule.exports = function (noa, dist) {\n\n\tshadowDist = dist\n\n\t// create a mesh to re-use for shadows\n\tvar scene = noa.rendering.getScene()\n\tvar disc = BABYLON.Mesh.CreateDisc('shadow', 0.75, 30, scene)\n\tdisc.rotation.x = Math.PI / 2\n\tdisc.material = noa.rendering.makeStandardMaterial('shadowMat')\n\tdisc.material.diffuseColor = BABYLON.Color3.Black()\n\tdisc.material.ambientColor = BABYLON.Color3.Black()\n\tdisc.material.alpha = 0.5\n\tdisc.setEnabled(false)\n\n\t// source mesh needn't be in the scene graph\n\tscene.removeMesh(disc)\n\n\n\treturn {\n\n\t\tname: 'shadow',\n\n\t\tstate: {\n\t\t\tsize: 0.5,\n\t\t\t_mesh: null,\n\t\t},\n\n\n\t\tonAdd: function (eid, state) {\n\t\t\tstate._mesh = noa.rendering.makeMeshInstance(disc, false)\n\t\t},\n\n\n\t\tonRemove: function (eid, state) {\n\t\t\tstate._mesh.dispose()\n\t\t},\n\n\n\t\tsystem: function shadowSystem(dt, states) {\n\t\t\tvar cpos = noa.rendering.getCameraPosition()\n\t\t\tvec3.set(camPos, cpos.x, cpos.y, cpos.z)\n\t\t\tvar dist = shadowDist\n\t\t\tstates.forEach(state => {\n\t\t\t\tupdateShadowHeight(state.__id, state._mesh, state.size, dist, noa)\n\t\t\t})\n\t\t},\n\n\n\t\trenderSystem: function (dt, states) {\n\t\t\t// before render adjust shadow x/z to render positions\n\t\t\tstates.forEach(state => {\n\t\t\t\tvar rpos = noa.ents.getPositionData(state.__id).renderPosition\n\t\t\t\tvar spos = state._mesh.position\n\t\t\t\tspos.x = rpos[0]\n\t\t\t\tspos.z = rpos[2]\n\t\t\t})\n\t\t}\n\n\n\n\n\t}\n}\n\nvar down = vec3.fromValues(0, -1, 0)\nvar camPos = vec3.fromValues(0, 0, 0)\nvar shadowPos = vec3.fromValues(0, 0, 0)\n\nfunction updateShadowHeight(id, mesh, size, shadowDist, noa) {\n\tvar ents = noa.entities\n\tvar dat = ents.getPositionData(id)\n\tvar loc = dat.position\n\tvar y\n\n\t// find Y location, from physics if on ground, otherwise by raycast\n\tif (ents.hasPhysics(id) && ents.getPhysicsBody(id).resting[1] < 0) {\n\t\ty = dat.renderPosition[1]\n\t} else {\n\t\tvar pick = noa.pick(loc, down, shadowDist)\n\t\tif (pick) {\n\t\t\ty = pick.position[1]\n\t\t} else {\n\t\t\tmesh.setEnabled(false)\n\t\t\treturn\n\t\t}\n\t}\n\n\ty = Math.round(y) // pick results get slightly countersunk\n\t// set shadow slightly above ground to avoid z-fighting\n\tvec3.set(shadowPos, mesh.position.x, y, mesh.position.z)\n\tvar sqdist = vec3.squaredDistance(camPos, shadowPos)\n\t// offset ~ 0.01 for nearby shadows, up to 0.1 at distance of ~40\n\tvar offset = 0.01 + 0.1 * (sqdist / 1600)\n\tif (offset > 0.1) offset = 0.1\n\tmesh.position.y = y + offset\n\t// set shadow scale\n\tvar dist = loc[1] - y\n\tvar scale = size * 0.7 * (1 - dist / shadowDist)\n\tmesh.scaling.copyFromFloats(scale, scale, scale)\n\tmesh.setEnabled(true)\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/shadow.js?");

/***/ }),

/***/ "../../src/components/smoothCamera.js":
/*!****************************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/components/smoothCamera.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (noa) {\n\treturn {\n\n\t\tname: 'smooth-camera',\n\n\t\tstate: {\n\t\t\ttime: 100.1\n\t\t},\n\n\t\tonAdd: null,\n\n\t\tonRemove: null,\n\n\t\tsystem: function (dt, states) {\n\t\t\t// remove self after time elapses\n\t\t\tstates.forEach(state => {\n\t\t\t\tstate.time -= dt\n\t\t\t\tif (state.time < 0) noa.ents.removeComponent(state.__id, 'smooth-camera')\n\t\t\t})\n\t\t},\n\n\n\n\t}\n}\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/components/smoothCamera.js?");

/***/ }),

/***/ "../../src/index.js":
/*!**********************************************!*\
  !*** /home/sasogu/web/EduCraft/src/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*!\n * noa: an experimental voxel game engine.\n * @url      github.com/andyhall/noa\n * @author   Andy Hall <andy@fenomas.com>\n * @license  MIT\n*/\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\nvar ndarray = __webpack_require__(/*! ndarray */ \"../../node_modules/ndarray/ndarray.js\")\nvar EventEmitter = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter\nvar createContainer = __webpack_require__(/*! ./lib/container */ \"../../src/lib/container.js\")\nvar createRendering = __webpack_require__(/*! ./lib/rendering */ \"../../src/lib/rendering.js\")\nvar createWorld = __webpack_require__(/*! ./lib/world */ \"../../src/lib/world.js\")\nvar createInputs = __webpack_require__(/*! ./lib/inputs */ \"../../src/lib/inputs.js\")\nvar createPhysics = __webpack_require__(/*! ./lib/physics */ \"../../src/lib/physics.js\")\nvar createCamControls = __webpack_require__(/*! ./lib/camera */ \"../../src/lib/camera.js\")\nvar createRegistry = __webpack_require__(/*! ./lib/registry */ \"../../src/lib/registry.js\")\nvar createEntities = __webpack_require__(/*! ./lib/entities */ \"../../src/lib/entities.js\")\nvar raycast = __webpack_require__(/*! fast-voxel-raycast */ \"../../node_modules/fast-voxel-raycast/index.js\")\n\n\nmodule.exports = Engine\n\n\n\n// profiling flag\nvar PROFILE = 0\nvar PROFILE_RENDER = 0\nvar DEBUG_QUEUES = 0\n\n\n\n\nvar defaults = {\n    debug: false,\n    silent: false,\n    playerHeight: 1.8,\n    playerWidth: 0.6,\n    playerStart: [0, 10, 0],\n    playerAutoStep: false,\n    tickRate: 33,  // ms per tick - not ticks per second\n    blockTestDistance: 10,\n    stickyPointerLock: true,\n    dragCameraOutsidePointerLock: true,\n    skipDefaultHighlighting: false,\n}\n\n/**\n * Main engine object.  \n * Emits: *tick, beforeRender, afterRender, targetBlockChanged*\n * \n * ```js\n * var noaEngine = require('noa-engine')\n * var noa = noaEngine(opts)\n * ```\n * \n * @class noa\n*/\n\nfunction Engine(opts) {\n    if (!(this instanceof Engine)) return new Engine(opts)\n\n    this.version = __webpack_require__(/*! ../package.json */ \"../../package.json\").version\n    if (!opts.silent) {\n        var debugstr = (opts.debug) ? ' (debug)' : ''\n        console.log(`noa-engine v${this.version}${debugstr}`)\n    }\n\n    opts = Object.assign({}, defaults, opts)\n    this._tickRate = opts.tickRate\n    this._paused = false\n    this._dragOutsideLock = opts.dragCameraOutsidePointerLock\n    var self = this\n\n    // container (html/div) manager\n    this.container = createContainer(this, opts)\n\n    // inputs manager - abstracts key/mouse input\n    this.inputs = createInputs(this, opts, this.container.element)\n\n    // create block/item property registry\n    this.registry = createRegistry(this, opts)\n\n    // create world manager\n    this.world = createWorld(this, opts)\n\n    // rendering manager - abstracts all draws to 3D context\n    this.rendering = createRendering(this, opts, this.container.canvas)\n\n    // Entity manager / Entity Component System (ECS)\n    this.entities = createEntities(this, opts)\n    // convenience\n    this.ents = this.entities\n\n    // physics engine - solves collisions, properties, etc.\n    this.physics = createPhysics(this, opts)\n\n    // camera controller\n    this.cameraControls = createCamControls(this, opts)\n\n\n    var ents = this.ents\n\n    /** Entity id for the player entity */\n    this.playerEntity = ents.add(\n        opts.playerStart,    // starting location- TODO: get from options\n        opts.playerWidth, opts.playerHeight,\n        null, null,          // no mesh for now, no meshOffset, \n        true, true\n    )\n\n    // make player entity it collide with terrain and other entities\n    ents.addComponent(this.playerEntity, ents.names.collideTerrain)\n    ents.addComponent(this.playerEntity, ents.names.collideEntities)\n\n    // adjust default physics parameters\n    var body = ents.getPhysicsBody(this.playerEntity)\n    body.gravityMultiplier = 2 // less floaty\n    body.autoStep = opts.playerAutoStep // auto step onto blocks\n\n    /** reference to player entity's physics body */\n    this.playerBody = body\n\n    // input component - sets entity's movement state from key inputs\n    ents.addComponent(this.playerEntity, ents.names.receivesInputs)\n\n    // add a component to make player mesh fade out when zooming in\n    ents.addComponent(this.playerEntity, ents.names.fadeOnZoom)\n\n    // movement component - applies movement forces\n    // todo: populate movement settings from options\n    var moveOpts = {\n        airJumps: 1\n    }\n    ents.addComponent(this.playerEntity, ents.names.movement, moveOpts)\n\n    // how high above the player's position the eye is (for picking, camera tracking)  \n    this.playerEyeOffset = 0.9 * opts.playerHeight\n\n\n\n\n    // set up block targeting\n    this.blockTestDistance = opts.blockTestDistance\n\n    /** function for which block IDs are targetable. \n     * Defaults to a solidity check, but can be overridden */\n    this.blockTargetIdCheck = this.registry.getBlockSolidity\n\n    /** Dynamically updated object describing the currently targeted block */\n    this.targetedBlock = null\n\n    // add a default block highlighting function\n    if (!opts.skipDefaultHighlighting) {\n        // the default listener, defined onto noa in case people want to remove it later\n        this.defaultBlockHighlightFunction = function (tgt) {\n            if (tgt) {\n                self.rendering.highlightBlockFace(true, tgt.position, tgt.normal)\n            } else {\n                self.rendering.highlightBlockFace(false)\n            }\n        }\n        this.on('targetBlockChanged', this.defaultBlockHighlightFunction)\n    }\n\n    // init rendering stuff that needed to wait for engine internals\n    this.rendering.initScene()\n\n    // expose constants, for HACKING\n    this._constants = __webpack_require__(/*! ./lib/constants */ \"../../src/lib/constants.js\")\n\n    // temp hacks for development\n    if (opts.debug) {\n        window.noa = this\n        window.scene = this.rendering._scene\n        window.ndarray = ndarray\n        window.vec3 = vec3\n        var debug = false\n        this.inputs.bind('debug', 'Z')\n        this.inputs.down.on('debug', function onDebug() {\n            debug = !debug\n            if (debug) window.scene.debugLayer.show(); else window.scene.debugLayer.hide();\n        })\n    }\n\n\n\n}\n\nEngine.prototype = Object.create(EventEmitter.prototype)\n\n\n/*\n *   Core Engine API\n*/\n\n\n\n\n/*\n * Tick function, called by container module at a fixed timestep. Emits #tick(dt),\n * where dt is the tick rate in ms (default 16.6)\n*/\n\nEngine.prototype.tick = function () {\n    if (this._paused) return\n    profile_hook('start')\n    var dt = this._tickRate       // fixed timesteps!\n    this.world.tick(dt)           // chunk creation/removal\n    profile_hook('world')\n    if (!this.world.playerChunkLoaded) {\n        // when waiting on worldgen, just tick the meshing queue and exit\n        this.rendering.tick(dt)\n        return\n    }\n    this.physics.tick(dt)         // iterates physics\n    profile_hook('physics')\n    this.rendering.tick(dt)       // zooms camera, does deferred chunk meshing\n    profile_hook('rendering')\n    updateBlockTargets(this)      // finds targeted blocks, and highlights one if needed\n    profile_hook('targets')\n    this.emit('tick', dt)\n    profile_hook('tick event')\n    profile_hook('end')\n    this.inputs.tick()            // clears accumulated tick/mouseMove data\n    if (DEBUG_QUEUES) debugQueues(this)\n}\n\n\nvar __qwasDone = true, __qstart\nfunction debugQueues(self) {\n    var a = self.world._chunkIDsToAdd.length\n    var b = self.world._chunkIDsToCreate.length\n    var c = self.rendering._chunksToMesh.length\n    var d = self.rendering._numMeshedChunks\n    if (a + b + c > 0) console.log([\n        'Chunks:', 'unmade', a,\n        'pending creation', b,\n        'to mesh', c,\n        'meshed', d,\n    ].join('   \\t'))\n    if (__qwasDone && a + b + c > 0) {\n        __qwasDone = false\n        __qstart = performance.now()\n    }\n    if (!__qwasDone && a + b + c === 0) {\n        __qwasDone = true\n        console.log('Queue empty after ' + Math.round(performance.now() - __qstart) + 'ms')\n    }\n}\n\n\n\n\n\n\n/*\n * Render function, called every animation frame. Emits #beforeRender(dt), #afterRender(dt) \n * where dt is the time in ms *since the last tick*.\n*/\n\nEngine.prototype.render = function (framePart) {\n    if (this._paused) return\n    profile_hook_render('start')\n    var dt = framePart * this._tickRate // ms since last tick\n    // only move camera during pointerlock or mousedown, or if pointerlock is unsupported\n    if (this.container.hasPointerLock ||\n        !this.container.supportsPointerLock ||\n        (this._dragOutsideLock && this.inputs.state.fire)) {\n        this.cameraControls.updateForRender()\n    }\n    // clear cumulative mouse inputs\n    this.inputs.state.dx = this.inputs.state.dy = 0\n    // events and render\n    this.emit('beforeRender', dt)\n    profile_hook_render('before render')\n    this.rendering.render(dt)\n    profile_hook_render('render')\n    this.emit('afterRender', dt)\n    profile_hook_render('after render')\n    profile_hook_render('end')\n}\n\n\n\n/*\n *   Utility APIs\n*/\n\n/** \n * Pausing the engine will also stop render/tick events, etc.\n * @param paused\n*/\nEngine.prototype.setPaused = function (paused) {\n    this._paused = !!paused\n    // when unpausing, clear any built-up mouse inputs\n    if (!paused) {\n        this.inputs.state.dx = this.inputs.state.dy = 0\n    }\n}\n\n/** @param x,y,z */\nEngine.prototype.getBlock = function (x, y, z) {\n    if (x.length) {\n        return this.world.getBlockID(x[0], x[1], x[2])\n    } else {\n        return this.world.getBlockID(x, y, z)\n    }\n}\n\n/** @param x,y,z */\nEngine.prototype.setBlock = function (id, x, y, z) {\n    // skips the entity collision check\n    if (x.length) {\n        return this.world.setBlockID(id, x[0], x[1], x[2])\n    } else {\n        return this.world.setBlockID(id, x, y, z)\n    }\n}\n\n/**\n * Adds a block unless obstructed by entities \n * @param id,x,y,z */\nEngine.prototype.addBlock = function (id, x, y, z) {\n    // add a new terrain block, if nothing blocks the terrain there\n    if (x.length) {\n        if (this.entities.isTerrainBlocked(x[0], x[1], x[2])) return\n        this.world.setBlockID(id, x[0], x[1], x[2])\n        return id\n    } else {\n        if (this.entities.isTerrainBlocked(x, y, z)) return\n        this.world.setBlockID(id, x, y, z)\n        return id\n    }\n}\n\n\n\n/** */\nEngine.prototype.getPlayerPosition = function () {\n    return this.entities.getPosition(this.playerEntity)\n}\n\n/** */\nEngine.prototype.getPlayerMesh = function () {\n    return this.entities.getMeshData(this.playerEntity).mesh\n}\n\n/** */\nEngine.prototype.setPlayerEyeOffset = function (y) {\n    this.playerEyeOffset = y\n    var state = this.ents.getState(this.rendering.cameraTarget, this.ents.names.followsEntity)\n    state.offset[1] = y\n}\n\n/** */\nEngine.prototype.getPlayerEyePosition = function () {\n    var pos = this.entities.getPosition(this.playerEntity)\n    vec3.copy(_eyeLoc, pos)\n    _eyeLoc[1] += this.playerEyeOffset\n    return _eyeLoc\n}\nvar _eyeLoc = vec3.create()\n\n/** */\nEngine.prototype.getCameraVector = function () {\n    // rendering works with babylon's xyz vectors\n    var v = this.rendering.getCameraVector()\n    vec3.set(_camVec, v.x, v.y, v.z)\n    return _camVec\n}\nvar _camVec = vec3.create()\n\n\n\n/**\n * Raycast through the world, returning a result object for any non-air block\n * @param pos\n * @param vec\n * @param dist\n */\nEngine.prototype.pick = function (pos, vec, dist, blockIdTestFunction) {\n    if (dist === 0) return null\n    // if no block ID function is specified default to solidity check\n    var testFn = blockIdTestFunction || this.registry.getBlockSolidity\n    var world = this.world\n    var testVoxel = function (x, y, z) {\n        var id = world.getBlockID(x, y, z)\n        return testFn(id)\n    }\n    pos = pos || this.getPlayerEyePosition()\n    vec = vec || this.getCameraVector()\n    dist = dist || this.blockTestDistance\n    var rpos = _hitResult.position\n    var rnorm = _hitResult.normal\n    var hit = raycast(testVoxel, pos, vec, dist, rpos, rnorm)\n    if (!hit) return null\n    // position is right on a voxel border - adjust it so flooring will work as expected\n    for (var i = 0; i < 3; i++) rpos[i] -= 0.01 * rnorm[i]\n    return _hitResult\n}\nvar _hitResult = {\n    position: vec3.create(),\n    normal: vec3.create(),\n}\n\n\n\n\n\n\n\n// Each frame, by default pick along the player's view vector \n// and tell rendering to highlight the struck block face\nfunction updateBlockTargets(noa) {\n    var newhash = ''\n    var blockIdFn = noa.blockTargetIdCheck || noa.registry.getBlockSolidity\n    var result = noa.pick(null, null, null, blockIdFn)\n    if (result) {\n        var dat = _targetedBlockDat\n        for (var i = 0; i < 3; i++) {\n            // position values are right on a border, so adjust them before flooring!\n            var n = result.normal[i] | 0\n            var p = Math.floor(result.position[i])\n            dat.position[i] = p\n            dat.normal[i] = n\n            dat.adjacent[i] = p + n\n            newhash += '|' + p + '|' + n\n        }\n        dat.blockID = noa.world.getBlockID(dat.position[0], dat.position[1], dat.position[2])\n        newhash += '|' + result.blockID\n        noa.targetedBlock = dat\n    } else {\n        noa.targetedBlock = null\n    }\n    if (newhash != _prevTargetHash) {\n        noa.emit('targetBlockChanged', noa.targetedBlock)\n        _prevTargetHash = newhash\n    }\n}\n\nvar _targetedBlockDat = {\n    blockID: 0,\n    position: [],\n    normal: [],\n    adjacent: [],\n}\n\nvar _prevTargetHash = ''\n\n\n\n\n\n\n\n\n\n\nvar profile_hook = function (s) { }\nvar profile_hook_render = function (s) { }\nif (PROFILE) (function () {\n    var timer = new (__webpack_require__(/*! ./lib/util */ \"../../src/lib/util.js\").Timer)(200, 'tick   ')\n    profile_hook = function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\nif (PROFILE_RENDER) (function () {\n    var timer = new (__webpack_require__(/*! ./lib/util */ \"../../src/lib/util.js\").Timer)(200, 'render ')\n    profile_hook_render = function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/index.js?");

/***/ }),

/***/ "../../src/lib/camera.js":
/*!***************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/camera.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (noa, opts) {\n\treturn new CameraController(noa, opts)\n}\n\n\n\n/*\n*    Controller for the camera\n*\n*/\n\n\nvar defaults = {\n\trotationScaleX: 0.0025,\n\trotationScaleY: 0.0025,\n\tinverseY: false,\n}\n\n\nfunction CameraController(noa, opts) {\n\tthis.noa = noa\n\n\t// options\n\topts = Object.assign({}, defaults, opts)\n\tthis.rotationScaleX = opts.rotationScaleX\n\tthis.rotationScaleY = opts.rotationScaleY\n\tthis.inverseY = opts.inverseY\n}\n\n\n\n\n\n/**\n * On render, move/rotate the camera based on target and mouse inputs\n */\n\nCameraController.prototype.updateForRender = function () {\n\t// input state\n\tvar state = this.noa.inputs.state\n\n\t// TODO: REMOVE EVENTUALLY\n\tbugFix(state)\n\n\t// Rotation: translate dx/dy inputs into y/x axis camera angle changes\n\tvar dx = this.rotationScaleY * state.dy * ((this.inverseY) ? -1 : 1)\n\tvar dy = this.rotationScaleX * state.dx\n\n\t// normalize/clamp/update\n\tvar camrot = this.noa.rendering.getCameraRotation() // [x,y]\n\tvar rotX = clamp(camrot[0] + dx, rotXcutoff)\n\tvar rotY = (camrot[1] + dy) % (Math.PI * 2)\n\tthis.noa.rendering.setCameraRotation(rotX, rotY)\n\n}\n\nvar rotXcutoff = (Math.PI / 2) - .0001 // engines can be weird when xRot == pi/2\n\nfunction clamp(value, to) {\n\treturn isFinite(to) ? Math.max(Math.min(value, to), -to) : value\n}\n\n\n\n// workaround for this Chrome 63 + Win10 bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=781182\nfunction bugFix(state) {\n\tvar dx = state.dx\n\tvar dy = state.dy\n\tvar wval = document.body.clientWidth / 6\n\tvar hval = document.body.clientHeight / 6\n\tvar badx = (Math.abs(dx) > wval && (dx / lastx) < -1)\n\tvar bady = (Math.abs(dy) > hval && (dy / lasty) < -1)\n\tif (badx || bady) {\n\t\tstate.dx = lastx\n\t\tstate.dy = lasty\n\t\tlastx = (dx > 0) ? 1 : -1\n\t\tlasty = (dy > 0) ? 1 : -1\n\t} else {\n\t\tif (dx) lastx = dx\n\t\tif (dy) lasty = dy\n\t}\n}\n\nvar lastx = 0\nvar lasty = 0\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/camera.js?");

/***/ }),

/***/ "../../src/lib/chunk.js":
/*!**************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/chunk.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"../../src/lib/constants.js\")\nvar ndarray = __webpack_require__(/*! ndarray */ \"../../node_modules/ndarray/ndarray.js\")\n\n\n\nmodule.exports = Chunk\n\n\n// shared references to terrain/object meshers\nvar terrainMesher = __webpack_require__(/*! ./terrainMesher */ \"../../src/lib/terrainMesher.js\")\nvar objectMesher = __webpack_require__(/*! ./objectMesher */ \"../../src/lib/objectMesher.js\")\n\n\n\n\n/* \n * \n *   Chunk\n * \n *  Stores and manages voxel ids and flags for each voxel within chunk\n *  See constants.js for internal data representation\n * \n*/\n\n\n\n// data representation\nvar ID_MASK = constants.ID_MASK\nvar VAR_MASK = constants.VAR_MASK\nvar SOLID_BIT = constants.SOLID_BIT\nvar OPAQUE_BIT = constants.OPAQUE_BIT\nvar OBJECT_BIT = constants.OBJECT_BIT\n\n\n\n\n/*\n *\n *    Chunk constructor\n *\n*/\n\nfunction Chunk(noa, id, i, j, k, size) {\n    this.id = id\n\n    this.noa = noa\n    this.isDisposed = false\n    this.isGenerated = false\n    this.inInvalid = false\n    this.octreeBlock = null\n    this._terrainMesh = null\n\n    this.isEmpty = false\n    this.isFull = false\n\n    // packed data storage\n    var s = size + 2 // 1 block of padding on each side\n    var arr = new Uint16Array(s * s * s)\n    this.array = new ndarray(arr, [s, s, s])\n    this.i = i\n    this.j = j\n    this.k = k\n    this.size = size\n    this.x = i * size\n    this.y = j * size\n    this.z = k * size\n\n    // flags to track if things need re-meshing\n    this._terrainDirty = false\n    this._objectsDirty = false\n\n    // init references shared among all chunks\n    setBlockLookups(noa)\n\n    // build unpadded and transposed array views for internal use\n    rebuildArrayViews(this)\n\n    // adds some properties to the chunk for handling object meshes\n    objectMesher.initChunk(this)\n\n}\n\n\n\n// Registry lookup references shared by all chunks\nvar solidLookup\nvar opaqueLookup\nvar objectMeshLookup\nvar blockHandlerLookup\n\nfunction setBlockLookups(noa) {\n    solidLookup = noa.registry._solidityLookup\n    opaqueLookup = noa.registry._opacityLookup\n    objectMeshLookup = noa.registry._blockMeshLookup\n    blockHandlerLookup = noa.registry._blockHandlerLookup\n}\n\n\n\n\n/*\n *\n *    Chunk API\n *\n*/\n\n// get/set deal with block IDs, so that this class acts like an ndarray\n\nChunk.prototype.get = function (x, y, z) {\n    return ID_MASK & this._unpaddedView.get(x, y, z)\n}\n\nChunk.prototype.getSolidityAt = function (x, y, z) {\n    return (SOLID_BIT & this._unpaddedView.get(x, y, z)) ? true : false\n}\n\nChunk.prototype.set = function (x, y, z, id) {\n    var oldID = this._unpaddedView.get(x, y, z)\n    var oldIDnum = oldID & ID_MASK\n    if (id === oldIDnum) return\n\n    // manage data\n    var newID = packID(id)\n    this._unpaddedView.set(x, y, z, newID)\n\n    // handle object meshes\n    if (oldID & OBJECT_BIT) removeObjectBlock(this, x, y, z)\n    if (newID & OBJECT_BIT) addObjectBlock(this, id, x, y, z)\n\n    // track full/emptyness\n    if (newID !== 0) this.isEmpty = false\n    if (!(newID & OPAQUE_BIT)) this.isFull = false\n\n    // call block handlers\n    callBlockHandler(this, oldIDnum, 'onUnset', x, y, z)\n    callBlockHandler(this, id, 'onSet', x, y, z)\n\n    // mark terrain dirty unless neither block was terrain\n    if (isTerrain(oldID) || isTerrain(newID)) this._terrainDirty = true\n}\n\n\n\n\n\n\n// helper to call handler of a given type at a particular xyz\n\nfunction callBlockHandler(chunk, blockID, type, x, y, z) {\n    var hobj = blockHandlerLookup[blockID]\n    if (!hobj) return\n    var handler = hobj[type]\n    if (!handler) return\n    // ignore all handlers if block is in chunk's edge padding blocks\n    var s = chunk.size\n    if (x < 0 || y < 0 || z < 0 || x >= s || y >= s || z >= s) return\n    handler(chunk.x + x, chunk.y + y, chunk.z + z)\n}\n\n\n\n// Convert chunk's voxel terrain into a babylon.js mesh\n// Used internally, but needs to be public so mesh-building hacks can call it\nChunk.prototype.mesh = function (matGetter, colGetter, useAO, aoVals, revAoVal) {\n    return terrainMesher.meshChunk(this, matGetter, colGetter, useAO, aoVals, revAoVal)\n}\n\n\n\n\n\n// gets called by World when this chunk has been queued for remeshing\nChunk.prototype.updateMeshes = function () {\n    if (this._terrainDirty) {\n        this.noa.rendering.removeTerrainMesh(this)\n        var mesh = this.mesh()\n        if (mesh) this.noa.rendering.addTerrainMesh(this, mesh)\n        this._terrainDirty = false\n    }\n    if (this._objectsDirty) {\n        objectMesher.buildObjectMesh(this)\n        this._objectsDirty = false\n    }\n}\n\n\n\n\n\n\n\n// helper to determine if a block counts as \"terrain\" (non-air, non-object)\nfunction isTerrain(id) {\n    if (id === 0) return false\n    // treat object blocks as terrain if solid (they affect AO)\n    if (id & OBJECT_BIT) return !!(id & SOLID_BIT)\n    return true\n}\n\n// helper to pack a block ID into the internally stored form, given lookup tables\nfunction packID(id) {\n    var newID = id\n    if (solidLookup[id]) newID |= SOLID_BIT\n    if (opaqueLookup[id]) newID |= OPAQUE_BIT\n    if (objectMeshLookup[id]) newID |= OBJECT_BIT\n    return newID\n}\n\n\n\n\n\n\n\n\n/*\n * \n *      Init\n * \n *  Gets called right after client filled the voxel ID data array\n*/\n\n\n\nChunk.prototype.initData = function () {\n    // remake other views, assuming that data has changed\n    rebuildArrayViews(this)\n    // flags for tracking if chunk is entirely opaque or transparent\n    var fullyOpaque = OPAQUE_BIT\n    var fullyAir = true\n\n    // init everything in one big scan\n    var arr = this.array\n    var data = arr.data\n    var len = arr.shape[0]\n    var kstride = arr.stride[2]\n    for (var i = 0; i < len; ++i) {\n        var edge1 = (i === 0 || i === len - 1)\n        for (var j = 0; j < len; ++j) {\n            var d0 = arr.index(i, j, 0)\n            var edge2 = edge1 || (j === 0 || j === len - 1)\n            for (var k = 0; k < len; ++k, d0 += kstride) {\n                // pull raw ID - could in principle be packed, so mask it\n                var id = data[d0] & ID_MASK\n                // skip air blocks\n                if (id === 0) {\n                    fullyOpaque = 0\n                    continue\n                }\n                // store ID as packed internal representation\n                var packed = packID(id) | 0\n                data[d0] = packed\n                // track whether chunk is entirely full or empty\n                fullyOpaque &= packed\n                fullyAir = false\n                // within unpadded view, handle object blocks and handlers\n                var atEdge = edge2 || (k === 0 || k === len - 1)\n                if (!atEdge) {\n                    if (OBJECT_BIT & packed) {\n                        addObjectBlock(this, id, i - 1, j - 1, k - 1)\n                    }\n                    callBlockHandler(this, id, 'onLoad', i - 1, j - 1, k - 1)\n                }\n            }\n        }\n    }\n\n    this.isFull = !!(fullyOpaque & OPAQUE_BIT)\n    this.isEmpty = !!(fullyAir)\n    this._terrainDirty = !(this.isFull || this.isEmpty)\n\n    this.isGenerated = true\n}\n\n\n// helper to rebuild several transformed views on the data array\n\nfunction rebuildArrayViews(chunk) {\n    var arr = chunk.array\n    var size = chunk.size\n    chunk._unpaddedView = arr.lo(1, 1, 1).hi(size, size, size)\n}\n\n\n\n// accessors related to meshing\n\nfunction addObjectBlock(chunk, id, x, y, z) {\n    objectMesher.addObjectBlock(chunk, id, x, y, z)\n    chunk._objectsDirty = true\n}\n\nfunction removeObjectBlock(chunk, x, y, z) {\n    objectMesher.removeObjectBlock(chunk, x, y, z)\n    chunk._objectsDirty = true\n}\n\n\n\n\n\n// dispose function - just clears properties and references\n\nChunk.prototype.dispose = function () {\n    // look through the data for onUnload handlers\n    callAllBlockHandlers(this, 'onUnload')\n\n    // let meshers dispose their stuff\n    objectMesher.disposeChunk(this)\n\n    // apparently there's no way to dispose typed arrays, so just null everything\n    this.array.data = null\n    this.array = null\n    this._unpaddedView = null\n\n    this.isGenerated = false\n    this.isDisposed = true\n}\n\n\n// helper to call a given handler for all blocks in the chunk\n\nfunction callAllBlockHandlers(chunk, type) {\n    var view = chunk._unpaddedView\n    var data = view.data\n    var si = view.stride[0]\n    var sj = view.stride[1]\n    var sk = view.stride[2]\n    var size = view.shape[0]\n    var d0 = view.offset\n    for (var i = 0; i < size; ++i) {\n        for (var j = 0; j < size; ++j) {\n            for (var k = 0; k < size; ++k) {\n                var id = ID_MASK & data[d0]\n                callBlockHandler(chunk, id, type, i, j, k)\n                d0 += sk\n            }\n            d0 -= sk * size\n            d0 += sj\n        }\n        d0 -= sj * size\n        d0 += si\n    }\n}\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/chunk.js?");

/***/ }),

/***/ "../../src/lib/constants.js":
/*!******************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/constants.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = {}\nmodule.exports = constants\n\n\n/* \n *  Internal voxel data representation\n *\n *  Each voxel is stored as a Uint16.\n *  Voxel id is stored in lowest bits, and flags stored in upper bits for fast retrieval\n *  \n *  Stores, from right to left:\n *     9 bits of voxel ID\n *     4 bits of variation (e.g. orientation)  --- Not yet being used!\n *     1 bit solidity (i.e. physics-wise)\n *     1 bit opacity (whether voxel obscures neighboring faces)\n *     1 bit object marker (marks non-terrain blocks with custom meshes)\n*/\n\n\nvar ID_BITS = 9\nvar ID_MASK = (1 << ID_BITS) - 1\n\nvar VAR_BITS = 4\nvar VAR_OFFSET = ID_BITS\nvar VAR_MASK = ((1 << VAR_BITS) - 1) << VAR_OFFSET\n\nvar n = ID_BITS + VAR_BITS\nvar SOLID_BIT = 1 << n++\nvar OPAQUE_BIT = 1 << n++\nvar OBJECT_BIT = 1 << n++\n\n// exports\n\nconstants.ID_MASK = ID_MASK\nconstants.VAR_MASK = VAR_MASK\nconstants.SOLID_BIT =  SOLID_BIT\nconstants.OPAQUE_BIT = OPAQUE_BIT\nconstants.OBJECT_BIT = OBJECT_BIT\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/constants.js?");

/***/ }),

/***/ "../../src/lib/container.js":
/*!******************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/container.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createGameShell = __webpack_require__(/*! game-shell */ \"../../node_modules/game-shell/shell.js\")\n// var createGameShell = require('../../../../npm-modules/game-shell')\nvar EventEmitter = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter\n\n\nmodule.exports = function (noa, opts) {\n\treturn new Container(noa, opts)\n}\n\n/*\n*  Container module\n*    Wraps game-shell module and manages HTML container, canvas, etc.\n*    Emits: DOMready\n*/\n\nfunction Container(noa, opts) {\n\topts = opts || {}\n\tthis._noa = noa\n\tthis.element = opts.domElement || createContainerDiv()\n\tthis.canvas = getOrCreateCanvas(this.element)\n\tthis._shell = createShell(this.canvas, opts)\n\n\t// mouse state/feature detection\n\tthis.hasPointerLock = false\n\tthis.supportsPointerLock = false\n\tthis.pointerInGame = false\n\tthis.isFocused = document.hasFocus()\n\n\t// basic listeners\n\tvar self = this\n\tvar lockChange = function (ev) { onLockChange(self, ev) }\n\tdocument.addEventListener(\"pointerlockchange\", lockChange, false)\n\tdocument.addEventListener(\"mozpointerlockchange\", lockChange, false)\n\tdocument.addEventListener(\"webkitpointerlockchange\", lockChange, false)\n\tdetectPointerLock(self)\n\n\tself.element.addEventListener('mouseenter', function () { self.pointerInGame = true })\n\tself.element.addEventListener('mouseleave', function () { self.pointerInGame = false })\n\n\twindow.addEventListener('focus', function () { self.isFocused = true })\n\twindow.addEventListener('blur', function () { self.isFocused = false })\n\n\t// get shell events after it's initialized\n\tthis._shell.on('init', onShellInit.bind(null, this))\n}\n\nContainer.prototype = Object.create(EventEmitter.prototype)\n\n\n\n/*\n*   SHELL EVENTS\n*/\n\nfunction onShellInit(self) {\n\t// create shell listeners that drive engine functions\n\tvar noa = self._noa\n\tvar shell = self._shell\n\tshell.on('tick', function onTick(n) { noa.tick(n) })\n\tshell.on('render', function onRender(n) { noa.render(n) })\n\tshell.on('resize', noa.rendering.resize.bind(noa.rendering))\n\n\t// let other components know DOM is ready\n\tself.emit('DOMready')\n}\n\n\n\n/*\n*   PUBLIC API \n*/\n\nContainer.prototype.appendTo = function (htmlElement) {\n\tthis.element.appendChild(htmlElement)\n}\n\n\n\nContainer.prototype.setPointerLock = function (lock) {\n\t// not sure if this will work robustly\n\tthis._shell.pointerLock = !!lock\n}\n\n\n\n\n\n/*\n*   INTERNALS\n*/\n\n\n\nfunction createContainerDiv() {\n\t// based on github.com/mikolalysenko/game-shell - makeDefaultContainer()\n\tvar container = document.createElement(\"div\")\n\tcontainer.tabindex = 1\n\tcontainer.style.position = \"absolute\"\n\tcontainer.style.left = \"0px\"\n\tcontainer.style.right = \"0px\"\n\tcontainer.style.top = \"0px\"\n\tcontainer.style.bottom = \"0px\"\n\tcontainer.style.height = \"100%\"\n\tcontainer.style.overflow = \"hidden\"\n\tdocument.body.appendChild(container)\n\tdocument.body.style.overflow = \"hidden\" //Prevent bounce\n\tdocument.body.style.height = \"100%\"\n\tcontainer.id = 'noa-container'\n\treturn container\n}\n\n\nfunction createShell(canvas, opts) {\n\tvar shellDefaults = {\n\t\tpointerLock: true,\n\t\tpreventDefaults: false\n\t}\n\topts = Object.assign(shellDefaults, opts)\n\topts.element = canvas\n\tvar shell = createGameShell(opts)\n\tshell.preventDefaults = opts.preventDefaults\n\treturn shell\n}\n\nfunction getOrCreateCanvas(el) {\n\t// based on github.com/stackgl/gl-now - default canvas\n\tvar canvas = el.querySelector('canvas')\n\tif (!canvas) {\n\t\tcanvas = document.createElement('canvas')\n\t\tcanvas.style.position = \"absolute\"\n\t\tcanvas.style.left = \"0px\"\n\t\tcanvas.style.top = \"0px\"\n\t\tcanvas.style.height = \"100%\"\n\t\tcanvas.style.width = \"100%\"\n\t\tcanvas.id = 'noa-canvas'\n\t\tel.insertBefore(canvas, el.firstChild);\n\t}\n\treturn canvas\n}\n\n\n// track changes in Pointer Lock state\nfunction onLockChange(self, ev) {\n\tvar el = document.pointerLockElement ||\n\t\tdocument.mozPointerLockElement ||\n\t\tdocument.webkitPointerLockElement\n\tif (el) {\n\t\tself.hasPointerLock = true\n\t\tself.emit('gainedPointerLock')\n\t} else {\n\t\tself.hasPointerLock = false\n\t\tself.emit('lostPointerLock')\n\t}\n\t// this works around a Firefox bug where no mouse-in event \n\t// gets issued after starting pointerlock\n\tif (el) {\n\t\t// act as if pointer is in game window while pointerLock is true\n\t\tself.pointerInGame = true\n\t}\n}\n\n\n// set up stuff to detect pointer lock support.\n// Needlessly complex because Chrome/Android claims to support but doesn't.\n// For now, just feature detect, but assume no support if a touch event occurs\n// TODO: see if this makes sense on hybrid touch/mouse devices\nfunction detectPointerLock(self) {\n\tvar lockElementExists =\n\t\t('pointerLockElement' in document) ||\n\t\t('mozPointerLockElement' in document) ||\n\t\t('webkitPointerLockElement' in document)\n\tif (lockElementExists) {\n\t\tself.supportsPointerLock = true\n\t\tvar listener = function (e) {\n\t\t\tself.supportsPointerLock = false\n\t\t\tdocument.removeEventListener(e.type, listener)\n\t\t}\n\t\tdocument.addEventListener('touchmove', listener)\n\t}\n}\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/container.js?");

/***/ }),

/***/ "../../src/lib/entities.js":
/*!*****************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/entities.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"../../node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\nvar EntComp = __webpack_require__(/*! ent-comp */ \"../../node_modules/ent-comp/src/ECS.js\")\n// var EntComp = require('../../../../npm-modules/ent-comp')\n\nmodule.exports = function (noa, opts) {\n\treturn new Entities(noa, opts)\n}\n\nvar defaults = {\n\tshadowDistance: 10,\n}\n\n\n\n/**\n * Wrangles entities. \n * This class is an instance of [ECS](https://github.com/andyhall/ent-comp), \n * and as such implements the usual ECS methods.\n * It's also decorated with helpers and accessor functions for getting component existence/state.\n * \n * Expects entity definitions in a specific format - see source `components` folder for examples.\n * \n * @class noa.entities\n*/\n\nfunction Entities(noa, opts) {\n\t// inherit from the ECS library\n\tEntComp.call(this)\n\n\tthis.noa = noa\n\topts = Object.assign({}, defaults, opts)\n\n\t// properties\n\t/**\n\t * Hash containing the component names of built-in components.\n\t * @name names\n\t */\n\tthis.names = {}\n\n\t// options\n\tvar shadowDist = opts.shadowDistance\n\n\t// register components with the ECS\n\tthis.names.position = this.createComponent(__webpack_require__(/*! ../components/position */ \"../../src/components/position.js\")(noa))\n\tthis.names.physics = this.createComponent(__webpack_require__(/*! ../components/physics */ \"../../src/components/physics.js\")(noa))\n\tthis.names.followsEntity = this.createComponent(__webpack_require__(/*! ../components/followsEntity */ \"../../src/components/followsEntity.js\")(noa))\n\tthis.names.mesh = this.createComponent(__webpack_require__(/*! ../components/mesh */ \"../../src/components/mesh.js\")(noa))\n\tthis.names.shadow = this.createComponent(__webpack_require__(/*! ../components/shadow */ \"../../src/components/shadow.js\")(noa, shadowDist))\n\tthis.names.collideTerrain = this.createComponent(__webpack_require__(/*! ../components/collideTerrain */ \"../../src/components/collideTerrain.js\")(noa))\n\tthis.names.collideEntities = this.createComponent(__webpack_require__(/*! ../components/collideEntities */ \"../../src/components/collideEntities.js\")(noa))\n\tthis.names.smoothCamera = this.createComponent(__webpack_require__(/*! ../components/smoothCamera */ \"../../src/components/smoothCamera.js\")(noa))\n\tthis.names.movement = this.createComponent(__webpack_require__(/*! ../components/movement */ \"../../src/components/movement.js\")(noa))\n\tthis.names.receivesInputs = this.createComponent(__webpack_require__(/*! ../components/receivesInputs */ \"../../src/components/receivesInputs.js\")(noa))\n\tthis.names.fadeOnZoom = this.createComponent(__webpack_require__(/*! ../components/fadeOnZoom */ \"../../src/components/fadeOnZoom.js\")(noa))\n\n\t// decorate the entities object with accessor functions\n\tthis.isPlayer = function (id) { return id === noa.playerEntity }\n\tthis.hasPhysics = this.getComponentAccessor(this.names.physics)\n\tthis.cameraSmoothed = this.getComponentAccessor(this.names.smoothCamera)\n\tthis.hasMesh = this.getComponentAccessor(this.names.mesh)\n\n\t// position functions\n\tthis.hasPosition = this.getComponentAccessor(this.names.position)\n\tvar getPos = this.getStateAccessor(this.names.position)\n\tthis.getPositionData = getPos\n\tthis.getPosition = function (id) { return getPos(id).position }\n\tthis.setPosition = function (id, x, y, z) {\n\t\tvar pdat = this.getPositionData(id)\n\t\tvec3.set(pdat.position, x, y, z)\n\t\tvec3.set(pdat.renderPosition, x, y, z)\n\t\tpdat._extentsChanged = true\n\t\tif (this.hasPhysics(id)) {\n\t\t\tsetAABBFromPosition(this.getPhysicsBody(id).aabb, pdat)\n\t\t}\n\t}\n\n\t// physics\n\tvar getPhys = this.getStateAccessor(this.names.physics)\n\tthis.getPhysicsBody = function (id) { return getPhys(id).body }\n\n\t// misc\n\tthis.getMeshData = this.getStateAccessor(this.names.mesh)\n\tthis.getMovement = this.getStateAccessor(this.names.movement)\n\tthis.getCollideTerrain = this.getStateAccessor(this.names.collideTerrain)\n\tthis.getCollideEntities = this.getStateAccessor(this.names.collideEntities)\n\n\t// pairwise collideEntities event - this is for client to override\n\tthis.onPairwiseEntityCollision = function (id1, id2) { }\n\n\t// events\n\tvar self = this\n\tnoa.on('tick', function (dt) { self.tick(dt) })\n\tnoa.on('beforeRender', function (dt) { self.render(dt) })\n\n}\n\n// inherit from EntComp\nEntities.prototype = Object.create(EntComp.prototype)\nEntities.prototype.constructor = Entities\n\n\n\n\n/*\n *\n *    ENTITY MANAGER API\n *\n*/\n\n\n/** @param id,name,state */\nEntities.prototype.addComponentAgain = function (id, name, state) {\n\t// removes component first if necessary\n\tif (this.hasComponent(id, name)) this.removeComponent(id, name, true)\n\tthis.addComponent(id, name, state)\n}\n\n\n/** @param x,y,z */\nEntities.prototype.isTerrainBlocked = function (x, y, z) {\n\t// checks if terrain location is blocked by entities\n\tvar box = _blockAABB\n\tvar eps = 0.001\n\tbox.setPosition([x + eps, y + eps, z + eps])\n\tvar hits = this.getEntitiesInAABB(box, this.names.collideTerrain)\n\treturn (hits.length > 0)\n}\nvar _blockAABB = new aabb([0, 0, 0], [0.998, 0.998, 0.998])\n\n\n/** @param x,y,z */\nEntities.prototype.setEntitySize = function (id, xs, ys, zs) {\n\t// adding this so client doesn't need to understand the internals\n\tif (!this.hasPosition(id)) throw 'Set size of entity without a position component'\n\tvar pdat = this.getPositionData(id)\n\tpdat.width = (xs + zs) / 2\n\tpdat.height = ys\n\tpdat._extentsChanged = true\n\tif (this.hasPhysics(id)) {\n\t\tvar box = this.getPhysicsBody(id).aabb\n\t\tsetAABBFromPosition(box, pdat)\n\t}\n}\n\n\nfunction setAABBFromPosition(box, posData) {\n\tvar w = posData.width\n\tvar pos = posData.position\n\tvar hw = w / 2\n\tvec3.set(box.base, pos[0] - hw, pos[1], pos[2] - hw)\n\tvec3.set(box.vec, w, posData.height, w)\n\tvec3.add(box.max, box.base, box.vec)\n}\n\n\n/** @param box */\nEntities.prototype.getEntitiesInAABB = function (box, withComponent) {\n\t// TODO - use bipartite box-intersect?\n\tvar hits = []\n\tvar self = this\n\tvar posArr = (withComponent) ?\n\t\tself.getStatesList(withComponent).map(function (state) {\n\t\t\treturn self.getPositionData(state.__id)\n\t\t}) :\n\t\tposArr = self.getStatesList(this.names.position)\n\tvar tmpBox = _searchBox\n\tfor (var i = 0; i < posArr.length; i++) {\n\t\tsetAABBFromPosition(tmpBox, posArr[i])\n\t\tif (box.intersects(tmpBox)) hits.push(posArr[i].__id)\n\t}\n\treturn hits\n}\nvar _searchBox = new aabb([], [])\n\n\n\n/** \n * Helper to set up a general entity, and populate with some common components depending on arguments.\n * \n * Parameters: position, width, height [, mesh, meshOffset, doPhysics, shadow]\n * \n * @param position\n * @param width\n * @param height..\n */\nEntities.prototype.add = function (position, width, height, // required\n\tmesh, meshOffset, doPhysics, shadow) {\n\n\tvar self = this\n\n\t// new entity\n\tvar eid = this.createEntity()\n\n\t// position component - force position vector to be a vec3\n\tvar pos = vec3.create()\n\tvec3.copy(pos, position)\n\tthis.addComponent(eid, this.names.position, {\n\t\tposition: pos,\n\t\twidth: width,\n\t\theight: height\n\t})\n\n\t// rigid body in physics simulator\n\tif (doPhysics) {\n\t\t// body = this.noa.physics.addBody(box)\n\t\tthis.addComponent(eid, this.names.physics)\n\t\tvar body = this.getPhysicsBody(eid)\n\n\t\t// handler for physics engine to call on auto-step\n\t\tvar smoothName = this.names.smoothCamera\n\t\tbody.onStep = function () {\n\t\t\tself.addComponentAgain(eid, smoothName)\n\t\t}\n\t}\n\n\t// mesh for the entity\n\tif (mesh) {\n\t\tif (!meshOffset) meshOffset = vec3.create()\n\t\tthis.addComponent(eid, this.names.mesh, {\n\t\t\tmesh: mesh,\n\t\t\toffset: meshOffset\n\t\t})\n\t}\n\n\t// add shadow-drawing component\n\tif (shadow) {\n\t\tthis.addComponent(eid, this.names.shadow, { size: width })\n\t}\n\n\treturn eid\n}\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/entities.js?");

/***/ }),

/***/ "../../src/lib/inputs.js":
/*!***************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/inputs.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createInputs = __webpack_require__(/*! game-inputs */ \"../../node_modules/game-inputs/inputs.js\")\n\n\nmodule.exports = function (noa, opts, element) {\n    return makeInputs(noa, opts, element)\n}\n\n\nvar defaultBindings = {\n    bindings: {\n        \"forward\": [\"W\", \"<up>\"],\n        \"left\": [\"A\", \"<left>\"],\n        \"backward\": [\"S\", \"<down>\"],\n        \"right\": [\"D\", \"<right>\"],\n        \"fire\": \"<mouse 1>\",\n        \"mid-fire\": [\"<mouse 2>\", \"Q\"],\n        \"alt-fire\": [\"<mouse 3>\", \"E\"],\n        \"jump\": \"<space>\",\n        \"sprint\": \"<shift>\",\n        \"crouch\": \"<control>\"\n    }\n}\n\n\nfunction makeInputs(noa, opts, element) {\n    opts = Object.assign({}, defaultBindings, opts)\n    var inputs = createInputs(element, opts)\n    var b = opts.bindings\n    for (var name in b) {\n        var arr = (Array.isArray(b[name])) ? b[name] : [b[name]]\n        arr.unshift(name)\n        inputs.bind.apply(inputs, arr)\n    }\n    return inputs\n}\n\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/inputs.js?");

/***/ }),

/***/ "../../src/lib/objectMesher.js":
/*!*********************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/objectMesher.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar removeUnorderedListItem = __webpack_require__(/*! ./util */ \"../../src/lib/util.js\").removeUnorderedListItem\n\n\nmodule.exports = new ObjectMesher()\n\n\n// enable for profiling..\nvar PROFILE = 0\n\n\n\n\n// helper class to hold data about a single object mesh\nfunction ObjMeshDat(id, x, y, z) {\n    this.id = id | 0\n    this.x = x | 0\n    this.y = y | 0\n    this.z = z | 0\n}\n\n\n\n\n\n\n\n/*\n * \n * \n *          Object meshing\n *  Per-chunk handling of the creation/disposal of voxels with static meshes\n * \n * \n*/\n\n\nfunction ObjectMesher() {\n\n\n    // adds properties to the new chunk that will be used when processing\n    this.initChunk = function (chunk) {\n        chunk._objectBlocks = {}\n        chunk._mergedObjectSystems = []\n    }\n\n    this.disposeChunk = function (chunk) {\n        removeCurrentSystems(chunk)\n        chunk._objectBlocks = null\n    }\n\n    function removeCurrentSystems(chunk) {\n        var systems = chunk._mergedObjectSystems\n        while (systems.length) {\n            var sps = systems.pop()\n            if (sps.mesh && chunk.octreeBlock && chunk.octreeBlock.entries) {\n                removeUnorderedListItem(chunk.octreeBlock.entries, sps.mesh)\n            }\n            if (sps.mesh) sps.mesh.dispose()\n            sps.dispose()\n        }\n    }\n\n\n\n    // accessors for the chunk to regester as object voxels are set/unset\n    this.addObjectBlock = function (chunk, id, x, y, z) {\n        var key = x + '|' + y + '|' + z\n        chunk._objectBlocks[key] = new ObjMeshDat(id, x, y, z, null)\n    }\n\n    this.removeObjectBlock = function (chunk, x, y, z) {\n        var key = x + '|' + y + '|' + z\n        if (chunk._objectBlocks[key]) delete chunk._objectBlocks[key]\n    }\n\n\n\n\n    /*\n     * \n     *    main implementation - re-creates all needed object mesh instances\n     * \n    */\n\n    this.buildObjectMesh = function (chunk) {\n        profile_hook('start')\n        // remove the current (if any) sps/mesh\n        removeCurrentSystems(chunk)\n\n        var scene = chunk.noa.rendering.getScene()\n        var objectMeshLookup = chunk.noa.registry._blockMeshLookup\n\n        // preprocess everything to build lists of object block keys\n        // hashed by material ID and then by block ID\n        var matIndexes = {}\n        for (var key in chunk._objectBlocks) {\n            var blockDat = chunk._objectBlocks[key]\n            var blockID = blockDat.id\n            var mat = objectMeshLookup[blockID].material\n            var matIndex = (mat) ? scene.materials.indexOf(mat) : -1\n            if (!matIndexes[matIndex]) matIndexes[matIndex] = {}\n            if (!matIndexes[matIndex][blockID]) matIndexes[matIndex][blockID] = []\n            matIndexes[matIndex][blockID].push(key)\n        }\n        profile_hook('preprocess')\n\n        // data structure now looks like:\n        // matIndexes = {\n        //      2: {                    // i.e. 2nd material in scene\n        //          14: {               // i.e. voxel ID 14 from registry\n        //              [ '2|3|4' ]     // key of block's local coords\n        //          }\n        //      }\n        // }\n\n        var x0 = chunk.i * chunk.size\n        var y0 = chunk.j * chunk.size\n        var z0 = chunk.k * chunk.size\n\n        // build one SPS for each material\n        for (var ix in matIndexes) {\n\n            var meshHash = matIndexes[ix]\n            var sps = buildSPSforMaterialIndex(chunk, scene, meshHash, x0, y0, z0)\n            profile_hook('made SPS')\n\n            // build SPS into the scene\n            var merged = sps.buildMesh()\n            profile_hook('built mesh')\n\n            // finish up\n            merged.material = (ix > -1) ? scene.materials[ix] : null\n            merged.position.x = x0\n            merged.position.y = y0\n            merged.position.z = z0\n            merged.freezeWorldMatrix()\n            merged.freezeNormals()\n\n            chunk.octreeBlock.entries.push(merged)\n            chunk._mergedObjectSystems.push(sps)\n        }\n\n        profile_hook('end')\n    }\n\n\n\n\n    function buildSPSforMaterialIndex(chunk, scene, meshHash, x0, y0, z0) {\n        var blockHash = chunk._objectBlocks\n        // base sps\n        var sps = new BABYLON.SolidParticleSystem('object_sps_' + chunk.id, scene, {\n            updatable: false,\n        })\n\n        var blockHandlerLookup = chunk.noa.registry._blockHandlerLookup\n        var objectMeshLookup = chunk.noa.registry._blockMeshLookup\n\n        // run through mesh hash adding shapes and position functions\n        for (var blockID in meshHash) {\n            var mesh = objectMeshLookup[blockID]\n            var blockArr = meshHash[blockID]\n            var count = blockArr.length\n\n            var handlerFn\n            var handlers = blockHandlerLookup[blockID]\n            if (handlers) handlerFn = handlers.onCustomMeshCreate\n            // jshint -W083\n            var setShape = function (particle, partIndex, shapeIndex) {\n                var key = blockArr[shapeIndex]\n                var dat = blockHash[key]\n                // set global positions for the custom handler, if any\n                particle.position.set(x0 + dat.x + 0.5, y0 + dat.y, z0 + dat.z + 0.5)\n                if (handlerFn) handlerFn(particle, x0 + dat.x, y0 + dat.y, z0 + dat.z)\n                // revert to local positions\n                particle.position.x -= x0\n                particle.position.y -= y0\n                particle.position.z -= z0\n            }\n            sps.addShape(mesh, count, { positionFunction: setShape })\n            blockArr.length = 0\n        }\n\n        return sps\n    }\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\nvar profile_hook = (function () {\n    if (!PROFILE) return function () { }\n    var every = 50\n    var timer = new (__webpack_require__(/*! ./util */ \"../../src/lib/util.js\").Timer)(every, 'Object meshing')\n    return function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/objectMesher.js?");

/***/ }),

/***/ "../../src/lib/physics.js":
/*!****************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/physics.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createPhysics = __webpack_require__(/*! voxel-physics-engine */ \"../../node_modules/voxel-physics-engine/src/index.js\")\n// var createPhysics = require('../../../../npm-modules/voxel-physics-engine')\n\n\nmodule.exports = function (noa, opts) {\n\treturn makePhysics(noa, opts)\n}\n\n\n/*\n *\n *    Simple wrapper module for the physics library\n *\n*/\n\n\nvar defaults = {\n\tgravity: [0, -10, 0],\n\tairDrag: 0.1,\n}\n\n\nfunction makePhysics(noa, opts) {\n\topts = Object.assign({}, defaults, opts)\n\tvar world = noa.world\n\tvar blockGetter = function (x, y, z) { return world.getBlockSolidity(x, y, z) }\n\tvar isFluidGetter = function (x, y, z) { return world.getBlockFluidity(x, y, z) }\n\n\tvar physics = createPhysics(opts, blockGetter, isFluidGetter)\n\n\treturn physics\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/physics.js?");

/***/ }),

/***/ "../../src/lib/registry.js":
/*!*****************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/registry.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (noa, opts) {\n    return new Registry(noa, opts)\n}\n\n\n/**\n * This is where clients register block types and their materials & properties.\n * @class noa.registry\n */\n\n\n/*\n *  data structs in the registry:\n *  registry \n *      blockSolidity:     id -> boolean\n *      blockOpacity:      id -> boolean\n *      blockIsFluid:      id -> boolean\n *      blockMats:         id -> 6x matID  [-x, +x, -y, +y, -z, +z]\n *      blockProps         id -> obj of less-often accessed properties\n *      blockMeshes:       id -> obj/null (custom mesh to instantiate)\n *      blockHandlers      id -> instance of `BlockCallbackHolder` or null \n *      matIDs             matName -> matID (int)\n *      matData            matID -> { color, alpha, texture, textureAlpha }\n*/\n\n\nvar defaults = {\n    texturePath: ''\n}\n\nvar blockDefaults = {\n    solid: true,\n    opaque: true,\n    fluidDensity: 1.0,\n    viscosity: 0.5,\n}\n\nvar MAX_BLOCK_IDS = 255 // currently stored in chunks as int8\n\n\nfunction Registry(noa, opts) {\n    this.noa = noa\n    opts = Object.assign({}, defaults, opts)\n\n\n    /* \n     * \n     *      data structures\n     * \n    */\n\n    // lookup arrays for block props and flags - all keyed by blockID\n    // fill in first value for id=0, empty space\n    var blockSolidity = [false]\n    var blockOpacity = [false]\n    var blockIsFluid = [false]\n    var blockMats = [0, 0, 0, 0, 0, 0]\n    var blockProps = [null]\n    var blockMeshes = [null]\n    var blockHandlers = [null]\n\n    // material data structs\n    var matIDs = {}             // mat name -> id\n    var matData = [null]        // mat id -> { color, alpha, texture, textureAlpha }\n\n    // option data to save\n    var texturePath = opts.texturePath\n\n\n\n    /* \n     * \n     *      Block registration methods\n     * \n    */\n\n\n\n    /**\n     * Register (by integer ID) a block type and its parameters.\n     * \n     *  @param id: integer, currently 1..255. This needs to be passed in by the \n     *    client because it goes into the chunk data, which someday will get serialized.\n     * \n     *  @param options: Recognized fields for the options object:\n     * \n     *  * material: can be:\n     *      * one (String) material name\n     *      * array of 2 names: [top/bottom, sides]\n     *      * array of 3 names: [top, bottom, sides]\n     *      * array of 6 names: [-x, +x, -y, +y, -z, +z]\n     *    If not specified, terrain won't be meshed for the block type\n     *  * solid: (true) solidity for physics purposes\n     *  * opaque: (true) fully obscures neighboring blocks\n     *  * fluid: (false) whether nonsolid block is a fluid (buoyant, viscous..)\n     *  * blockMeshes: (null) if specified, noa will create an instance of the mesh instead of rendering voxel terrain\n     *  * fluidDensity: (1.0) for fluid blocks\n     *  * viscosity: (0.5) for fluid blocks\n     *  * onLoad(): block event handler\n     *  * onUnload(): block event handler\n     *  * onSet(): block event handler\n     *  * onUnset(): block event handler\n     *  * onCustomMeshCreate(): block event handler\n    */\n\n\n    this.registerBlock = function (id, _options) {\n        _options = _options || {}\n        blockDefaults.solid = !_options.fluid\n        blockDefaults.opaque = !_options.fluid\n        var opts = Object.assign({}, blockDefaults, _options)\n\n        // console.log('register block: ', id, opts)\n        if (id < 1 || id > MAX_BLOCK_IDS) throw 'Block id exceeds max: ' + id\n\n        // if block ID is greater than current highest ID, \n        // register fake blocks to avoid holes in lookup arrays\n        while (id > blockSolidity.length) {\n            this.registerBlock(blockSolidity.length, {})\n        }\n\n        // flags default to solid, opaque, nonfluid\n        blockSolidity[id] = !!opts.solid\n        blockOpacity[id] = !!opts.opaque\n        blockIsFluid[id] = !!opts.fluid\n\n        // store any custom mesh, and if one is present assume no material\n        blockMeshes[id] = opts.blockMesh || null\n        if (blockMeshes[id]) opts.material = null\n\n        // parse out material parameter\n        // always store 6 material IDs per blockID, so material lookup is monomorphic\n        var mat = opts.material || null\n        var mats\n        if (!mat) {\n            mats = [null, null, null, null, null, null]\n        } else if (typeof mat == 'string') {\n            mats = [mat, mat, mat, mat, mat, mat]\n        } else if (mat.length && mat.length == 2) {\n            // interpret as [top/bottom, sides]\n            mats = [mat[1], mat[1], mat[0], mat[0], mat[1], mat[1]]\n        } else if (mat.length && mat.length == 3) {\n            // interpret as [top, bottom, sides]\n            mats = [mat[2], mat[2], mat[0], mat[1], mat[2], mat[2]]\n        } else if (mat.length && mat.length == 6) {\n            // interpret as [-x, +x, -y, +y, -z, +z]\n            mats = mat\n        } else throw 'Invalid material parameter: ' + mat\n\n        // argument is material name, but store as material id, allocating one if needed\n        for (var i = 0; i < 6; ++i) {\n            blockMats[id * 6 + i] = getMaterialId(this, matIDs, mats[i], true)\n        }\n\n        // props data object - currently only used for fluid properties\n        blockProps[id] = {}\n\n        // if block is fluid, initialize properties if needed\n        if (blockIsFluid[id]) {\n            blockProps[id].fluidDensity = opts.fluidDensity\n            blockProps[id].viscosity = opts.viscosity\n        }\n\n        // event callbacks\n        var hasHandler = opts.onLoad || opts.onUnload || opts.onSet || opts.onUnset || opts.onCustomMeshCreate\n        blockHandlers[id] = (hasHandler) ? new BlockCallbackHolder(opts) : null\n\n        return id\n    }\n\n\n\n\n    /*\n     * Register (by name) a material and its parameters.\n     * \n     * @param name,color,textureURL,texHasAlpha\n     * @param renderMaterial an optional BABYLON material to be used for block faces with this block material\n    */\n\n    this.registerMaterial = function (name, color, textureURL, texHasAlpha, renderMaterial) {\n        // console.log('register mat: ', name, color, textureURL)\n        var id = matIDs[name] || matData.length\n        matIDs[name] = id\n        var alpha = 1\n        if (color && color.length == 4) {\n            alpha = color.pop()\n        }\n        matData[id] = {\n            color: color || [1, 1, 1],\n            alpha: alpha,\n            texture: textureURL ? texturePath + textureURL : '',\n            textureAlpha: !!texHasAlpha,\n            renderMat: renderMaterial || null,\n        }\n        return id\n    }\n\n\n\n    /*\n     *      quick accessors for querying block ID stuff\n    */\n\n    // block solidity (as in physics)\n    this.getBlockSolidity = function (id) {\n        return blockSolidity[id]\n    }\n\n    // block opacity - whether it obscures the whole voxel (dirt) or \n    // can be partially seen through (like a fencepost, etc)\n    this.getBlockOpacity = function (id) {\n        return blockOpacity[id]\n    }\n\n    // block is fluid or not\n    this.getBlockFluidity = function (id) {\n        return blockIsFluid[id]\n    }\n\n    // Get block property object passed in at registration\n    this.getBlockProps = function (id) {\n        return blockProps[id]\n    }\n\n    // look up a block ID's face material\n    // dir is a value 0..5: [ +x, -x, +y, -y, +z, -z ]\n    this.getBlockFaceMaterial = function (blockId, dir) {\n        return blockMats[blockId * 6 + dir]\n    }\n\n\n\n\n\n    // look up material color given ID\n    this.getMaterialColor = function (matID) {\n        return matData[matID].color\n    }\n\n    // look up material texture given ID\n    this.getMaterialTexture = function (matID) {\n        return matData[matID].texture\n    }\n\n    // look up material's properties: color, alpha, texture, textureAlpha\n    this.getMaterialData = function (matID) {\n        return matData[matID]\n    }\n\n\n\n\n\n    /*\n     * \n     *   Meant for internal use within the engine\n     * \n    */\n\n\n    // internal access to lookup arrays\n    this._solidityLookup = blockSolidity\n    this._opacityLookup = blockOpacity\n    this._blockMeshLookup = blockMeshes\n    this._blockHandlerLookup = blockHandlers\n\n\n\n\n\n\n    // look up color used for vertices of blocks of given material\n    // - i.e. white if it has a texture, color otherwise\n    this._getMaterialVertexColor = function (matID) {\n        if (matData[matID].texture) return white\n        return matData[matID].color\n    }\n    var white = [1, 1, 1]\n\n\n\n\n\n    /*\n     * \n     *      default initialization\n     * \n    */\n\n    // add a default material and set ID=1 to it\n    // note that registering new block data overwrites the old\n    this.registerMaterial('dirt', [0.4, 0.3, 0], null)\n    this.registerBlock(1, { material: 'dirt' })\n\n\n\n}\n\n\n\n/*\n * \n *          helpers\n * \n*/\n\n\n\n// look up material ID given its name\n// if lazy is set, pre-register the name and return an ID\nfunction getMaterialId(reg, matIDs, name, lazyInit) {\n    if (!name) return 0\n    var id = matIDs[name]\n    if (id === undefined && lazyInit) id = reg.registerMaterial(name)\n    return id\n}\n\n\n\n// data class for holding block callback references\nfunction BlockCallbackHolder(opts) {\n    this.onLoad = opts.onLoad || null\n    this.onUnload = opts.onUnload || null\n    this.onSet = opts.onSet || null\n    this.onUnset = opts.onUnset || null\n    this.onCustomMeshCreate = opts.onCustomMeshCreate || null\n}\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/registry.js?");

/***/ }),

/***/ "../../src/lib/rendering.js":
/*!******************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/rendering.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar glvec3 = __webpack_require__(/*! gl-vec3 */ \"../../node_modules/gl-vec3/index.js\")\nvar aabb = __webpack_require__(/*! aabb-3d */ \"../../node_modules/aabb-3d/index.js\")\nvar sweep = __webpack_require__(/*! voxel-aabb-sweep */ \"../../node_modules/voxel-aabb-sweep/index.js\")\nvar removeUnorderedListItem = __webpack_require__(/*! ./util */ \"../../src/lib/util.js\").removeUnorderedListItem\n\n\n// For now, assume Babylon.js has been imported into the global space already\nif (!BABYLON) {\n    throw new Error('Babylon.js reference not found! Abort! Abort!')\n}\n\nmodule.exports = function (noa, opts, canvas) {\n    return new Rendering(noa, opts, canvas)\n}\n\nvar vec3 = BABYLON.Vector3 // not a gl-vec3, in this module only!!\nvar col3 = BABYLON.Color3\n\n\n\n// profiling flags\nvar PROFILE = 0\n\n\n\nvar defaults = {\n    showFPS: false,\n    antiAlias: true,\n    clearColor: [0.8, 0.9, 1],\n    ambientColor: [1, 1, 1],\n    lightDiffuse: [1, 1, 1],\n    lightSpecular: [1, 1, 1],\n    groundLightColor: [0.5, 0.5, 0.5],\n    initialCameraZoom: 0,\n    cameraZoomSpeed: .2,\n    cameraMaxAngle: (Math.PI / 2) - 0.01,\n    useAO: true,\n    AOmultipliers: [0.93, 0.8, 0.5],\n    reverseAOmultiplier: 1.0,\n    useOctreesForDynamicMeshes: true,\n    preserveDrawingBuffer: true,\n}\n\n\n\n\n\nfunction Rendering(noa, opts, canvas) {\n    this.noa = noa\n    opts = Object.assign({}, defaults, opts)\n    this.zoomDistance = opts.initialCameraZoom      // zoom setting\n    this._currentZoom = this.zoomDistance       // current actual zoom level\n    this._cameraZoomSpeed = opts.cameraZoomSpeed\n    this._maxCamAngle = opts.cameraMaxAngle\n\n    // internals\n    this._dynamicMeshes = []\n    this.useAO = !!opts.useAO\n    this.aoVals = opts.AOmultipliers\n    this.revAoVal = opts.reverseAOmultiplier\n    this.meshingCutoffTime = 6 // ms\n    this._dynamicMeshOctrees = opts.useOctreesForDynamicMeshes\n    this._resizeDebounce = 250 // ms\n\n    // set up babylon scene\n    initScene(this, canvas, opts)\n\n    // for debugging\n    if (opts.showFPS) setUpFPS()\n}\n\n\n// Constructor helper - set up the Babylon.js scene and basic components\nfunction initScene(self, canvas, opts) {\n    if (!BABYLON) throw new Error('BABYLON.js engine not found!')\n\n    // init internal properties\n    self._engine = new BABYLON.Engine(canvas, opts.antiAlias, {\n        preserveDrawingBuffer: opts.preserveDrawingBuffer,\n    })\n    self._scene = new BABYLON.Scene(self._engine)\n    var scene = self._scene\n    // remove built-in listeners\n    scene.detachControl()\n\n    // octree setup\n    self._octree = new BABYLON.Octree($ => { })\n    self._octree.blocks = []\n    scene._selectionOctree = self._octree\n\n    // camera, and empty mesh to hold it, and one to accumulate rotations\n    self._rotationHolder = new BABYLON.Mesh('rotHolder', scene)\n    self._cameraHolder = new BABYLON.Mesh('camHolder', scene)\n    self._camera = new BABYLON.FreeCamera('camera', new vec3(0, 0, 0), scene)\n    self._camera.parent = self._cameraHolder\n    self._camera.minZ = .01\n    self._cameraHolder.visibility = false\n    self._rotationHolder.visibility = false\n\n    // plane obscuring the camera - for overlaying an effect on the whole view\n    self._camScreen = BABYLON.Mesh.CreatePlane('camScreen', 10, scene)\n    self.addMeshToScene(self._camScreen)\n    self._camScreen.position.z = .1\n    self._camScreen.parent = self._camera\n    self._camScreenMat = self.makeStandardMaterial('camscreenmat')\n    self._camScreen.material = self._camScreenMat\n    self._camScreen.setEnabled(false)\n    self._camLocBlock = 0\n\n    // apply some defaults\n    self._light = new BABYLON.HemisphericLight('light', new vec3(0.1, 1, 0.3), scene)\n    function arrToColor(a) { return new col3(a[0], a[1], a[2]) }\n    scene.clearColor = arrToColor(opts.clearColor)\n    scene.ambientColor = arrToColor(opts.ambientColor)\n    self._light.diffuse = arrToColor(opts.lightDiffuse)\n    self._light.specular = arrToColor(opts.lightSpecular)\n    self._light.groundColor = arrToColor(opts.groundLightColor)\n\n    // make a default flat material (used or clone by terrain, etc)\n    self.flatMaterial = self.makeStandardMaterial('flatmat')\n\n}\n\n\n\n/*\n *   PUBLIC API \n*/\n\n// Init anything about scene that needs to wait for engine internals\nRendering.prototype.initScene = function () {\n    // engine entity to follow the player and act as camera target\n    this.cameraTarget = this.noa.ents.createEntity(['position'])\n    this.noa.ents.addComponent(this.cameraTarget, 'followsEntity', {\n        entity: this.noa.playerEntity,\n        offset: [0, this.noa.playerEyeOffset, 0],\n    })\n}\n\n// accessor for client app to build meshes and register materials\nRendering.prototype.getScene = function () {\n    return this._scene\n}\n\n// per-tick listener for rendering-related stuff\nRendering.prototype.tick = function (dt) {\n    if (this._dynamicMeshOctrees) updateDynamicMeshOctrees(this)\n}\n\n\n\n\n\nRendering.prototype.render = function (dt) {\n    profile_hook('start')\n    updateCamera(this)\n    profile_hook('updateCamera')\n    this._engine.beginFrame()\n    profile_hook('beginFrame')\n    this._scene.render()\n    profile_hook('render')\n    fps_hook()\n    this._engine.endFrame()\n    profile_hook('endFrame')\n    profile_hook('end')\n}\n\n\n\nRendering.prototype.resize = function (e) {\n    if (!pendingResize) {\n        pendingResize = true\n        setTimeout(() => {\n            this._engine.resize()\n            pendingResize = false\n        }, this._resizeDebounce)\n    }\n}\nvar pendingResize = false\n\n\n\nRendering.prototype.highlightBlockFace = function (show, posArr, normArr) {\n    var m = getHighlightMesh(this)\n    if (show) {\n        // bigger slop when zoomed out\n        var dist = this._currentZoom + glvec3.distance(this.noa.getPlayerEyePosition(), posArr)\n        var slop = 0.001 + 0.001 * dist\n        var pos = _highlightPos\n        for (var i = 0; i < 3; ++i) {\n            pos[i] = Math.floor(posArr[i]) + .5 + ((0.5 + slop) * normArr[i])\n        }\n        m.position.copyFromFloats(pos[0], pos[1], pos[2])\n        m.rotation.x = (normArr[1]) ? Math.PI / 2 : 0\n        m.rotation.y = (normArr[0]) ? Math.PI / 2 : 0\n    }\n    m.setEnabled(show)\n}\nvar _highlightPos = glvec3.create()\n\n\nRendering.prototype.getCameraVector = function () {\n    return vec3.TransformCoordinates(BABYLON.Axis.Z, this._rotationHolder.getWorldMatrix())\n}\nvar zero = vec3.Zero()\nRendering.prototype.getCameraPosition = function () {\n    return vec3.TransformCoordinates(zero, this._camera.getWorldMatrix())\n}\nRendering.prototype.getCameraRotation = function () {\n    var rot = this._rotationHolder.rotation\n    return [rot.x, rot.y]\n}\nRendering.prototype.setCameraRotation = function (x, y) {\n    var rot = this._rotationHolder.rotation\n    rot.x = Math.max(-this._maxCamAngle, Math.min(this._maxCamAngle, x))\n    rot.y = y\n}\n\n\n\n\n// add a mesh to the scene's octree setup so that it renders\n// pass in isStatic=true if the mesh won't move (i.e. change octree blocks)\nRendering.prototype.addMeshToScene = function (mesh, isStatic) {\n    // exit silently if mesh has already been added and not removed\n    if (mesh._currentNoaChunk || this._octree.dynamicContent.includes(mesh)) {\n        return\n    }\n    var pos = mesh.position\n    var chunk = this.noa.world._getChunkByCoords(pos.x, pos.y, pos.z)\n    if (this._dynamicMeshOctrees && chunk && chunk.octreeBlock) {\n        // add to an octree\n        chunk.octreeBlock.entries.push(mesh)\n        mesh._currentNoaChunk = chunk\n    } else {\n        // mesh added outside an active chunk - so treat as scene-dynamic\n        this._octree.dynamicContent.push(mesh)\n    }\n    // remember for updates if it's not static\n    if (!isStatic) this._dynamicMeshes.push(mesh)\n    // handle remover when mesh gets disposed\n    var remover = this.removeMeshFromScene.bind(this, mesh)\n    mesh.onDisposeObservable.add(remover)\n}\n\n// undo the above\nRendering.prototype.removeMeshFromScene = function (mesh) {\n    if (mesh._currentNoaChunk && mesh._currentNoaChunk.octreeBlock) {\n        removeUnorderedListItem(mesh._currentNoaChunk.octreeBlock.entries, mesh)\n    }\n    mesh._currentNoaChunk = null\n    removeUnorderedListItem(this._octree.dynamicContent, mesh)\n    removeUnorderedListItem(this._dynamicMeshes, mesh)\n}\n\n\n\n\n// runs once per tick - move any dynamic meshes to correct chunk octree\nfunction updateDynamicMeshOctrees(self) {\n    for (var i = 0; i < self._dynamicMeshes.length; i++) {\n        var mesh = self._dynamicMeshes[i]\n        if (mesh._isDisposed) continue // shouldn't be possible\n        var pos = mesh.position\n        var prev = mesh._currentNoaChunk || null\n        var next = self.noa.world._getChunkByCoords(pos.x, pos.y, pos.z) || null\n        if (prev === next) continue\n        // mesh has moved chunks since last update\n        // remove from previous location...\n        if (prev && prev.octreeBlock) {\n            removeUnorderedListItem(prev.octreeBlock.entries, mesh)\n        } else {\n            removeUnorderedListItem(self._octree.dynamicContent, mesh)\n        }\n        // ... and add to new location\n        if (next && next.octreeBlock) {\n            next.octreeBlock.entries.push(mesh)\n        } else {\n            self._octree.dynamicContent.push(mesh)\n        }\n        mesh._currentNoaChunk = next\n    }\n}\n\n\n\nRendering.prototype.makeMeshInstance = function (mesh, isStatic) {\n    var m = mesh.createInstance(mesh.name + ' instance' || false)\n    if (mesh.billboardMode) m.billboardMode = mesh.billboardMode\n    // add to scene so as to render\n    this.addMeshToScene(m, isStatic)\n\n    // testing performance tweaks\n\n    // make instance meshes skip over getLOD checks, since there may be lots of them\n    // mesh.getLOD = m.getLOD = function () { return mesh }\n    m._currentLOD = mesh\n\n    // make terrain instance meshes skip frustum checks \n    // (they'll still get culled by octree checks)\n    // if (isStatic) m.isInFrustum = function () { return true }\n\n    return m\n}\n\n\n\n// Create a default standardMaterial:\n//      flat, nonspecular, fully reflects diffuse and ambient light\nRendering.prototype.makeStandardMaterial = function (name) {\n    var mat = new BABYLON.StandardMaterial(name, this._scene)\n    mat.specularColor.copyFromFloats(0, 0, 0)\n    mat.ambientColor.copyFromFloats(1, 1, 1)\n    mat.diffuseColor.copyFromFloats(1, 1, 1)\n    return mat\n}\n\n\n\n\n\n\n\n/*\n *\n * \n *   ACCESSORS FOR CHUNK ADD/REMOVAL/MESHING\n *\n * \n*/\n\nRendering.prototype.prepareChunkForRendering = function (chunk) {\n    var cs = chunk.size\n    var min = new vec3(chunk.x, chunk.y, chunk.z)\n    var max = new vec3(chunk.x + cs, chunk.y + cs, chunk.z + cs)\n    chunk.octreeBlock = new BABYLON.OctreeBlock(min, max, undefined, undefined, undefined, $ => { })\n    this._octree.blocks.push(chunk.octreeBlock)\n}\n\nRendering.prototype.disposeChunkForRendering = function (chunk) {\n    this.removeTerrainMesh(chunk)\n    removeUnorderedListItem(this._octree.blocks, chunk.octreeBlock)\n    chunk.octreeBlock.entries.length = 0\n    chunk.octreeBlock = null\n}\n\nRendering.prototype.addTerrainMesh = function (chunk, mesh) {\n    this.removeTerrainMesh(chunk)\n    if (mesh.getIndices().length) this.addMeshToScene(mesh, true)\n    chunk._terrainMesh = mesh\n}\n\nRendering.prototype.removeTerrainMesh = function (chunk) {\n    if (!chunk._terrainMesh) return\n    chunk._terrainMesh.dispose()\n    chunk._terrainMesh = null\n}\n\n\n\n\n\n\n\n\n\n\n/*\n *\n *   INTERNALS\n *\n*/\n\n\n\n\n/*\n *\n *  zoom/camera related internals\n *\n*/\n\n\n// check if obstructions are behind camera by sweeping back an AABB\n// along the negative camera vector\n\nfunction cameraObstructionDistance(self) {\n    var size = 0.2\n    if (!_camBox) {\n        _camBox = new aabb([0, 0, 0], [size * 2, size * 2, size * 2])\n        _getVoxel = function (x, y, z) {\n            return self.noa.world.getBlockSolidity(x, y, z)\n        }\n    }\n\n    var pos = self._cameraHolder.position\n    glvec3.set(_posVec, pos.x - size, pos.y - size, pos.z - size)\n    _camBox.setPosition(_posVec)\n\n    var dist = -self.zoomDistance\n    var cam = self.getCameraVector()\n    glvec3.set(_camVec, dist * cam.x, dist * cam.y, dist * cam.z)\n\n    return sweep(_getVoxel, _camBox, _camVec, function (dist, axis, dir, vec) {\n        return true\n    }, true)\n}\n\nvar _posVec = glvec3.create()\nvar _camVec = glvec3.create()\nvar _camBox\nvar _getVoxel\n\n\n\n\n// Various updates to camera position/zoom, called every render\n\nfunction updateCamera(self) {\n    // update cameraHolder pos/rot from rotation holder and target entity\n    self._cameraHolder.rotation.copyFrom(self._rotationHolder.rotation)\n    var cpos = self.noa.ents.getPositionData(self.cameraTarget).renderPosition\n    self._cameraHolder.position.copyFromFloats(cpos[0], cpos[1], cpos[2])\n\n    // check obstructions and tween camera towards clipped position\n    var dist = self.zoomDistance\n    var speed = self._cameraZoomSpeed\n    if (dist > 0) {\n        dist = cameraObstructionDistance(self)\n        if (dist < self._currentZoom) self._currentZoom = dist\n    }\n    self._currentZoom += speed * (dist - self._currentZoom)\n    self._camera.position.z = -self._currentZoom\n\n    // check id of block camera is in for overlay effects (e.g. being in water) \n    var cam = self.getCameraPosition()\n    var id = self.noa.world.getBlockID(Math.floor(cam.x), Math.floor(cam.y), Math.floor(cam.z))\n    checkCameraEffect(self, id)\n}\n\n\n\n//  If camera's current location block id has alpha color (e.g. water), apply/remove an effect\n\nfunction checkCameraEffect(self, id) {\n    if (id === self._camLocBlock) return\n    if (id === 0) {\n        self._camScreen.setEnabled(false)\n    } else {\n        var matId = self.noa.registry.getBlockFaceMaterial(id, 0)\n        if (matId) {\n            var matData = self.noa.registry.getMaterialData(matId)\n            var col = matData.color\n            var alpha = matData.alpha\n            if (col && alpha && alpha < 1) {\n                self._camScreenMat.diffuseColor = new col3(col[0], col[1], col[2])\n                self._camScreenMat.alpha = alpha\n                self._camScreen.setEnabled(true)\n            }\n        }\n    }\n    self._camLocBlock = id\n}\n\n\n\n\n\n\n// make or get a mesh for highlighting active voxel\nfunction getHighlightMesh(rendering) {\n    var m = rendering._highlightMesh\n    if (!m) {\n        var mesh = BABYLON.Mesh.CreatePlane(\"highlight\", 1.0, rendering._scene)\n        var hlm = rendering.makeStandardMaterial('highlightMat')\n        hlm.backFaceCulling = false\n        hlm.emissiveColor = new col3(1, 1, 1)\n        hlm.alpha = 0.2\n        mesh.material = hlm\n        m = rendering._highlightMesh = mesh\n        // outline\n        var s = 0.5\n        var lines = BABYLON.Mesh.CreateLines(\"hightlightLines\", [\n            new vec3(s, s, 0),\n            new vec3(s, -s, 0),\n            new vec3(-s, -s, 0),\n            new vec3(-s, s, 0),\n            new vec3(s, s, 0)\n        ], rendering._scene)\n        lines.color = new col3(1, 1, 1)\n        lines.parent = mesh\n\n        rendering.addMeshToScene(m)\n        rendering.addMeshToScene(lines)\n    }\n    return m\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n * \n *      sanity checks:\n * \n*/\n\nRendering.prototype.debug_SceneCheck = function () {\n    var meshes = this._scene.meshes\n    var dyns = this._octree.dynamicContent\n    var octs = []\n    var numOcts = 0\n    var mats = this._scene.materials\n    var allmats = []\n    mats.forEach(mat => {\n        if (mat.subMaterials) mat.subMaterials.forEach(mat => allmats.push(mat))\n        else allmats.push(mat)\n    })\n    this._octree.blocks.forEach(function (block) {\n        numOcts++\n        block.entries.forEach(m => octs.push(m))\n    })\n    meshes.forEach(function (m) {\n        if (m._isDisposed) warn(m, 'disposed mesh in scene')\n        if (empty(m)) return\n        if (missing(m, dyns, octs)) warn(m, 'non-empty mesh missing from octree')\n        if (!m.material) { warn(m, 'non-empty scene mesh with no material'); return }\n        (m.material.subMaterials || [m.material]).forEach(function (mat) {\n            if (missing(mat, mats)) warn(mat, 'mesh material not in scene')\n        })\n    })\n    var unusedMats = []\n    allmats.forEach(mat => {\n        var used = false\n        meshes.forEach(mesh => {\n            if (mesh.material === mat) used = true\n            if (!mesh.material || !mesh.material.subMaterials) return\n            if (mesh.material.subMaterials.includes(mat)) used = true\n        })\n        if (!used) unusedMats.push(mat.name)\n    })\n    if (unusedMats.length) {\n        console.warn('Materials unused by any mesh: ', unusedMats.join(', '))\n    }\n    dyns.forEach(function (m) {\n        if (missing(m, meshes)) warn(m, 'octree/dynamic mesh not in scene')\n    })\n    octs.forEach(function (m) {\n        if (missing(m, meshes)) warn(m, 'octree block mesh not in scene')\n    })\n    var avgPerOct = Math.round(10 * octs.length / numOcts) / 10\n    console.log('meshes - octree:', octs.length, '  dynamic:', dyns.length,\n        '   avg meshes/octreeBlock:', avgPerOct)\n    function warn(obj, msg) { console.warn(obj.name + ' --- ' + msg) }\n    function empty(mesh) { return (mesh.getIndices().length === 0) }\n    function missing(obj, list1, list2) {\n        if (!obj) return false\n        if (list1.includes(obj)) return false\n        if (list2 && list2.includes(obj)) return false\n        return true\n    }\n    return 'done.'\n}\n\nRendering.prototype.debug_MeshCount = function () {\n    var ct = {}\n    this._scene.meshes.forEach(m => {\n        var n = m.name || ''\n        n = n.replace(/-\\d+.*/, '#')\n        n = n.replace(/\\d+.*/, '#')\n        n = n.replace(/(rotHolder|camHolder|camScreen)/, 'rendering use')\n        n = n.replace(/atlas sprite .*/, 'atlas sprites')\n        ct[n] = ct[n] || 0\n        ct[n]++\n    })\n    for (var s in ct) console.log('   ' + (ct[s] + '       ').substr(0, 7) + s)\n}\n\n\n\n\n\n\n\nvar profile_hook = (function () {\n    if (!PROFILE) return function () { }\n    var every = 200\n    var timer = new (__webpack_require__(/*! ./util */ \"../../src/lib/util.js\").Timer)(every, 'render internals')\n    return function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n\nvar fps_hook = function () { }\nfunction setUpFPS() {\n    var div = document.createElement('div')\n    div.id = 'noa_fps'\n    var style = 'position:absolute; top:0; right:0; z-index:0;'\n    style += 'color:white; background-color:rgba(0,0,0,0.5);'\n    style += 'font:14px monospace; text-align:center;'\n    style += 'min-width:2em; margin:4px;'\n    div.style = style\n    document.body.appendChild(div)\n    var every = 1000\n    var ct = 0\n    var longest = 0\n    var start = performance.now()\n    var last = start\n    fps_hook = function () {\n        ct++\n        var nt = performance.now()\n        if (nt - last > longest) longest = nt - last\n        last = nt\n        if (nt - start < every) return\n        var fps = Math.round(ct / (nt - start) * 1000)\n        var min = Math.round(1 / longest * 1000)\n        div.innerHTML = fps + '<br>' + min\n        ct = 0\n        longest = 0\n        start = nt\n    }\n}\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/rendering.js?");

/***/ }),

/***/ "../../src/lib/terrainMesher.js":
/*!**********************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/terrainMesher.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\n\nmodule.exports = new TerrainMesher()\n\n\n\n\n// enable for profiling..\nvar PROFILE = 0\n\n\n\n\n/*\n * \n *          TERRAIN MESHER!!\n * \n*/\n\n\nfunction TerrainMesher() {\n\n    var greedyMesher = new GreedyMesher()\n    var meshBuilder = new MeshBuilder()\n\n\n    /*\n     * \n     * Entry point and high-level flow\n     * \n    */\n\n    this.meshChunk = function (chunk, matGetter, colGetter, ignoreMaterials, useAO, aoVals, revAoVal) {\n        profile_hook('start')\n        var noa = chunk.noa\n\n        // args\n        var array = chunk.array\n        var mats = matGetter || noa.registry.getBlockFaceMaterial\n        var cols = colGetter || noa.registry._getMaterialVertexColor\n        var ao = (useAO === undefined) ? noa.rendering.useAO : useAO\n        var vals = aoVals || noa.rendering.aoVals\n        var rev = isNaN(revAoVal) ? noa.rendering.revAoVal : revAoVal\n\n        // greedy mesher creates an array of Submesh structs\n        var subMeshes = greedyMesher.mesh(array, mats, cols, ao, vals, rev)\n\n        // builds the babylon mesh that will be added to the scene\n        var mesh\n        if (Object.keys(subMeshes).length) {\n            mesh = meshBuilder.build(chunk, subMeshes, ignoreMaterials)\n            profile_hook('built terrain')\n        }\n\n        profile_hook('end')\n        return mesh || null\n    }\n\n}\n\n\n\n\n/*\n * \n *  Submesh - holds one submesh worth of greedy-meshed data\n * \n *  Basically, the greedy mesher builds these and the mesh builder consumes them\n * \n*/\n\nfunction Submesh(id) {\n    this.id = id | 0\n    this.positions = []\n    this.indices = []\n    this.normals = []\n    this.colors = []\n    this.uvs = []\n}\n\nSubmesh.prototype.dispose = function () {\n    this.positions = null\n    this.indices = null\n    this.normals = null\n    this.colors = null\n    this.uvs = null\n}\n\n\n\n\n\n\n\n\n/*\n * \n *  Mesh Builder - turns an array of Submesh data into a \n *  Babylon.js mesh/submeshes, ready to be added to the scene\n * \n*/\n\nfunction MeshBuilder() {\n\n    var noa\n\n\n    // core\n    this.build = function (chunk, meshdata, ignoreMaterials) {\n        noa = chunk.noa\n\n        // preprocess meshdata entries to merge those that will use default terrain material\n        var mergeCriteria = function (mdat) {\n            if (ignoreMaterials) return true\n            if (mdat.renderMat) return false\n            var url = noa.registry.getMaterialTexture(mdat.id)\n            var alpha = noa.registry.getMaterialData(mdat.id).alpha\n            if (url || alpha < 1) return false\n        }\n        mergeSubmeshes(meshdata, mergeCriteria)\n\n        // now merge everything, keeping track of vertices/indices/materials\n        var results = mergeSubmeshes(meshdata, () => true)\n\n        // merge sole remaining submesh instance into a babylon mesh\n        var mdat = meshdata[results.mergedID]\n        var name = 'chunk_' + chunk.id\n        var mats = results.matIDs.map(id => getTerrainMaterial(id, ignoreMaterials))\n        var mesh = buildMeshFromSubmesh(mdat, name, mats, results.vertices, results.indices)\n\n        // position, freeze and exit\n        var x = chunk.i * chunk.size\n        var y = chunk.j * chunk.size\n        var z = chunk.k * chunk.size\n        mesh.position.x = x\n        mesh.position.y = y\n        mesh.position.z = z\n\n        mesh.freezeWorldMatrix()\n        mesh.freezeNormals()\n        return mesh\n    }\n\n\n\n    // this version builds a parent mesh + child meshes, rather than\n    // one big mesh with submeshes and a multimaterial.\n    // This should be obsolete, unless the first one has problems..\n    this.buildWithoutMultimats = function (chunk, meshdata, ignoreMaterials) {\n        noa = chunk.noa\n\n        // preprocess meshdata entries to merge those that use default terrain material\n        var mergeCriteria = function (mdat) {\n            if (ignoreMaterials) return true\n            if (mdat.renderMat) return false\n            var url = noa.registry.getMaterialTexture(mdat.id)\n            var alpha = noa.registry.getMaterialData(mdat.id).alpha\n            if (url || alpha < 1) return false\n        }\n        mergeSubmeshes(meshdata, mergeCriteria)\n\n        // go through (remaining) meshdata entries and create a mesh for each\n        // call the first one the parent, and attach others to it\n        var parent = null\n        var keylist = Object.keys(meshdata)\n        for (var i = 0; i < keylist.length; ++i) {\n            var mdat = meshdata[keylist[i]]\n            var matID = mdat.id\n            var mat = getTerrainMaterial(matID, ignoreMaterials)\n            var name = 'chunk_inner_' + chunk.id + ' ' + matID\n            var mesh = buildMeshFromSubmesh(mdat, name, [mat])\n\n            if (!parent) {\n                parent = mesh\n                // position the parent globally\n                var x = chunk.i * chunk.size\n                var y = chunk.j * chunk.size\n                var z = chunk.k * chunk.size\n                parent.position.x = x\n                parent.position.y = y\n                parent.position.z = z\n            } else {\n                mesh.parent = parent\n            }\n\n            mesh.freezeWorldMatrix()\n            mesh.freezeNormals()\n        }\n\n        return parent\n    }\n\n\n\n    // given a set of submesh objects, merge all those that \n    // meet some criteria into the first such submesh\n    //      modifies meshDataList in place!\n    function mergeSubmeshes(meshDataList, criteria) {\n        var vertices = []\n        var indices = []\n        var matIDs = []\n\n        var keylist = Object.keys(meshDataList)\n        var target = null\n        var targetID\n        for (var i = 0; i < keylist.length; ++i) {\n            var mdat = meshDataList[keylist[i]]\n            if (!criteria(mdat)) continue\n\n            vertices.push(mdat.positions.length)\n            indices.push(mdat.indices.length)\n            matIDs.push(mdat.id)\n\n            if (!target) {\n                target = mdat\n                targetID = keylist[i]\n\n            } else {\n                var indexOffset = target.positions.length / 3\n                // merge data in \"mdat\" onto \"target\"\n                target.positions = target.positions.concat(mdat.positions)\n                target.normals = target.normals.concat(mdat.normals)\n                target.colors = target.colors.concat(mdat.colors)\n                target.uvs = target.uvs.concat(mdat.uvs)\n                // indices must be offset relative to data being merged onto\n                for (var j = 0, len = mdat.indices.length; j < len; ++j) {\n                    target.indices.push(mdat.indices[j] + indexOffset)\n                }\n                // get rid of entry that's been merged\n                mdat.dispose()\n                delete meshDataList[keylist[i]]\n            }\n        }\n\n        return {\n            mergedID: targetID,\n            vertices: vertices,\n            indices: indices,\n            matIDs: matIDs,\n        }\n    }\n\n\n\n    function buildMeshFromSubmesh(submesh, name, mats, verts, inds) {\n\n        // base mesh and vertexData object\n        var scene = noa.rendering.getScene()\n        var mesh = new BABYLON.Mesh(name, scene)\n        var vdat = new BABYLON.VertexData()\n        vdat.positions = submesh.positions\n        vdat.indices = submesh.indices\n        vdat.normals = submesh.normals\n        vdat.colors = submesh.colors\n        vdat.uvs = submesh.uvs\n        vdat.applyToMesh(mesh)\n        submesh.dispose()\n\n        if (mats.length === 1) {\n            // if only one material ID, assign as a regular mesh and return\n            mesh.material = mats[0]\n\n        } else {\n            // else we need to make a multimaterial and define (babylon) submeshes\n            var multiMat = new BABYLON.MultiMaterial('multimat ' + name, scene)\n            mesh.subMeshes = []\n            // var totalVerts = vdat.positions.length\n            // var totalInds = vdat.indices.length\n            var vertStart = 0\n            var indStart = 0\n            for (var i = 0; i < mats.length; i++) {\n                multiMat.subMaterials[i] = mats[i]\n                var sub = new BABYLON.SubMesh(i, vertStart, verts[i], indStart, inds[i], mesh)\n                mesh.subMeshes[i] = sub\n                vertStart += verts[i]\n                indStart += inds[i]\n            }\n            mesh.material = multiMat\n        }\n\n        return mesh\n    }\n\n\n\n\n    //                         Material wrangling\n\n\n    var materialCache = {}\n\n    // manage materials/textures to avoid duplicating them\n    function getTerrainMaterial(matID, ignore) {\n        if (ignore) return noa.rendering.flatMaterial\n        var name = 'terrain mat ' + matID\n        if (!materialCache[name]) materialCache[name] = makeTerrainMaterial(matID)\n        return materialCache[name]\n    }\n\n\n    // canonical function to make a terrain material\n    function makeTerrainMaterial(id) {\n        // if user-specified render material is defined, use it\n        var matData = noa.registry.getMaterialData(id)\n        if (matData.renderMat) return matData.renderMat\n        // otherwise determine which built-in material to use\n        var url = noa.registry.getMaterialTexture(id)\n        var alpha = matData.alpha\n        if (!url && alpha == 1) {\n            // base material is fine for non-textured case, if no alpha\n            return noa.rendering.flatMaterial\n        }\n        var mat = noa.rendering.flatMaterial.clone('terrain' + id)\n        if (url) {\n            var scene = noa.rendering.getScene()\n            var tex = new BABYLON.Texture(url, scene, true, false, BABYLON.Texture.NEAREST_SAMPLINGMODE)\n            if (matData.textureAlpha) tex.hasAlpha = true\n            mat.diffuseTexture = tex\n        }\n        if (matData.alpha < 1) {\n            mat.alpha = matData.alpha\n        }\n        return mat\n    }\n}\n\n\n\n\n\n\n\n\n/*\n *    Greedy voxel meshing algorithm\n *        based initially on algo by Mikola Lysenko:\n *          http://0fps.net/2012/07/07/meshing-minecraft-part-2/\n *          but evolved quite a bit since then\n *        AO handling by me, stitched together out of cobwebs and dreams\n *    \n *    Arguments:\n *        arr: 3D ndarray of dimensions X,Y,Z\n *             packed with solidity/opacity booleans in higher bits\n *        getMaterial: function( blockID, dir )\n *             returns a material ID based on block id and which cube face it is\n *             (assume for now that each mat ID should get its own mesh)\n *        getColor: function( materialID )\n *             looks up a color (3-array) by material ID\n *             TODO: replace this with a lookup array?\n *        doAO: whether or not to bake ambient occlusion into vertex colors\n *        aoValues: array[3] of color multipliers for AO (least to most occluded)\n *        revAoVal: \"reverse ao\" - color multiplier for unoccluded exposed edges\n *\n *    Return object: array of mesh objects keyed by material ID\n *        arr[id] = {\n *          id:       material id for mesh\n *          vertices: ints, range 0 .. X/Y/Z\n *          indices:  ints\n *          normals:  ints,   -1 .. 1\n *          colors:   floats,  0 .. 1\n *          uvs:      floats,  0 .. X/Y/Z\n *        }\n*/\n\nfunction GreedyMesher() {\n\n    // data representation constants\n    var constants = __webpack_require__(/*! ./constants */ \"../../src/lib/constants.js\")\n\n    var ID_MASK = constants.ID_MASK\n    var VAR_MASK = constants.VAR_MASK\n    var SOLID_BIT = constants.SOLID_BIT\n    var OPAQUE_BIT = constants.OPAQUE_BIT\n    var OBJECT_BIT = constants.OBJECT_BIT\n\n\n    var maskCache = new Int16Array(16)\n    var aomaskCache = new Uint16Array(16)\n\n\n\n\n    this.mesh = function (arr, getMaterial, getColor, doAO, aoValues, revAoVal) {\n\n        // return object, holder for Submeshes\n        var subMeshes = {}\n\n        // precalc how to apply AO packing in first masking function\n        var skipReverseAO = (doAO && (revAoVal === aoValues[0]))\n        var aoPackFcn\n        if (doAO) aoPackFcn = (skipReverseAO) ? packAOMaskNoReverse : packAOMask\n\n\n        //Sweep over each axis, mapping axes to [d,u,v]\n        for (var d = 0; d < 3; ++d) {\n            var u = (d + 1) % 3\n            var v = (d + 2) % 3\n\n            // make transposed ndarray so index i is the axis we're sweeping\n            var arrT = arr.transpose(d, u, v).lo(1, 1, 1).hi(arr.shape[d] - 2, arr.shape[u] - 2, arr.shape[v] - 2)\n\n            // shorten len0 by 1 so faces at edges don't get drawn in both chunks\n            var len0 = arrT.shape[0] - 1\n            var len1 = arrT.shape[1]\n            var len2 = arrT.shape[2]\n\n            // create bigger mask arrays as needed\n            if (maskCache.length < len1 * len2) {\n                maskCache = new Int16Array(len1 * len2)\n                aomaskCache = new Uint16Array(len1 * len2)\n            }\n\n            // iterate along current major axis..\n            for (var i = 0; i <= len0; ++i) {\n\n                // fills mask and aomask arrays with values\n                constructMeshMasks(i, d, arrT, getMaterial, aoPackFcn)\n                profile_hook('built masks')\n\n                // parses the masks to do greedy meshing\n                constructMeshDataFromMasks(i, d, u, v, len1, len2,\n                    doAO, subMeshes, getColor, aoValues, revAoVal)\n\n                profile_hook('build submeshes')\n            }\n        }\n\n        // done, return array of submeshes\n        return subMeshes\n    }\n\n\n\n\n\n\n\n    //      Greedy meshing inner loop one\n    //\n    // iterating across ith 2d plane, with n being index into masks\n\n    function constructMeshMasks(i, d, arrT, getMaterial, aoPackFcn) {\n        var len = arrT.shape[1]\n        var mask = maskCache\n        var aomask = aomaskCache\n        // set up for quick array traversals\n        var n = 0\n        var data = arrT.data\n        var dbase = arrT.index(i - 1, 0, 0)\n        var istride = arrT.stride[0]\n        var jstride = arrT.stride[1]\n        var kstride = arrT.stride[2]\n\n        for (var k = 0; k < len; ++k) {\n            var d0 = dbase\n            dbase += kstride\n            for (var j = 0; j < len; j++ , n++ , d0 += jstride) {\n\n                // mask[n] will represent the face needed between i-1,j,k and i,j,k\n                // for now, assume we never have two faces in both directions\n\n                // IDs at i-1,j,k  and  i,j,k\n                var id0 = data[d0]\n                var id1 = data[d0 + istride]\n\n                var faceDir = getFaceDir(id0, id1)\n                if (faceDir) {\n                    // set regular mask value to material ID, sign indicating direction\n                    mask[n] = (faceDir > 0) ?\n                        getMaterial(id0 & ID_MASK, d * 2) :\n                        -getMaterial(id1 & ID_MASK, d * 2 + 1)\n\n                    // if doing AO, precalculate AO level for each face into second mask\n                    if (aoPackFcn) {\n                        // i values in direction face is/isn't pointing\n                        var ipos = (faceDir > 0) ? i : i - 1\n                        var ineg = (faceDir > 0) ? i - 1 : i\n\n                        // this got so big I rolled it into a function\n                        aomask[n] = aoPackFcn(arrT, ipos, ineg, j, k)\n                    }\n                } else {\n                    // unneeded, mesher zeroes out mask as it goes\n                    // mask[n] = 0\n                }\n\n            }\n        }\n    }\n\n\n\n    function getFaceDir(id0, id1) {\n        // no face if both blocks are opaque, or if ids match\n        if (id0 === id1) return 0\n        var op0 = id0 & OPAQUE_BIT\n        var op1 = id1 & OPAQUE_BIT\n        if (op0 && op1) return 0\n        // if either block is opaque draw a face for it\n        if (op0) return 1\n        if (op1) return -1\n        // if one block is air or an object block draw face for the other\n        if (id1 === 0 || (id1 & OBJECT_BIT)) return 1\n        if (id0 === 0 || (id0 & OBJECT_BIT)) return -1\n        // only remaining case is two different non-opaque non-air blocks that are adjacent\n        // really we should draw both faces here; draw neither for now\n        return 0\n    }\n\n\n\n\n\n\n\n    //      Greedy meshing inner loop two\n    //\n    // construct data for mesh using the masks\n\n    function constructMeshDataFromMasks(i, d, u, v, len1, len2,\n        doAO, submeshes, getColor, aoValues, revAoVal) {\n        var n = 0\n        var mask = maskCache\n        var aomask = aomaskCache\n\n        // some logic is broken into helper functions for AO and non-AO\n        // this fixes deopts in Chrome (for reasons unknown)\n        var maskCompareFcn = (doAO) ? maskCompare : maskCompare_noAO\n        var meshColorFcn = (doAO) ? pushMeshColors : pushMeshColors_noAO\n\n        for (var k = 0; k < len2; ++k) {\n            var w = 1\n            var h = 1\n            for (var j = 0; j < len1; j += w, n += w) {\n\n                var maskVal = mask[n] | 0\n                if (!maskVal) {\n                    w = 1\n                    continue\n                }\n                var ao = aomask[n] | 0\n\n                // Compute width and height of area with same mask/aomask values\n                for (w = 1; w < len1 - j; ++w) {\n                    if (!maskCompareFcn(n + w, mask, maskVal, aomask, ao)) break\n                }\n\n                OUTER:\n                for (h = 1; h < len2 - k; ++h) {\n                    for (var m = 0; m < w; ++m) {\n                        var ix = n + m + h * len1\n                        if (!maskCompareFcn(ix, mask, maskVal, aomask, ao)) break OUTER\n                    }\n                }\n\n                // for testing: doing the following will disable greediness\n                //w=h=1\n\n                // material and mesh for this face\n                var matID = Math.abs(maskVal)\n                if (!submeshes[matID]) submeshes[matID] = new Submesh(matID)\n                var mesh = submeshes[matID]\n                var colors = mesh.colors\n                var c = getColor(matID)\n\n                // colors are pushed in helper function - avoids deopts\n                // tridir is boolean for which way to split the quad into triangles\n\n                var triDir = meshColorFcn(colors, c, ao, aoValues, revAoVal)\n\n\n                //Add quad, vertices = x -> x+du -> x+du+dv -> x+dv\n                var x = [0, 0, 0]\n                x[d] = i\n                x[u] = j\n                x[v] = k\n                var du = [0, 0, 0]; du[u] = w;\n                var dv = [0, 0, 0]; dv[v] = h;\n\n                var pos = mesh.positions\n                pos.push(\n                    x[0], x[1], x[2],\n                    x[0] + du[0], x[1] + du[1], x[2] + du[2],\n                    x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2],\n                    x[0] + dv[0], x[1] + dv[1], x[2] + dv[2])\n\n\n                // add uv values, with the order and sign depending on \n                // axis and direction so as to avoid mirror-image textures\n                var dir = (maskVal > 0) ? 1 : -1\n\n                if (d === 2) {\n                    mesh.uvs.push(\n                        0, h,\n                        -dir * w, h,\n                        -dir * w, 0,\n                        0, 0)\n                } else {\n                    mesh.uvs.push(\n                        0, w,\n                        0, 0,\n                        dir * h, 0,\n                        dir * h, w)\n                }\n\n\n                // Add indexes, ordered clockwise for the facing direction;\n\n                var vs = pos.length / 3 - 4\n\n                if (maskVal < 0) {\n                    if (triDir) {\n                        mesh.indices.push(vs, vs + 1, vs + 2, vs, vs + 2, vs + 3)\n                    } else {\n                        mesh.indices.push(vs + 1, vs + 2, vs + 3, vs, vs + 1, vs + 3)\n                    }\n                } else {\n                    if (triDir) {\n                        mesh.indices.push(vs, vs + 2, vs + 1, vs, vs + 3, vs + 2)\n                    } else {\n                        mesh.indices.push(vs + 3, vs + 1, vs, vs + 3, vs + 2, vs + 1)\n                    }\n                }\n\n\n                // norms depend on which direction the mask was solid in..\n                var norm0 = d === 0 ? dir : 0\n                var norm1 = d === 1 ? dir : 0\n                var norm2 = d === 2 ? dir : 0\n\n                // same norm for all vertices\n                mesh.normals.push(\n                    norm0, norm1, norm2,\n                    norm0, norm1, norm2,\n                    norm0, norm1, norm2,\n                    norm0, norm1, norm2)\n\n\n                //Zero-out mask\n                for (var hx = 0; hx < h; ++hx) {\n                    for (var wx = 0; wx < w; ++wx) {\n                        mask[n + wx + hx * len1] = 0\n                    }\n                }\n\n            }\n        }\n    }\n\n\n\n    // Two helper functions with AO and non-AO implementations:\n\n    function maskCompare(index, mask, maskVal, aomask, aoVal) {\n        if (maskVal !== mask[index]) return false\n        if (aoVal !== aomask[index]) return false\n        return true\n    }\n\n    function maskCompare_noAO(index, mask, maskVal, aomask, aoVal) {\n        if (maskVal !== mask[index]) return false\n        return true\n    }\n\n    function pushMeshColors_noAO(colors, c, ao, aoValues, revAoVal) {\n        colors.push(c[0], c[1], c[2], 1)\n        colors.push(c[0], c[1], c[2], 1)\n        colors.push(c[0], c[1], c[2], 1)\n        colors.push(c[0], c[1], c[2], 1)\n        return true // triangle direction doesn't matter for non-AO\n    }\n\n    function pushMeshColors(colors, c, ao, aoValues, revAoVal) {\n        var ao00 = unpackAOMask(ao, 0, 0)\n        var ao10 = unpackAOMask(ao, 1, 0)\n        var ao11 = unpackAOMask(ao, 1, 1)\n        var ao01 = unpackAOMask(ao, 0, 1)\n        pushAOColor(colors, c, ao00, aoValues, revAoVal)\n        pushAOColor(colors, c, ao10, aoValues, revAoVal)\n        pushAOColor(colors, c, ao11, aoValues, revAoVal)\n        pushAOColor(colors, c, ao01, aoValues, revAoVal)\n\n        // this bit is pretty magical..\n        var triDir = true\n        if (ao00 === ao11) {\n            triDir = (ao01 === ao10) ? (ao01 == 2) : true\n        } else {\n            triDir = (ao01 === ao10) ? false : (ao00 + ao11 > ao01 + ao10)\n        }\n        return triDir\n    }\n\n\n\n\n\n    /* \n     *  packAOMask:\n     *\n     *    For a given face, find occlusion levels for each vertex, then\n     *    pack 4 such (2-bit) values into one Uint8 value\n     * \n     *  Occlusion levels:\n     *    1 is flat ground, 2 is partial occlusion, 3 is max (corners)\n     *    0 is \"reverse occlusion\" - an unoccluded exposed edge \n     *  Packing order var(bit offset):\n     *      a01(2)  -   a11(6)   ^  K\n     *        -     -            +> J\n     *      a00(0)  -   a10(4)\n    */\n\n    // when skipping reverse AO, uses this simpler version of the function:\n\n    function packAOMaskNoReverse(data, ipos, ineg, j, k) {\n        var a00 = 1\n        var a01 = 1\n        var a10 = 1\n        var a11 = 1\n        var solidBit = SOLID_BIT\n\n        // facing into a solid (non-opaque) block?\n        var facingSolid = (solidBit & data.get(ipos, j, k))\n\n        // inc occlusion of vertex next to obstructed side\n        if (data.get(ipos, j + 1, k) & solidBit) { ++a10; ++a11 }\n        if (data.get(ipos, j - 1, k) & solidBit) { ++a00; ++a01 }\n        if (data.get(ipos, j, k + 1) & solidBit) { ++a01; ++a11 }\n        if (data.get(ipos, j, k - 1) & solidBit) { ++a00; ++a10 }\n\n        // treat corners differently based when facing a solid block\n        if (facingSolid) {\n            // always 2, or 3 in corners\n            a11 = (a11 == 3 || data.get(ipos, j + 1, k + 1) & solidBit) ? 3 : 2\n            a01 = (a01 == 3 || data.get(ipos, j - 1, k + 1) & solidBit) ? 3 : 2\n            a10 = (a10 == 3 || data.get(ipos, j + 1, k - 1) & solidBit) ? 3 : 2\n            a00 = (a00 == 3 || data.get(ipos, j - 1, k - 1) & solidBit) ? 3 : 2\n        } else {\n            // treat corner as occlusion 3 only if not occluded already\n            if (a11 === 1 && (data.get(ipos, j + 1, k + 1) & solidBit)) { a11 = 2 }\n            if (a01 === 1 && (data.get(ipos, j - 1, k + 1) & solidBit)) { a01 = 2 }\n            if (a10 === 1 && (data.get(ipos, j + 1, k - 1) & solidBit)) { a10 = 2 }\n            if (a00 === 1 && (data.get(ipos, j - 1, k - 1) & solidBit)) { a00 = 2 }\n        }\n\n        return a11 << 6 | a10 << 4 | a01 << 2 | a00\n    }\n\n    // more complicated AO packing when doing reverse AO on corners\n\n    function packAOMask(data, ipos, ineg, j, k) {\n        var a00 = 1\n        var a01 = 1\n        var a10 = 1\n        var a11 = 1\n        var solidBit = SOLID_BIT\n\n        // facing into a solid (non-opaque) block?\n        var facingSolid = (solidBit & data.get(ipos, j, k))\n\n        // inc occlusion of vertex next to obstructed side\n        if (data.get(ipos, j + 1, k) & solidBit) { ++a10; ++a11 }\n        if (data.get(ipos, j - 1, k) & solidBit) { ++a00; ++a01 }\n        if (data.get(ipos, j, k + 1) & solidBit) { ++a01; ++a11 }\n        if (data.get(ipos, j, k - 1) & solidBit) { ++a00; ++a10 }\n\n        if (facingSolid) {\n            // always 2, or 3 in corners\n            a11 = (a11 == 3 || data.get(ipos, j + 1, k + 1) & solidBit) ? 3 : 2\n            a01 = (a01 == 3 || data.get(ipos, j - 1, k + 1) & solidBit) ? 3 : 2\n            a10 = (a10 == 3 || data.get(ipos, j + 1, k - 1) & solidBit) ? 3 : 2\n            a00 = (a00 == 3 || data.get(ipos, j - 1, k - 1) & solidBit) ? 3 : 2\n        } else {\n\n            // check each corner, and if not present do reverse AO\n            if (a11 === 1) {\n                if (data.get(ipos, j + 1, k + 1) & solidBit) { a11 = 2 }\n                else if (!(data.get(ineg, j, k + 1) & solidBit) ||\n                    !(data.get(ineg, j + 1, k) & solidBit) ||\n                    !(data.get(ineg, j + 1, k + 1) & solidBit)) {\n                    a11 = 0\n                }\n            }\n\n            if (a10 === 1) {\n                if (data.get(ipos, j + 1, k - 1) & solidBit) { a10 = 2 }\n                else if (!(data.get(ineg, j, k - 1) & solidBit) ||\n                    !(data.get(ineg, j + 1, k) & solidBit) ||\n                    !(data.get(ineg, j + 1, k - 1) & solidBit)) {\n                    a10 = 0\n                }\n            }\n\n            if (a01 === 1) {\n                if (data.get(ipos, j - 1, k + 1) & solidBit) { a01 = 2 }\n                else if (!(data.get(ineg, j, k + 1) & solidBit) ||\n                    !(data.get(ineg, j - 1, k) & solidBit) ||\n                    !(data.get(ineg, j - 1, k + 1) & solidBit)) {\n                    a01 = 0\n                }\n            }\n\n            if (a00 === 1) {\n                if (data.get(ipos, j - 1, k - 1) & solidBit) { a00 = 2 }\n                else if (!(data.get(ineg, j, k - 1) & solidBit) ||\n                    !(data.get(ineg, j - 1, k) & solidBit) ||\n                    !(data.get(ineg, j - 1, k - 1) & solidBit)) {\n                    a00 = 0\n                }\n            }\n        }\n\n        return a11 << 6 | a10 << 4 | a01 << 2 | a00\n    }\n\n\n\n    // unpack (2 bit) ao value from ao mask\n    // see above for details\n    function unpackAOMask(aomask, jpos, kpos) {\n        var offset = jpos ? (kpos ? 6 : 4) : (kpos ? 2 : 0)\n        return aomask >> offset & 3\n    }\n\n\n    // premultiply vertex colors by value depending on AO level\n    // then push them into color array\n    function pushAOColor(colors, baseCol, ao, aoVals, revAoVal) {\n        var mult = (ao === 0) ? revAoVal : aoVals[ao - 1]\n        colors.push(baseCol[0] * mult, baseCol[1] * mult, baseCol[2] * mult, 1)\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar profile_hook = (function () {\n    if (!PROFILE) return function () { }\n    var every = 50\n    var timer = new (__webpack_require__(/*! ./util */ \"../../src/lib/util.js\").Timer)(every, 'Terrain meshing')\n    return function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/terrainMesher.js?");

/***/ }),

/***/ "../../src/lib/util.js":
/*!*************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/util.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = {\n    Timer: Timer,\n    removeUnorderedListItem: removeUnorderedListItem,\n}\n\n\n\n\n// helper to swap item to end and pop(), instead of splice()ing\nfunction removeUnorderedListItem(list, item) {\n    var i = list.indexOf(item)\n    if (i < 0) { return }\n    if (i === list.length - 1) {\n        list.pop()\n    } else {\n        list[i] = list.pop()\n    }\n}\n\n\n\n\n// simple thing for reporting time split up between several activities\nfunction Timer(_every, _title) {\n    var title = _title || ''\n    var every = _every || 1\n    var times = []\n    var names = []\n    var started = 0\n    var last = 0\n    var iter = 0\n    var total = 0\n    var clearNext = true\n\n    this.start = function () {\n        if (clearNext) {\n            times.length = names.length = 0\n            clearNext = false\n        }\n        started = last = performance.now()\n        iter++\n    }\n    this.add = function (name) {\n        var t = performance.now()\n        if (names.indexOf(name) < 0) names.push(name)\n        var i = names.indexOf(name)\n        if (!times[i]) times[i] = 0\n        times[i] += t - last\n        last = t\n    }\n    this.report = function () {\n        total += performance.now() - started\n        if (iter === every) {\n            var head = title + ' total ' + (total / every).toFixed(2) + 'ms (avg, ' + every + ' runs)    '\n            console.log(head, names.map(function (name, i) {\n                return name + ': ' + (times[i] / every).toFixed(2) + 'ms    '\n            }).join(''))\n            clearNext = true\n            iter = 0\n            total = 0\n        }\n    }\n}\n\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/util.js?");

/***/ }),

/***/ "../../src/lib/world.js":
/*!**************************************************!*\
  !*** /home/sasogu/web/EduCraft/src/lib/world.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ndHash = __webpack_require__(/*! ndarray-hash */ \"../../node_modules/ndarray-hash/ndhash.js\")\nvar EventEmitter = __webpack_require__(/*! events */ \"../../node_modules/events/events.js\").EventEmitter\nvar Chunk = __webpack_require__(/*! ./chunk */ \"../../src/lib/chunk.js\")\n\n\nmodule.exports = function (noa, opts) {\n    return new World(noa, opts)\n}\n\n\nvar PROFILE = 0\nvar PROFILE_QUEUES = 0\n\n\nvar defaultOptions = {\n    chunkSize: 24,\n    chunkAddDistance: 3,\n    chunkRemoveDistance: 4\n}\n\n/**\n * Module for managing the world, and its chunks\n * @class noa.world\n * \n * Emits:\n *  * worldDataNeeded  (id, ndarray, x, y, z)\n *  * chunkAdded (chunk)\n *  * chunkChanged (chunk)\n *  * chunkBeingRemoved (id, ndarray, userData)\n */\n\nfunction World(noa, opts) {\n    this.noa = noa\n    opts = Object.assign({}, defaultOptions, opts)\n\n    this.userData = null\n    this.playerChunkLoaded = false\n    this.Chunk = Chunk\n\n    this.chunkSize = opts.chunkSize\n    this.chunkAddDistance = opts.chunkAddDistance\n    this.chunkRemoveDistance = opts.chunkRemoveDistance\n    if (this.chunkRemoveDistance < this.chunkAddDistance) {\n        this.chunkRemoveDistance = this.chunkAddDistance\n    }\n\n    // internals\n    this._chunkIDsToAdd = []\n    this._chunkIDsToRemove = []\n    this._chunkIDsInMemory = []\n    this._chunkIDsToCreate = []\n    this._chunkIDsToMesh = []\n    this._chunkIDsToMeshFirst = []\n    this._maxChunksPendingCreation = 20\n    this._maxChunksPendingMeshing = 20\n    this._maxProcessingPerTick = 9 // ms\n    this._maxProcessingPerRender = 5 // ms\n\n    // triggers a short visit to the meshing queue before renders\n    var self = this\n    noa.on('beforeRender', function () { beforeRender(self) })\n\n    // actual chunk storage - hash size hard coded for now\n    this._chunkHash = ndHash([1024, 1024, 1024])\n\n    // instantiate coord conversion functions based on the chunk size\n    // use bit twiddling if chunk size is a power of 2\n    var cs = this.chunkSize\n    if (cs & cs - 1 === 0) {\n        var shift = Math.log2(cs) | 0\n        var mask = (cs - 1) | 0\n        worldCoordToChunkCoord = coord => (coord >> shift) | 0\n        worldCoordToChunkIndex = coord => (coord & mask) | 0\n    } else {\n        worldCoordToChunkCoord = coord => Math.floor(coord / cs) | 0\n        worldCoordToChunkIndex = coord => (((coord % cs) + cs) % cs) | 0\n    }\n\n}\nWorld.prototype = Object.create(EventEmitter.prototype)\n\nvar worldCoordToChunkCoord\nvar worldCoordToChunkIndex\n\n\n\n\n/*\n *   PUBLIC API \n*/\n\n\n\n/** @param x,y,z */\nWorld.prototype.getBlockID = function (x, y, z) {\n    var chunk = this._getChunkByCoords(x, y, z)\n    if (!chunk) return 0\n\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n    return chunk.get(ix, iy, iz)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockSolidity = function (x, y, z) {\n    var chunk = this._getChunkByCoords(x, y, z)\n    if (!chunk) return 0\n\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n    return !!chunk.getSolidityAt(ix, iy, iz)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockOpacity = function (x, y, z) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockOpacity(id)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockFluidity = function (x, y, z) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockFluidity(id)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockProperties = function (x, y, z) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockProps(id)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockObjectMesh = function (x, y, z) {\n    var chunk = this._getChunkByCoords(x, y, z)\n    if (!chunk) return 0\n\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n    return chunk.getObjectMeshAt(ix, iy, iz)\n}\n\n\n/** @param x,y,z */\nWorld.prototype.setBlockID = function (val, x, y, z) {\n    var i = worldCoordToChunkCoord(x)\n    var j = worldCoordToChunkCoord(y)\n    var k = worldCoordToChunkCoord(z)\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n\n    // if update is on chunk border, update neighbor's padding data too\n    _updateChunkAndBorders(this, i, j, k, this.chunkSize, ix, iy, iz, val)\n}\n\n\n/** @param x,y,z */\nWorld.prototype.isBoxUnobstructed = function (box) {\n    var base = box.base\n    var max = box.max\n    for (var i = Math.floor(base[0]); i < max[0] + 1; i++) {\n        for (var j = Math.floor(base[1]); j < max[1] + 1; j++) {\n            for (var k = Math.floor(base[2]); k < max[2] + 1; k++) {\n                if (this.getBlockSolidity(i, j, k)) return false\n            }\n        }\n    }\n    return true\n}\n\n\n\n\n\nWorld.prototype.tick = function () {\n    profile_hook('start')\n\n    // check player position and needed/unneeded chunks\n    var pos = getPlayerChunkCoords(this)\n    var chunkID = getChunkID(pos[0], pos[1], pos[2])\n    if (chunkID != this._lastPlayerChunkID) {\n        this.emit('playerEnteredChunk', pos[0], pos[1], pos[2])\n        buildChunkAddQueue(this, pos[0], pos[1], pos[2])\n        buildChunkRemoveQueue(this, pos[0], pos[1], pos[2])\n    }\n    this._lastPlayerChunkID = chunkID\n    profile_hook('build queues')\n\n    // process (create or mesh) some chunks. If fast enough, do several\n    profile_queues(this, 'start')\n    var cutoff = performance.now() + this._maxProcessingPerTick\n    var done = false\n    while (!done && (performance.now() < cutoff)) {\n        var d1 = processMeshingQueues(this, false)\n        var d2 = processChunkQueues(this)\n        if (!d2) d2 = processChunkQueues(this)\n        done = d1 && d2\n    }\n    profile_queues(this, 'end')\n\n\n    // track whether the player's local chunk is loaded and ready or not\n    var pChunk = getChunk(this, pos[0], pos[1], pos[2])\n    var okay = !!(pChunk && pChunk.isGenerated && !pChunk.isInvalid)\n    this.playerChunkLoaded = okay\n\n    profile_hook('end')\n}\n\n\n\nfunction beforeRender(self) {\n    // on render, quickly process the high-priority meshing queue\n    // to help avoid flashes of background while neighboring chunks update\n    var cutoff = performance.now() + self._maxProcessingPerRender\n    var done = false\n    while (!done && (performance.now() < cutoff)) {\n        done = processMeshingQueues(self, true)\n    }\n}\n\n\n\n\n/** client should call this after creating a chunk's worth of data (as an ndarray)  \n * If userData is passed in it will be attached to the chunk\n * @param id\n * @param array\n * @param userData\n */\nWorld.prototype.setChunkData = function (id, array, userData) {\n    profile_queues(this, 'received')\n    var arr = parseChunkID(id)\n    var chunk = getChunk(this, arr[0], arr[1], arr[2])\n    // ignore if chunk was invalidated while being prepared\n    if (!chunk || chunk.isInvalid) return\n    chunk.array = array\n    if (userData) chunk.userData = userData\n    chunk.initData()\n    enqueueID(id, this._chunkIDsInMemory)\n    unenqueueID(id, this._chunkIDsToCreate)\n\n    // chunk can now be meshed...\n    this.noa.rendering.prepareChunkForRendering(chunk)\n    enqueueID(id, this._chunkIDsToMesh)\n    this.emit('chunkAdded', chunk)\n}\n\n\n\n\n/*\n * Calling this causes all world chunks to get unloaded and recreated \n * (after receiving new world data from the client). This is useful when\n * you're teleporting the player to a new world, e.g.\n*/\nWorld.prototype.invalidateAllChunks = function () {\n    var toInval = this._chunkIDsInMemory.concat(this._chunkIDsToCreate)\n    for (var id of toInval) {\n        var loc = parseChunkID(id)\n        var chunk = getChunk(this, loc[0], loc[1], loc[2])\n        chunk.isInvalid = true\n    }\n    // this causes chunk queues to get rebuilt next tick\n    this._lastPlayerChunkID = ''\n}\n\n\n\n// debugging\nWorld.prototype.report = function () {\n    console.log('World report - playerChunkLoaded: ', this.playerChunkLoaded)\n    _report(this, '  to add     ', this._chunkIDsToAdd)\n    _report(this, '  to remove: ', this._chunkIDsToRemove)\n    _report(this, '  in memory: ', this._chunkIDsInMemory, true)\n    _report(this, '  creating:  ', this._chunkIDsToCreate)\n    _report(this, '  meshing:   ', this._chunkIDsToMesh.concat(this._chunkIDsToMeshFirst))\n}\nfunction _report(world, name, arr, ext) {\n    var ct = 0, full = 0, empty = 0\n    for (var id of arr) {\n        if (id.size) {\n            if (id.isInvalid) ct++\n            continue\n        }\n        var loc = parseChunkID(id)\n        var chunk = getChunk(world, loc[0], loc[1], loc[2])\n        if (chunk.isInvalid) ct++\n        if (chunk.isFull) full++\n        if (chunk.isEmpty) empty++\n    }\n    var len = (arr.length + '        ').substr(0, 6)\n    var es = (ext) ? [', ', full, ' full, ', empty, ' empty'].join('') : ''\n    console.log(name, len, ct, 'invalid' + es)\n}\n\n\n\n\n/*\n *    INTERNALS\n*/\n\n\n// canonical string ID handling for the i,j,k-th chunk\nfunction getChunkID(i, j, k) {\n    return i + '|' + j + '|' + k\n}\nfunction parseChunkID(id) {\n    var arr = id.split('|')\n    return [parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2])]\n}\n\n// canonical functions to store/retrieve a chunk held in memory\nfunction getChunk(world, i, j, k) {\n    var mi = (i | 0) & 1023\n    var mj = (j | 0) & 1023\n    var mk = (k | 0) & 1023\n    return world._chunkHash.get(mi, mj, mk)\n}\n\nfunction setChunk(world, i, j, k, value) {\n    var mi = (i | 0) & 1023\n    var mj = (j | 0) & 1023\n    var mk = (k | 0) & 1023\n    world._chunkHash.set(mi, mj, mk, value)\n}\n\n\n\nfunction getPlayerChunkCoords(world) {\n    var pos = world.noa.getPlayerPosition()\n    var i = worldCoordToChunkCoord(pos[0])\n    var j = worldCoordToChunkCoord(pos[1])\n    var k = worldCoordToChunkCoord(pos[2])\n    return [i, j, k]\n}\n\n\n// for internal use\nWorld.prototype._getChunkByCoords = function (x, y, z) {\n    var i = worldCoordToChunkCoord(x)\n    var j = worldCoordToChunkCoord(y)\n    var k = worldCoordToChunkCoord(z)\n    return getChunk(this, i, j, k)\n}\n\n\n\n\n// run through chunk tracking queues looking for work to do next\nfunction processChunkQueues(self) {\n    var done = true\n    // both queues are sorted by ascending distance\n    if (self._chunkIDsToRemove.length) {\n        var remove = parseChunkID(self._chunkIDsToRemove.pop())\n        removeChunk(self, remove[0], remove[1], remove[2])\n        profile_queues(self, 'removed')\n        profile_hook('removed')\n        done = false\n    }\n    if (self._chunkIDsToCreate.length >= self._maxChunksPendingCreation) return done\n    // if (self._chunkIDsToMesh.length >= self._maxChunksPendingMeshing) return done\n    if (self._chunkIDsToAdd.length) {\n        var id = self._chunkIDsToAdd.shift()\n        requestNewChunk(self, id)\n        profile_hook('requested')\n        profile_queues(self, 'requested')\n        done = false\n    }\n    return done\n}\n\n\n// similar to above but for chunks waiting to be meshed\nfunction processMeshingQueues(self, firstOnly) {\n    var id\n    if (self._chunkIDsToMeshFirst.length) {\n        id = self._chunkIDsToMeshFirst.pop()\n    } else if (firstOnly) {\n        return true\n    } else if (self._chunkIDsToMesh.length) {\n        id = self._chunkIDsToMesh.pop()\n    } else return true\n\n    var arr = parseChunkID(id)\n    var chunk = getChunk(self, arr[0], arr[1], arr[2])\n    if (chunk.isInvalid) return\n    if (!chunk.isGenerated) {\n        // client code triggered a remesh too early, requeue it\n        self._chunkIDsToMesh.unshift(id)\n        return\n    }\n    chunk.updateMeshes()\n\n    profile_queues(self, 'meshed')\n    profile_hook('meshed')\n    return false\n}\n\n\n\n\n\n\n\n\n\n\n// make a new chunk and emit an event for it to be populated with world data\nfunction requestNewChunk(world, id) {\n    var pos = parseChunkID(id)\n    var i = pos[0]\n    var j = pos[1]\n    var k = pos[2]\n    var size = world.chunkSize\n    var chunk = new Chunk(world.noa, id, i, j, k, size)\n    setChunk(world, i, j, k, chunk)\n    var x = i * size - 1\n    var y = j * size - 1\n    var z = k * size - 1\n    enqueueID(id, world._chunkIDsToCreate)\n    world.emit('worldDataNeeded', id, chunk.array, x, y, z)\n}\n\n\n\n\n// remove a chunk that wound up in the remove queue\nfunction removeChunk(world, i, j, k) {\n    var chunk = getChunk(world, i, j, k)\n    world.emit('chunkBeingRemoved', chunk.id, chunk.array, chunk.userData)\n    world.noa.rendering.disposeChunkForRendering(chunk)\n    chunk.dispose()\n    setChunk(world, i, j, k, 0)\n    unenqueueID(chunk.id, world._chunkIDsInMemory)\n    unenqueueID(chunk.id, world._chunkIDsToMesh)\n    unenqueueID(chunk.id, world._chunkIDsToMeshFirst)\n    // when removing a chunk because it was invalid, arrange for chunk queues to get rebuilt\n    if (chunk.isInvalid) world._lastPlayerChunkID = ''\n}\n\n\n\n\n\n// for a given chunk (i/j/k) and local location (x/y/z), \n// update all chunks that need it (including border chunks with the \n// changed block in their 1-block padding)\n\nfunction _updateChunkAndBorders(world, i, j, k, size, x, y, z, val) {\n    var ilocs = [0]\n    var jlocs = [0]\n    var klocs = [0]\n    if (x === 0) { ilocs.push(-1) } else if (x === size - 1) { ilocs.push(1) }\n    if (y === 0) { jlocs.push(-1) } else if (y === size - 1) { jlocs.push(1) }\n    if (z === 0) { klocs.push(-1) } else if (z === size - 1) { klocs.push(1) }\n\n    for (var di of ilocs) {\n        var lx = [size, x, -1][di + 1]\n        for (var dj of jlocs) {\n            var ly = [size, y, -1][dj + 1]\n            for (var dk of klocs) {\n                var lz = [size, z, -1][dk + 1]\n                _modifyBlockData(world,\n                    i + di, j + dj, k + dk,\n                    lx, ly, lz, val)\n            }\n        }\n    }\n}\n\n\n\n// internal function to modify a chunk's block\n\nfunction _modifyBlockData(world, i, j, k, x, y, z, val) {\n    var chunk = getChunk(world, i, j, k)\n    if (!chunk) return\n    chunk.set(x, y, z, val)\n    enqueueID(chunk.id, world._chunkIDsToMeshFirst)\n    world.emit('chunkChanged', chunk)\n}\n\n\n\n\n// rebuild queue of chunks to be added around (ci,cj,ck)\nfunction buildChunkAddQueue(world, ci, cj, ck) {\n    var add = Math.ceil(world.chunkAddDistance)\n    var pending = world._chunkIDsToCreate\n    var queue = []\n    var distArr = []\n\n    var addDistSq = world.chunkAddDistance * world.chunkAddDistance\n    for (var i = ci - add; i <= ci + add; ++i) {\n        for (var j = cj - add; j <= cj + add; ++j) {\n            for (var k = ck - add; k <= ck + add; ++k) {\n                var di = i - ci\n                var dj = j - cj\n                var dk = k - ck\n                var distSq = di * di + dj * dj + dk * dk\n                if (distSq > addDistSq) continue\n\n                if (getChunk(world, i, j, k)) continue\n                var id = getChunkID(i, j, k)\n                if (pending.indexOf(id) > -1) continue\n                queue.push(id)\n                distArr.push(distSq)\n            }\n        }\n    }\n    world._chunkIDsToAdd = sortByReferenceArray(queue, distArr)\n}\n\n\n// rebuild queue of chunks to be removed from around (ci,cj,ck)\nfunction buildChunkRemoveQueue(world, ci, cj, ck) {\n    var remDistSq = world.chunkRemoveDistance * world.chunkRemoveDistance\n    var list = world._chunkIDsInMemory\n    var queue = []\n    var distArr = []\n\n    for (var i = 0; i < list.length; i++) {\n        var id = list[i]\n        var loc = parseChunkID(id)\n        var di = loc[0] - ci\n        var dj = loc[1] - cj\n        var dk = loc[2] - ck\n        var distSq = di * di + dj * dj + dk * dk\n        if (distSq < remDistSq) {\n            var chunk = getChunk(world, loc[0], loc[1], loc[2])\n            if (!chunk.isInvalid) continue\n            distSq *= -1 // rig sort so that invalidated chunks get removed first\n        }\n        queue.push(id)\n        distArr.push(distSq)\n    }\n    world._chunkIDsToRemove = sortByReferenceArray(queue, distArr)\n}\n\n\n\n// sorts [A, B, C] and [3, 1, 2] into [B, C, A]\nfunction sortByReferenceArray(data, ref) {\n    var ind = Object.keys(ref)\n    ind.sort((i, j) => ref[i] - ref[j])\n    return ind.map(i => data[i])\n}\n\n\n\n\n\n// uniquely enqueue a string id into an array of them\nfunction enqueueID(id, queue) {\n    var i = queue.indexOf(id)\n    if (i >= 0) return\n    queue.push(id)\n}\n\n// remove string id from queue if it exists\nfunction unenqueueID(id, queue) {\n    var i = queue.indexOf(id)\n    if (i >= 0) queue.splice(i, 1)\n}\n\n\n\n\n\nvar profile_queues = function (w, s) { }\nif (PROFILE_QUEUES) (function () {\n    var every = 100\n    var iter = 0\n    var t, nrem, nreq, totalrec, nmesh\n    var reqcts, remcts, meshcts\n    var qadd, qrem, qmem, qgen, qmesh\n    profile_queues = function (world, state) {\n        if (state === 'start') {\n            if (iter === 0) {\n                t = performance.now()\n                qadd = qrem = qmem = qgen = qmesh = 0\n                totalrec = 0\n                remcts = []\n                reqcts = []\n                meshcts = []\n            }\n            iter++\n            nrem = nreq = nmesh = 0\n        } else if (state === 'removed') {\n            nrem++\n        } else if (state === 'received') {\n            totalrec++\n        } else if (state === 'requested') {\n            nreq++\n        } else if (state === 'meshed') {\n            nmesh++\n        } else if (state === 'end') {\n            // counts for frames that were fully worked\n            if (world._chunkIDsToAdd.length) reqcts.push(nreq)\n            if (world._chunkIDsToRemove.length) remcts.push(nrem)\n            if (world._chunkIDsToMesh.length + world._chunkIDsToMeshFirst.length) meshcts.push(nmesh)\n            // avg queue sizes\n            qadd += world._chunkIDsToAdd.length\n            qrem += world._chunkIDsToRemove.length\n            qmem += world._chunkIDsInMemory.length\n            qgen += world._chunkIDsToCreate.length\n            qmesh += world._chunkIDsToMesh.length + world._chunkIDsToMeshFirst.length\n            // on end\n            if (iter === every) {\n                var dt = (performance.now() - t) / 1000\n                console.log('world chunk queues:',\n                    'made', rnd(totalrec / dt), 'cps',\n                    '- avg queuelen: ',\n                    'add', qadd / every,\n                    'rem', qrem / every,\n                    'mem', qmem / every,\n                    'gen', qgen / every,\n                    'mesh', qmesh / every,\n                    '- work/frame: ',\n                    'req', rnd(reqcts.reduce(sum, 0) / reqcts.length),\n                    'rem', rnd(remcts.reduce(sum, 0) / remcts.length),\n                    'mesh', rnd(meshcts.reduce(sum, 0) / meshcts.length)\n                )\n                iter = 0\n            }\n        }\n    }\n    var sum = function (num, prev) { return num + prev }\n    var rnd = function (n) { return Math.round(n * 10) / 10 }\n})()\n\n\nvar profile_hook = function (s) { }\nif (PROFILE) (function () {\n    var every = 200\n    var timer = new (__webpack_require__(/*! ./util */ \"../../src/lib/util.js\").Timer)(every, 'world ticks')\n    profile_hook = function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n\n\n//# sourceURL=webpack:////home/sasogu/web/EduCraft/src/lib/world.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* globals BABYLON */\n\n\n\n/**\n * Classic-inspired testbed.\n */\n\nvar noaEngine = __webpack_require__(/*! ../.. */ \"../../src/index.js\")\nvar createRegistry = __webpack_require__(/*! ./registry */ \"./registry.js\")\nvar storage = __webpack_require__(/*! ./storage */ \"./storage.js\")\n\nvar opts = {\n\tdebug: true,\n\tshowFPS: true,\n\tinverseY: true,\n\tchunkSize: 32,\n\tchunkAddDistance: 2,\n\tchunkRemoveDistance: 3,\n\tblockTestDistance: 40,\n\ttexturePath: 'textures/',\n\tplayerStart: [0.5, 6, 0.5],\n\tplayerHeight: 1.6,\n\tplayerWidth: 0.6,\n\tplayerAutoStep: true,\n\tuseAO: false,\n}\n\n\n// create engine\nvar noa = noaEngine(opts)\nvar scene = noa.rendering.getScene()\n\nvar multiplayer = setupMultiplayer(noa, scene)\n\nscene.clearColor = new BABYLON.Color4(0.62, 0.82, 1.0, 1.0)\nscene.fogMode = BABYLON.Scene.FOGMODE_LINEAR\nscene.fogColor = new BABYLON.Color3(0.62, 0.82, 1.0)\nscene.fogStart = 24\nscene.fogEnd = 80\n\nvar light = new BABYLON.HemisphericLight('sun', new BABYLON.Vector3(0.3, 1, 0.4), scene)\nlight.intensity = 0.9\n\nnoa.inputs.unbind('alt-fire')\nnoa.inputs.bind('alt-fire', '<mouse 3>')\n\n\n//\t\tWorld generation\n\n\n// block registry\nvar registry = createRegistry(noa, scene)\nvar blockCatalog = registry.blockCatalog\nvar musicBlocks = registry.musicBlocks\nvar grassID = registry.ids.grassID\nvar dirtID = registry.ids.dirtID\nvar stoneID = registry.ids.stoneID\nvar brickID = registry.ids.brickID\nvar woodID = registry.ids.woodID\nvar plankID = registry.ids.plankID\nvar sandID = registry.ids.sandID\nvar gravelID = registry.ids.gravelID\nvar leavesID = registry.ids.leavesID\nvar glassID = registry.ids.glassID\nvar waterID = registry.ids.waterID\nvar fenceID = registry.ids.fenceID\n\nfunction setupMultiplayer(noa, scene) {\n\tvar params = new URLSearchParams(window.location.search)\n\tvar serverUrl = params.get('server')\n\tvar playerName = params.get('name') || params.get('player')\n\tvar proto = window.location.protocol === 'https:' ? 'wss' : 'ws'\n\tif (!serverUrl) serverUrl = proto + '://' + window.location.host + '/ws'\n\n\tvar socket = null\n\tvar clientId = null\n\tvar remotePlayers = {}\n\tvar reconnectTimer = null\n\tvar pingTimer = null\n\tvar sendCooldown = 0\n\tvar snapshotDelay = 120\n\n\tfunction send(msg) {\n\t\tif (socket && socket.readyState === WebSocket.OPEN) {\n\t\t\tsocket.send(JSON.stringify(msg))\n\t\t}\n\t}\n\n\tfunction scheduleReconnect() {\n\t\tif (reconnectTimer) return\n\t\treconnectTimer = setTimeout(function () {\n\t\t\treconnectTimer = null\n\t\t\tconnect()\n\t\t}, 2000)\n\t}\n\n\tfunction connect() {\n\t\tif (socket && socket.readyState === WebSocket.OPEN) return\n\t\tsocket = new WebSocket(serverUrl)\n\n\t\tsocket.addEventListener('open', function () {\n\t\t\tsend({ type: 'hello', v: 1, name: playerName || 'Player' })\n\t\t\tif (pingTimer) clearInterval(pingTimer)\n\t\t\tpingTimer = setInterval(function () {\n\t\t\t\tsend({ type: 'ping', v: 1, t: Date.now() })\n\t\t\t}, 5000)\n\t\t})\n\n\t\tsocket.addEventListener('message', function (event) {\n\t\t\tvar msg = {}\n\t\t\ttry {\n\t\t\t\tmsg = JSON.parse(event.data)\n\t\t\t} catch (err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (!msg || msg.v !== 1 || typeof msg.type !== 'string') return\n\n\t\t\tif (msg.type === 'welcome') {\n\t\t\t\tclientId = msg.id\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (msg.type === 'snapshot' && Array.isArray(msg.players)) {\n\t\t\t\tvar seen = {}\n\t\t\t\tmsg.players.forEach(function (player) {\n\t\t\t\t\tif (!player || player.id === clientId) return\n\t\t\t\t\tseen[player.id] = true\n\t\t\t\t\tupsertRemotePlayer(player)\n\t\t\t\t})\n\t\t\t\tObject.keys(remotePlayers).forEach(function (id) {\n\t\t\t\t\tif (!seen[id]) removeRemotePlayer(id)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (msg.type === 'delta' && Array.isArray(msg.players)) {\n\t\t\t\tmsg.players.forEach(function (player) {\n\t\t\t\t\tif (!player || player.id === clientId) return\n\t\t\t\t\tupsertRemotePlayer(player)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (msg.type === 'playerLeft' && msg.id) {\n\t\t\t\tremoveRemotePlayer(msg.id)\n\t\t\t}\n\t\t})\n\n\t\tsocket.addEventListener('close', function () {\n\t\t\tif (pingTimer) {\n\t\t\t\tclearInterval(pingTimer)\n\t\t\t\tpingTimer = null\n\t\t\t}\n\t\t\tscheduleReconnect()\n\t\t})\n\n\t\tsocket.addEventListener('error', function () {\n\t\t\tscheduleReconnect()\n\t\t})\n\t}\n\n\tfunction upsertRemotePlayer(player) {\n\t\tvar entry = remotePlayers[player.id]\n\t\tif (!entry) {\n\t\t\tvar size = noa.entities.getPositionData(noa.playerEntity)\n\t\t\tvar mesh = createRemoteMesh(player.id, scene)\n\t\t\tvar eid = noa.entities.add([player.x, player.y, player.z], size.width, size.height, mesh, [0, size.height / 2, 0], false, false)\n\t\t\tentry = {\n\t\t\t\teid: eid,\n\t\t\t\tmesh: mesh,\n\t\t\t\tlast: { x: player.x, y: player.y, z: player.z },\n\t\t\t\ttarget: { x: player.x, y: player.y, z: player.z },\n\t\t\t\tlastUpdate: Date.now(),\n\t\t\t}\n\t\t\tremotePlayers[player.id] = entry\n\t\t}\n\t\tentry.last = { x: entry.target.x, y: entry.target.y, z: entry.target.z }\n\t\tentry.target = { x: player.x, y: player.y, z: player.z }\n\t\tentry.lastUpdate = Date.now()\n\t}\n\n\tfunction removeRemotePlayer(id) {\n\t\tvar entry = remotePlayers[id]\n\t\tif (!entry) return\n\t\tnoa.entities.deleteEntity(entry.eid, true)\n\t\tdelete remotePlayers[id]\n\t}\n\n\tfunction createRemoteMesh(id, scene) {\n\t\tvar mesh = BABYLON.Mesh.CreateBox('remote-' + id, 1, scene)\n\t\tmesh.isPickable = false\n\t\tvar mat = new BABYLON.StandardMaterial('remote-mat-' + id, scene)\n\t\tvar color = colorFromId(id)\n\t\tmat.diffuseColor = new BABYLON.Color3(color.r, color.g, color.b)\n\t\tmesh.material = mat\n\t\treturn mesh\n\t}\n\n\tfunction colorFromId(id) {\n\t\tvar hash = 0\n\t\tfor (var i = 0; i < id.length; i++) {\n\t\t\thash = (hash << 5) - hash + id.charCodeAt(i)\n\t\t\thash |= 0\n\t\t}\n\t\treturn {\n\t\t\tr: ((hash >> 16) & 255) / 255,\n\t\t\tg: ((hash >> 8) & 255) / 255,\n\t\t\tb: (hash & 255) / 255,\n\t\t}\n\t}\n\n\tfunction tick(dt) {\n\t\tsendCooldown -= dt\n\t\tif (sendCooldown > 0) return\n\t\tsendCooldown = 60\n\n\t\tif (!socket || socket.readyState !== WebSocket.OPEN) return\n\t\tvar pos = noa.entities.getPositionData(noa.playerEntity).position\n\t\tsend({ type: 'move', v: 1, x: pos[0], y: pos[1], z: pos[2] })\n\t}\n\n\tfunction lerp(a, b, t) {\n\t\treturn a + (b - a) * t\n\t}\n\n\tfunction updateRemotes() {\n\t\tvar now = Date.now()\n\t\tObject.keys(remotePlayers).forEach(function (id) {\n\t\t\tvar entry = remotePlayers[id]\n\t\t\tvar elapsed = now - entry.lastUpdate\n\t\t\tvar t = Math.min(1, Math.max(0, (elapsed + snapshotDelay) / snapshotDelay))\n\t\t\tvar x = lerp(entry.last.x, entry.target.x, t)\n\t\t\tvar y = lerp(entry.last.y, entry.target.y, t)\n\t\t\tvar z = lerp(entry.last.z, entry.target.z, t)\n\t\t\tnoa.entities.setPosition(entry.eid, x, y, z)\n\t\t})\n\t}\n\n\tconnect()\n\n\treturn { tick: tick, updateRemotes: updateRemotes }\n}\n\n\nvar defaultHotbarLabels = [\n\t'Do4 Negra',\n\t'Re4 Negra',\n\t'Mi4 Negra',\n\t'Fa4 Negra',\n\t'Sol4 Negra',\n\t'La4 Negra',\n\t'Si4 Negra',\n\t'Silencio Negra',\n\t'Do5 Negra',\n]\n\n\n// add a listener for when the engine requests a new world chunk\n// `data` is an ndarray - see https://github.com/scijs/ndarray\nnoa.world.on('worldDataNeeded', function (id, data, x, y, z) {\n\t// populate ndarray with world data (block IDs or 0 for air)\n\tfor (var i = 0; i < data.shape[0]; ++i) {\n\t\tfor (var k = 0; k < data.shape[2]; ++k) {\n\t\t\tvar worldX = x + i\n\t\t\tvar worldZ = z + k\n\t\t\tfor (var j = 0; j < data.shape[1]; ++j) {\n\t\t\t\tvar worldY = y + j\n\t\t\t\tvar block = decideBlock(worldX, worldY, worldZ)\n\t\t\t\tif (block) data.set(i, j, k, block)\n\t\t\t}\n\t\t}\n\t}\n\t// pass the finished data back to the game engine\n\tnoa.world.setChunkData(id, data)\n})\n\nvar baseHeight = 4\nvar treeSpacing = 6\nvar treeHeight = 4\nvar waterLevel = baseHeight - 1\n\nfunction getEditKey(x, y, z) {\n\treturn x + '|' + y + '|' + z\n}\n\nfunction getEditBlock(x, y, z) {\n\tvar key = getEditKey(x, y, z)\n\tif (Object.prototype.hasOwnProperty.call(worldEdits, key)) {\n\t\treturn worldEdits[key]\n\t}\n\treturn null\n}\n\nfunction decideBlock(x, y, z) {\n\tvar edit = getEditBlock(x, y, z)\n\tif (edit !== null) return edit\n\n\tvar surface = getHeight(x, z)\n\n\tif (y < surface) {\n\t\tif (y === surface - 1) {\n\t\t\tif (surface <= waterLevel + 1) return sandID\n\t\t\treturn grassID\n\t\t}\n\t\tif (y >= surface - 3) return dirtID\n\t\treturn stoneID\n\t}\n\n\tif (y <= waterLevel) return waterID\n\n\tif (isTreeSpot(x, z, surface)) {\n\t\tvar trunkBase = surface\n\t\tif (y >= trunkBase && y < trunkBase + treeHeight) return woodID\n\t\tif (y >= trunkBase + treeHeight - 1 && y <= trunkBase + treeHeight + 1) {\n\t\t\tvar dx = Math.abs((x % treeSpacing + treeSpacing) % treeSpacing - 1)\n\t\t\tvar dz = Math.abs((z % treeSpacing + treeSpacing) % treeSpacing - 1)\n\t\t\tif (dx <= 2 && dz <= 2) return leavesID\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunction getHeight(x, z) {\n\tvar h = baseHeight\n\th += Math.floor(Math.sin(x / 12) * 2 + Math.cos(z / 14) * 2)\n\th += Math.floor(Math.sin((x + z) / 18) * 1.5)\n\treturn Math.max(2, h)\n}\n\nfunction isTreeSpot(x, z, surface) {\n\tif (surface <= waterLevel + 1) return false\n\tvar hash = Math.abs((x * 73856093) ^ (z * 19349663))\n\treturn (hash % 100) < 6 && (x % treeSpacing === 1 && z % treeSpacing === 1)\n}\n\n\n// \t\tadd a mesh to represent the player\n\n\n// get the player entity's ID and other info (aabb, size)\nvar eid = noa.playerEntity\nvar dat = noa.entities.getPositionData(eid)\nvar w = dat.width\nvar h = dat.height\n\n// make a Babylon.js mesh and scale it, etc.\nvar playerMesh = BABYLON.Mesh.CreateBox('player', 1, scene)\nplayerMesh.scaling.x = playerMesh.scaling.z = w\nplayerMesh.scaling.y = h\n\n// offset of mesh relative to the entity's \"position\" (center of its feet)\nvar offset = [0, h / 2, 0]\n\n// a \"mesh\" component to the player entity\nnoa.entities.addComponent(eid, noa.entities.names.mesh, {\n\tmesh: playerMesh,\n\toffset: offset\n})\n\n\n\n\n// \t\tInteractivity:\n\nfunction applyBlockEdit(blockId, position) {\n\tvar key = getEditKey(position[0], position[1], position[2])\n\tworldEdits[key] = blockId\n\tscheduleSaveWorld()\n\tif (blockId === 0) {\n\t\tnoa.setBlock(0, position)\n\t} else {\n\t\tnoa.addBlock(blockId, position)\n\t}\n}\n\n\n// on left mouse, set targeted block to be air\nnoa.inputs.down.on('fire', function () {\n\tif (noa.targetedBlock) {\n\t\tplayMusicBlock(noa.targetedBlock.blockID)\n\t\tapplyBlockEdit(0, noa.targetedBlock.position)\n\t}\n})\n\n// place block on alt-fire (RMB)\nnoa.inputs.down.on('alt-fire', function () {\n\tif (noa.targetedBlock) {\n\t\tapplyBlockEdit(pickedID, noa.targetedBlock.adjacent)\n\t\tplayMusicBlock(pickedID)\n\t}\n})\n\n// pick block on middle fire (MMB)\nnoa.inputs.down.on('mid-fire', function () {\n\tif (noa.targetedBlock) setSelectedById(noa.targetedBlock.blockID)\n})\n\nnoa.inputs.bind('play-note', 'R')\nnoa.inputs.down.on('play-note', function () {\n\tif (noa.targetedBlock) playMusicBlock(noa.targetedBlock.blockID)\n})\n\n\n// classic-ish UI + inventory\nvar ui = {\n\thotbar: document.getElementById('hotbar'),\n\tinventory: document.getElementById('inventory'),\n\tinventoryGrid: document.getElementById('inventory-grid'),\n\tblockName: document.getElementById('block-name'),\n\tplayerPos: document.getElementById('player-pos'),\n\tmodeStatus: document.getElementById('mode-status'),\n\tmusicStatus: document.getElementById('music-status'),\n\tmusicFeedback: document.getElementById('music-feedback'),\n\tmusicPulse: document.getElementById('music-pulse'),\n\taudioHint: document.getElementById('audio-hint'),\n\tclassroom: document.getElementById('classroom'),\n\tclassroomLevel: document.getElementById('classroom-level'),\n\tclassroomScore: document.getElementById('classroom-score'),\n\tclassroomProgress: document.getElementById('classroom-progress'),\n\tclassroomSeq: document.getElementById('classroom-seq'),\n\tclassroomStatus: document.getElementById('classroom-status'),\n\tclassroomStart: document.getElementById('classroom-start'),\n\tclassroomPlay: document.getElementById('classroom-play'),\n\tclassroomReset: document.getElementById('classroom-reset'),\n\tclassroomToggle: document.getElementById('classroom-toggle'),\n}\n\nvar hotbarSlots = getDefaultHotbar()\nvar hotbarEls = []\nvar inventoryEls = []\nvar selectedIndex = 0\nvar pickedID = hotbarSlots[0].id\nvar creativeMode = true\nvar musicFeedbackTimer = null\nvar musicPulseTimer = null\nvar audioState = { ctx: null }\nvar audioReady = false\nvar lastStepBlockId = null\nvar lastStepTime = 0\nvar rewardPlaced = false\nvar classroom = {\n\tenabled: false,\n\tlevelIndex: -1,\n\tscore: 0,\n\tsequence: [],\n\tinputIndex: 0,\n\tplaying: false,\n\tallowInput: false,\n\ttimeouts: [],\n}\n\nvar classroomLevels = [\n\t{ name: 'Eco 1', length: 3, notes: ['Do4', 'Re4', 'Mi4'], rhythms: ['Negra'], allowRest: false },\n\t{ name: 'Eco 2', length: 4, notes: ['Do4', 'Re4', 'Mi4', 'Fa4', 'Sol4'], rhythms: ['Negra'], allowRest: false },\n\t{ name: 'Eco 3', length: 5, notes: ['Do4', 'Re4', 'Mi4', 'Fa4', 'Sol4'], rhythms: ['Negra', 'Blanca'], allowRest: false },\n\t{ name: 'Eco 4', length: 6, notes: ['Do4', 'Re4', 'Mi4', 'Fa4', 'Sol4', 'La4', 'Si4'], rhythms: ['Negra', 'Corchea'], allowRest: false },\n\t{ name: 'Eco 5', length: 7, notes: ['Do4', 'Re4', 'Mi4', 'Fa4', 'Sol4', 'La4', 'Si4', 'Do5'], rhythms: ['Negra', 'Corchea'], allowRest: true },\n\t{ name: 'Eco 6', length: 8, notes: ['Do4', 'Re4', 'Mi4', 'Fa4', 'Sol4', 'La4', 'Si4', 'Do5', 'Re5'], rhythms: ['Blanca', 'Negra', 'Corchea'], allowRest: true },\n]\n\nvar worldName = getWorldName()\nvar worldEdits = {}\nvar saveSettingsTimer = null\nvar saveWorldTimer = null\nvar editsApplied = false\n\ninitLocalState()\n\nfunction setupClassroom() {\n\tif (ui.classroomStart) ui.classroomStart.addEventListener('click', startClassroom)\n\tif (ui.classroomPlay) ui.classroomPlay.addEventListener('click', playSequence)\n\tif (ui.classroomReset) ui.classroomReset.addEventListener('click', resetClassroom)\n\tif (ui.classroomToggle) ui.classroomToggle.addEventListener('click', function () {\n\t\ttoggleClassroom(false)\n\t})\n}\n\nfunction toggleClassroom(force) {\n\tvar open = (typeof force === 'boolean') ? force : !ui.classroom.classList.contains('open')\n\tui.classroom.classList.toggle('open', open)\n\tscheduleSaveSettings()\n}\n\nfunction getWorldName() {\n\tvar params = new URLSearchParams(window.location.search)\n\treturn params.get('world') || 'default'\n}\n\nfunction initLocalState() {\n\tstorage.getSettings()\n\t\t.then(function (settings) {\n\t\t\tapplySettings(settings)\n\t\t\treturn storage.getWorldEdits(worldName)\n\t\t})\n\t\t.then(function (edits) {\n\t\t\tif (edits) worldEdits = edits\n\t\t\tbuildHotbar()\n\t\t\tbuildInventory()\n\t\t\tselectSlot(selectedIndex)\n\t\t\tsetCreativeMode(creativeMode)\n\t\t\tsetupClassroom()\n\t\t\ttoggleClassroom(settingsClassroomOpen())\n\t\t\tapplySavedEdits()\n\t\t})\n\t\t.catch(function () {\n\t\t\tbuildHotbar()\n\t\t\tbuildInventory()\n\t\t\tselectSlot(selectedIndex)\n\t\t\tsetCreativeMode(creativeMode)\n\t\t\tsetupClassroom()\n\t\t\ttoggleClassroom(true)\n\t\t})\n}\n\nfunction applySettings(settings) {\n\tif (!settings) return\n\tif (Array.isArray(settings.hotbar)) {\n\t\thotbarSlots = settings.hotbar.map(function (id) {\n\t\t\treturn getBlockById(id) || blockCatalog[0]\n\t\t})\n\t}\n\tif (typeof settings.selectedIndex === 'number') {\n\t\tselectedIndex = Math.max(0, Math.min(8, settings.selectedIndex))\n\t}\n\tif (typeof settings.creativeMode === 'boolean') {\n\t\tcreativeMode = settings.creativeMode\n\t}\n\tif (typeof settings.classroomOpen === 'boolean') {\n\t\tclassroom._open = settings.classroomOpen\n\t}\n}\n\nfunction settingsClassroomOpen() {\n\tif (typeof classroom._open === 'boolean') return classroom._open\n\treturn true\n}\n\nfunction collectSettings() {\n\treturn {\n\t\thotbar: hotbarSlots.map(function (slot) { return slot.id }),\n\t\tselectedIndex: selectedIndex,\n\t\tcreativeMode: creativeMode,\n\t\tclassroomOpen: ui.classroom.classList.contains('open')\n\t}\n}\n\nfunction scheduleSaveSettings() {\n\tif (saveSettingsTimer) clearTimeout(saveSettingsTimer)\n\tsaveSettingsTimer = setTimeout(function () {\n\t\tstorage.saveSettings(collectSettings())\n\t\tsaveSettingsTimer = null\n\t}, 500)\n}\n\nfunction scheduleSaveWorld() {\n\tif (saveWorldTimer) clearTimeout(saveWorldTimer)\n\tsaveWorldTimer = setTimeout(function () {\n\t\tstorage.saveWorldEdits(worldName, worldEdits)\n\t\tsaveWorldTimer = null\n\t}, 1000)\n}\n\nfunction applySavedEdits() {\n\tif (editsApplied) return\n\teditsApplied = true\n\tvar keys = Object.keys(worldEdits)\n\tif (!keys.length) return\n\tkeys.forEach(function (key) {\n\t\tvar parts = key.split('|').map(Number)\n\t\tif (parts.length !== 3) return\n\t\tnoa.setBlock(worldEdits[key], parts)\n\t})\n}\n\nfunction buildHotbar() {\n\thotbarSlots.forEach(function (block, index) {\n\t\tvar slot = document.createElement('div')\n\t\tslot.className = 'slot'\n\t\tslot.dataset.index = index\n\t\tslot.appendChild(makeIcon(block))\n\n\t\tvar key = document.createElement('div')\n\t\tkey.className = 'key'\n\t\tkey.textContent = index + 1\n\t\tslot.appendChild(key)\n\n\t\tui.hotbar.appendChild(slot)\n\t\thotbarEls.push(slot)\n\t})\n}\n\nfunction buildInventory() {\n\tblockCatalog.forEach(function (block) {\n\t\tif (block.locked) return\n\t\taddInventoryItem(block)\n\t})\n}\n\nfunction createInventoryItem(block) {\n\tvar item = document.createElement('div')\n\titem.className = 'inventory-item'\n\titem.dataset.blockId = block.id\n\titem.appendChild(makeIcon(block))\n\n\tvar label = document.createElement('div')\n\tlabel.className = 'label'\n\tlabel.textContent = block.name\n\titem.appendChild(label)\n\n\titem.addEventListener('click', function () {\n\t\tsetSelectedById(block.id)\n\t\ttoggleInventory(false)\n\t})\n\n\treturn item\n}\n\nfunction addInventoryItem(block) {\n\tif (!ui.inventoryGrid) return\n\tvar item = createInventoryItem(block)\n\tui.inventoryGrid.appendChild(item)\n\tinventoryEls.push(item)\n}\n\nfunction unlockBlockByName(name) {\n\tfor (var i = 0; i < blockCatalog.length; i++) {\n\t\tvar block = blockCatalog[i]\n\t\tif (block.name === name) {\n\t\t\tif (!block.locked) return false\n\t\t\tblock.locked = false\n\t\t\taddInventoryItem(block)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunction makeIcon(block) {\n\tvar iconEl = document.createElement('div')\n\ticonEl.className = 'icon'\n\tif (block.icon.type === 'texture') {\n\t\ticonEl.style.backgroundImage = 'url(textures/' + block.icon.value + ')'\n\t} else if (block.icon.type === 'data') {\n\t\ticonEl.style.backgroundImage = 'url(' + block.icon.value + ')'\n\t} else {\n\t\ticonEl.style.backgroundColor = block.icon.value\n\t}\n\tif (block.music) {\n\t\tvar badge = document.createElement('div')\n\t\tbadge.className = 'music-badge'\n\t\tbadge.textContent = block.music.isRest ? 'SIL' : block.music.note\n\t\ticonEl.appendChild(badge)\n\n\t\tvar rhythmClass = rhythmClassFor(block.music.rhythm)\n\t\tif (block.music.isRest) {\n\t\t\tvar rest = document.createElement('div')\n\t\t\trest.className = 'rhythm-rest'\n\t\t\ticonEl.appendChild(rest)\n\t\t} else if (rhythmClass) {\n\t\t\tvar rhythm = document.createElement('div')\n\t\t\trhythm.className = 'rhythm-icon ' + rhythmClass\n\t\t\tif (rhythmClass === 'rhythm-eighth') {\n\t\t\t\tvar flag = document.createElement('div')\n\t\t\t\tflag.className = 'flag'\n\t\t\t\trhythm.appendChild(flag)\n\t\t\t}\n\t\t\ticonEl.appendChild(rhythm)\n\t\t}\n\t}\n\treturn iconEl\n}\n\nfunction rhythmClassFor(rhythmName) {\n\tif (rhythmName === 'Negra') return 'rhythm-quarter'\n\tif (rhythmName === 'Blanca') return 'rhythm-half'\n\tif (rhythmName === 'Corchea') return 'rhythm-eighth'\n\treturn ''\n}\n\nfunction selectSlot(index) {\n\tselectedIndex = (index + hotbarSlots.length) % hotbarSlots.length\n\tpickedID = hotbarSlots[selectedIndex].id\n\thotbarEls.forEach(function (el, i) {\n\t\tif (i === selectedIndex) el.classList.add('selected')\n\t\telse el.classList.remove('selected')\n\t})\n\tupdateStatus()\n\tscheduleSaveSettings()\n}\n\nfunction setSelectedById(blockId) {\n\tfor (var i = 0; i < hotbarSlots.length; i++) {\n\t\tif (hotbarSlots[i].id === blockId) {\n\t\t\tselectSlot(i)\n\t\t\treturn\n\t\t}\n\t}\n\thotbarSlots[selectedIndex] = getBlockById(blockId)\n\tupdateHotbarSlot(selectedIndex)\n\tselectSlot(selectedIndex)\n\tscheduleSaveSettings()\n}\n\nfunction updateStatus() {\n\tvar blockName = 'Bloque: ' + (getBlockName(pickedID) || '--')\n\tui.blockName.textContent = blockName\n\tui.modeStatus.textContent = 'Modo: ' + (creativeMode ? 'Creativo' : 'Survival')\n\tui.musicStatus.textContent = 'Musica: ' + (getMusicLabel(pickedID) || '--')\n}\n\nfunction getBlockName(blockId) {\n\tfor (var i = 0; i < blockCatalog.length; i++) {\n\t\tif (blockCatalog[i].id === blockId) return blockCatalog[i].name\n\t}\n\treturn null\n}\n\nfunction getMusicLabel(blockId) {\n\tvar music = musicBlocks[blockId]\n\tif (!music) return null\n\treturn formatMusicLabel(music)\n}\n\nfunction formatMusicLabel(music) {\n\tif (music.isRest) return music.label\n\tif (!music.noteName || !music.noteOctave) return music.label\n\tif (music.noteLetter) {\n\t\treturn music.noteName + music.noteOctave + ' (' + music.noteLetter + music.noteOctave + ') ' + music.rhythm\n\t}\n\treturn music.noteName + music.noteOctave + ' ' + music.rhythm\n}\n\nfunction getBlockById(blockId) {\n\tfor (var i = 0; i < blockCatalog.length; i++) {\n\t\tif (blockCatalog[i].id === blockId) return blockCatalog[i]\n\t}\n\treturn blockCatalog[0]\n}\n\nfunction getDefaultHotbar() {\n\tvar slots = []\n\tfor (var i = 0; i < defaultHotbarLabels.length; i++) {\n\t\tvar label = defaultHotbarLabels[i]\n\t\tfor (var j = 0; j < blockCatalog.length; j++) {\n\t\t\tif (blockCatalog[j].name === label) {\n\t\t\t\tslots.push(blockCatalog[j])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\twhile (slots.length < 9) {\n\t\tslots.push(blockCatalog[slots.length] || blockCatalog[0])\n\t}\n\treturn slots.slice(0, 9)\n}\n\nfunction startClassroom() {\n\tclassroom.enabled = true\n\tclassroom.levelIndex = 0\n\tclassroom.score = 0\n\tclassroom.inputIndex = 0\n\tsetLevel(classroom.levelIndex)\n\tupdateClassroomUI()\n\tsetClassroomStatus('Escucha la secuencia y repitela.')\n\tplaySequence()\n}\n\nfunction resetClassroom() {\n\tclassroom.enabled = false\n\tclassroom.levelIndex = -1\n\tclassroom.score = 0\n\tclassroom.sequence = []\n\tclassroom.inputIndex = 0\n\tclassroom.playing = false\n\tclassroom.allowInput = false\n\tclearClassroomTimers()\n\tupdateClassroomUI()\n\tsetClassroomStatus('Pulsa Empezar para iniciar el reto.')\n}\n\nfunction setLevel(index) {\n\tclassroom.levelIndex = index\n\tclassroom.sequence = buildSequence(classroomLevels[index])\n\tclassroom.inputIndex = 0\n\tupdateClassroomUI()\n}\n\nfunction buildSequence(level) {\n\tvar pool = buildPool(level)\n\tvar sequence = []\n\tfor (var i = 0; i < level.length; i++) {\n\t\tvar pick = pool[Math.floor(Math.random() * pool.length)]\n\t\tsequence.push(pick)\n\t}\n\treturn sequence\n}\n\nfunction buildPool(level) {\n\tvar pool = []\n\tfor (var i = 0; i < level.notes.length; i++) {\n\t\tfor (var j = 0; j < level.rhythms.length; j++) {\n\t\t\tvar label = level.notes[i] + ' ' + level.rhythms[j]\n\t\t\tvar block = getBlockByName(label)\n\t\t\tif (block) pool.push(block.id)\n\t\t}\n\t}\n\tif (level.allowRest) {\n\t\tfor (var k = 0; k < level.rhythms.length; k++) {\n\t\t\tvar restLabel = 'Silencio ' + level.rhythms[k]\n\t\t\tvar restBlock = getBlockByName(restLabel)\n\t\t\tif (restBlock) pool.push(restBlock.id)\n\t\t}\n\t}\n\treturn pool\n}\n\nfunction getBlockByName(name) {\n\tfor (var i = 0; i < blockCatalog.length; i++) {\n\t\tif (blockCatalog[i].name === name) return blockCatalog[i]\n\t}\n\treturn null\n}\n\nfunction playSequence() {\n\tif (!classroom.enabled || classroom.playing) return\n\tif (!audioReady) {\n\t\t// Try to unlock audio from a user gesture (e.g., clicking \"Empezar\").\n\t\tif (ensureAudio()) {\n\t\t\taudioReady = true\n\t\t\thideAudioHint()\n\t\t\tupdateStatus()\n\t\t} else {\n\t\tshowAudioHint()\n\t\tsetClassroomStatus('Activa el audio para empezar.')\n\t\treturn\n\t\t}\n\t}\n\tclassroom.playing = true\n\tclassroom.allowInput = false\n\tclassroom.inputIndex = 0\n\tclearClassroomTimers()\n\tupdateClassroomUI()\n\n\tvar delay = 400\n\tclassroom.sequence.forEach(function (blockId, index) {\n\t\tvar timer = setTimeout(function () {\n\t\t\thighlightSequenceIndex(index)\n\t\t\tplayMusicBlock(blockId)\n\t\t}, delay)\n\t\tclassroom.timeouts.push(timer)\n\t\tdelay += getBlockDuration(blockId) * 1000 + 200\n\t})\n\n\tvar endTimer = setTimeout(function () {\n\t\tclassroom.playing = false\n\t\tclassroom.allowInput = true\n\t\tclearSequenceHighlights()\n\t\tsetClassroomStatus('Tu turno: repite la secuencia.')\n\t\tupdateClassroomUI()\n\t}, delay)\n\tclassroom.timeouts.push(endTimer)\n}\n\nfunction getBlockDuration(blockId) {\n\tvar music = musicBlocks[blockId]\n\treturn music ? music.duration : 0.3\n}\n\nfunction recordClassroomInput(blockId) {\n\tif (!classroom.enabled || !classroom.allowInput) return\n\tif (!musicBlocks[blockId]) return\n\n\tvar expected = classroom.sequence[classroom.inputIndex]\n\tif (blockId === expected) {\n\t\tclassroom.inputIndex++\n\t\tclassroom.score += 5\n\t\tupdateClassroomUI()\n\t\tif (classroom.inputIndex >= classroom.sequence.length) {\n\t\t\tclassroom.score += 10\n\t\t\tsetClassroomStatus('Bien! Siguiente nivel...')\n\t\t\tadvanceLevel()\n\t\t}\n\t} else {\n\t\tsetClassroomStatus('Ups! Intenta de nuevo.')\n\t\tclassroom.inputIndex = 0\n\t\tupdateClassroomUI()\n\t}\n}\n\nfunction advanceLevel() {\n\tclassroom.allowInput = false\n\tif (classroom.levelIndex + 1 >= classroomLevels.length) {\n\t\tvar unlocked = unlockBlockByName('Valla')\n\t\tif (unlocked && !rewardPlaced) {\n\t\t\tplaceFenceRewardNearPlayer()\n\t\t\trewardPlaced = true\n\t\t}\n\t\tvar rewardText = unlocked ? ' Premio desbloqueado: Valla (inventario E).' : ''\n\t\tsetClassroomStatus('Reto completado. Puntuacion final: ' + classroom.score + '.' + rewardText)\n\t\tclassroom.enabled = false\n\t\treturn\n\t}\n\tclassroom.levelIndex += 1\n\tsetLevel(classroom.levelIndex)\n\tsetTimeout(function () {\n\t\tplaySequence()\n\t}, 600)\n}\n\nfunction updateClassroomUI() {\n\tif (!ui.classroomLevel) return\n\tvar levelLabel = classroom.levelIndex >= 0 ? classroomLevels[classroom.levelIndex].name : '--'\n\tui.classroomLevel.textContent = levelLabel\n\tui.classroomScore.textContent = String(classroom.score)\n\tui.classroomProgress.textContent = classroom.inputIndex + '/' + classroom.sequence.length\n\trenderSequence()\n}\n\nfunction placeFenceRewardNearPlayer() {\n\tvar pos = noa.entities.getPositionData(eid).position\n\tvar centerX = Math.floor(pos[0]) + 2\n\tvar centerZ = Math.floor(pos[2]) + 2\n\tvar topY = getHeight(centerX, centerZ)\n\tfor (var dx = -1; dx <= 1; dx++) {\n\t\tfor (var dz = -1; dz <= 1; dz++) {\n\t\t\tif (Math.abs(dx) === 1 || Math.abs(dz) === 1) {\n\t\t\t\tnoa.setBlock(fenceID, [centerX + dx, topY, centerZ + dz])\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction renderSequence() {\n\tif (!ui.classroomSeq) return\n\tui.classroomSeq.innerHTML = ''\n\tfor (var i = 0; i < classroom.sequence.length; i++) {\n\t\tvar blockId = classroom.sequence[i]\n\t\tvar chip = document.createElement('div')\n\t\tchip.className = 'seq-chip'\n\t\tchip.textContent = getMusicLabel(blockId) || '---'\n\t\tui.classroomSeq.appendChild(chip)\n\t}\n}\n\nfunction highlightSequenceIndex(index) {\n\tif (!ui.classroomSeq) return\n\tvar chips = ui.classroomSeq.querySelectorAll('.seq-chip')\n\tfor (var i = 0; i < chips.length; i++) {\n\t\tif (i === index) chips[i].classList.add('active')\n\t\telse chips[i].classList.remove('active')\n\t}\n}\n\nfunction clearSequenceHighlights() {\n\tif (!ui.classroomSeq) return\n\tvar chips = ui.classroomSeq.querySelectorAll('.seq-chip')\n\tfor (var i = 0; i < chips.length; i++) {\n\t\tchips[i].classList.remove('active')\n\t}\n}\n\nfunction clearClassroomTimers() {\n\twhile (classroom.timeouts.length) {\n\t\tclearTimeout(classroom.timeouts.pop())\n\t}\n}\n\nfunction setClassroomStatus(text) {\n\tif (ui.classroomStatus) ui.classroomStatus.textContent = text\n}\n\nfunction ensureAudio() {\n\tif (!audioState.ctx) {\n\t\tvar AudioContext = window.AudioContext || window.webkitAudioContext\n\t\tif (!AudioContext) return false\n\t\taudioState.ctx = new AudioContext()\n\t}\n\tif (audioState.ctx.state === 'suspended') {\n\t\ttry {\n\t\t\taudioState.ctx.resume()\n\t\t} catch (err) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunction playMusicBlock(blockId) {\n\tvar music = musicBlocks[blockId]\n\tif (!music) return\n\tif (!ensureAudio()) {\n\t\tshowAudioHint()\n\t\treturn\n\t}\n\tif (!audioReady) {\n\t\taudioReady = true\n\t\thideAudioHint()\n\t\tupdateStatus()\n\t}\n\n\trecordClassroomInput(blockId)\n\n\tif (!music.isRest && music.frequency) {\n\t\tvar osc = audioState.ctx.createOscillator()\n\t\tvar gain = audioState.ctx.createGain()\n\t\tvar now = audioState.ctx.currentTime\n\t\tvar endTime = now + music.duration\n\n\t\tosc.type = 'square'\n\t\tosc.frequency.setValueAtTime(music.frequency, now)\n\t\tgain.gain.setValueAtTime(0.001, now)\n\t\tgain.gain.exponentialRampToValueAtTime(0.2, now + 0.02)\n\t\tgain.gain.exponentialRampToValueAtTime(0.0001, endTime)\n\n\t\tosc.connect(gain)\n\t\tgain.connect(audioState.ctx.destination)\n\t\tosc.start(now)\n\t\tosc.stop(endTime)\n\t}\n\n\tshowMusicFeedback(music)\n}\n\nfunction showMusicFeedback(music) {\n\tif (musicFeedbackTimer) clearTimeout(musicFeedbackTimer)\n\tif (musicPulseTimer) clearTimeout(musicPulseTimer)\n\tui.musicFeedback.textContent = formatMusicLabel(music)\n\tui.musicFeedback.classList.add('active')\n\tui.musicPulse.classList.add('active')\n\tmusicFeedbackTimer = setTimeout(function () {\n\t\tui.musicFeedback.classList.remove('active')\n\t}, Math.max(150, music.duration * 1000))\n\tmusicPulseTimer = setTimeout(function () {\n\t\tui.musicPulse.classList.remove('active')\n\t}, Math.max(120, music.duration * 600))\n}\n\nfunction showAudioHint() {\n\tif (ui.audioHint) ui.audioHint.style.display = 'block'\n}\n\nfunction hideAudioHint() {\n\tif (ui.audioHint) ui.audioHint.style.display = 'none'\n}\n\nfunction updateHotbarSlot(index) {\n\tvar slot = hotbarEls[index]\n\twhile (slot.firstChild) slot.removeChild(slot.firstChild)\n\tslot.appendChild(makeIcon(hotbarSlots[index]))\n\tvar key = document.createElement('div')\n\tkey.className = 'key'\n\tkey.textContent = index + 1\n\tslot.appendChild(key)\n}\n\nfunction toggleInventory(force) {\n\tvar shouldOpen = (typeof force === 'boolean') ? force : !ui.inventory.classList.contains('open')\n\tui.inventory.classList.toggle('open', shouldOpen)\n\tinventoryOpen = shouldOpen\n\tupdatePause()\n\tif (inventoryOpen && document.exitPointerLock) document.exitPointerLock()\n}\n\n\n// each tick, consume any scroll events and use them to cycle hotbar\nvar scrollCooldown = 0\nvar statusCooldown = 0\nnoa.on('tick', function (dt) {\n\tscrollCooldown -= dt\n\tstatusCooldown -= dt\n\tlastStepTime -= dt\n\tif (multiplayer) multiplayer.tick(dt)\n\n\tif (statusCooldown <= 0) {\n\t\tstatusCooldown = 120\n\t\tvar pos = noa.entities.getPositionData(eid).position\n\t\tui.playerPos.textContent = 'Pos: ' +\n\t\t\tMath.floor(pos[0]) + ' ' +\n\t\t\tMath.floor(pos[1]) + ' ' +\n\t\t\tMath.floor(pos[2])\n\t}\n\n\tif (multiplayer) multiplayer.updateRemotes()\n\n\tvar scroll = noa.inputs.state.scrolly\n\tif (scroll && scrollCooldown <= 0) {\n\t\tscrollCooldown = 80\n\t\tselectSlot(selectedIndex + (scroll > 0 ? -1 : 1))\n\t}\n\n\tvar pos = noa.entities.getPositionData(eid).position\n\tvar underX = Math.floor(pos[0])\n\tvar underY = Math.floor(pos[1] - 0.1)\n\tvar underZ = Math.floor(pos[2])\n\tvar blockUnder = noa.getBlock(underX, underY, underZ)\n\tif (blockUnder && blockUnder !== lastStepBlockId && lastStepTime <= 0) {\n\t\tif (musicBlocks[blockUnder]) {\n\t\t\tplayMusicBlock(blockUnder)\n\t\t\tlastStepTime = 120\n\t\t}\n\t}\n\tlastStepBlockId = blockUnder\n\n\tif (creativeMode) {\n\t\tvar body = noa.playerBody\n\t\tvar flySpeed = noa.inputs.state.sprint ? 12 : 6\n\t\tvar up = noa.inputs.state.jump\n\t\tvar down = noa.inputs.state.crouch\n\t\tif (up && !down) body.velocity[1] = flySpeed\n\t\telse if (down && !up) body.velocity[1] = -flySpeed\n\t\telse body.velocity[1] = 0\n\t}\n})\n\n\n// pausing + inventory\nnoa.inputs.bind('pause', 'P')\nnoa.inputs.down.on('pause', function () {\n\tpaused = !paused\n\tupdatePause()\n})\n\nnoa.inputs.bind('inventory', 'E')\nnoa.inputs.bind('inventory', 'I')\nnoa.inputs.down.on('inventory', function () {\n\ttoggleInventory()\n})\n\nnoa.inputs.bind('toggle-creative', 'G')\nnoa.inputs.down.on('toggle-creative', function () {\n\tsetCreativeMode(!creativeMode)\n})\n\nnoa.inputs.bind('toggle-classroom', 'M')\nnoa.inputs.down.on('toggle-classroom', function () {\n\ttoggleClassroom()\n})\n\nfor (var i = 0; i < hotbarSlots.length; i++) {\n\tvar action = 'slot-' + (i + 1)\n\tnoa.inputs.bind(action, String(i + 1))\n\tbindSlotAction(action, i)\n}\n\nfunction bindSlotAction(action, index) {\n\tnoa.inputs.down.on(action, function () {\n\t\tselectSlot(index)\n\t})\n}\n\nvar paused = false\nvar inventoryOpen = false\n\nfunction updatePause() {\n\tnoa.setPaused(paused || inventoryOpen)\n}\n\nfunction setCreativeMode(enabled) {\n\tcreativeMode = enabled\n\tnoa.playerBody.gravityMultiplier = creativeMode ? 0 : 2\n\tupdateStatus()\n\tscheduleSaveSettings()\n}\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./registry.js":
/*!*********************!*\
  !*** ./registry.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function createRegistry(noa, scene) {\n\tvar musicBlocks = {}\n\tvar blockCatalog = []\n\n\tvar textureAssets = buildClassicTextures(scene)\n\n\tregisterClassicMaterial('grassTop', textureAssets.grassTop)\n\tregisterClassicMaterial('grassSide', textureAssets.grassSide)\n\tregisterClassicMaterial('dirt', textureAssets.dirt)\n\tregisterClassicMaterial('stone', textureAssets.stone)\n\tregisterClassicMaterial('brick', textureAssets.brick)\n\tregisterClassicMaterial('woodSide', textureAssets.woodSide)\n\tregisterClassicMaterial('woodTop', textureAssets.woodTop)\n\tregisterClassicMaterial('plank', textureAssets.plank)\n\tregisterClassicMaterial('sand', textureAssets.sand)\n\tregisterClassicMaterial('gravel', textureAssets.gravel)\n\tregisterClassicMaterial('leaves', textureAssets.leaves, { alpha: 0.85, hasAlpha: true })\n\tregisterClassicMaterial('glass', textureAssets.glass, { alpha: 0.35, hasAlpha: true })\n\tregisterClassicMaterial('water', textureAssets.water, { alpha: 0.65, hasAlpha: true })\n\n\tvar idCounter = 1\n\tvar grassID = noa.registry.registerBlock(idCounter++, { material: ['grassTop', 'dirt', 'grassSide'] })\n\tvar dirtID = noa.registry.registerBlock(idCounter++, { material: 'dirt' })\n\tvar stoneID = noa.registry.registerBlock(idCounter++, { material: 'stone' })\n\tvar brickID = noa.registry.registerBlock(idCounter++, { material: 'brick' })\n\tvar woodID = noa.registry.registerBlock(idCounter++, { material: ['woodTop', 'woodTop', 'woodSide'] })\n\tvar plankID = noa.registry.registerBlock(idCounter++, { material: 'plank' })\n\tvar sandID = noa.registry.registerBlock(idCounter++, { material: 'sand' })\n\tvar gravelID = noa.registry.registerBlock(idCounter++, { material: 'gravel' })\n\tvar leavesID = noa.registry.registerBlock(idCounter++, { material: 'leaves', opaque: false })\n\tvar glassID = noa.registry.registerBlock(idCounter++, { material: 'glass', opaque: false })\n\tvar waterID = noa.registry.registerBlock(idCounter++, { material: 'water', fluid: true, opaque: false })\n\tvar fenceID = noa.registry.registerBlock(idCounter++, { material: 'plank', opaque: false })\n\n\tblockCatalog = [\n\t\t{ name: 'Cesped', id: grassID, icon: { type: 'data', value: textureAssets.grassTop.dataUrl } },\n\t\t{ name: 'Tierra', id: dirtID, icon: { type: 'data', value: textureAssets.dirt.dataUrl } },\n\t\t{ name: 'Piedra', id: stoneID, icon: { type: 'data', value: textureAssets.stone.dataUrl } },\n\t\t{ name: 'Ladrillo', id: brickID, icon: { type: 'data', value: textureAssets.brick.dataUrl } },\n\t\t{ name: 'Madera', id: woodID, icon: { type: 'data', value: textureAssets.woodSide.dataUrl } },\n\t\t{ name: 'Tablon', id: plankID, icon: { type: 'data', value: textureAssets.plank.dataUrl } },\n\t\t{ name: 'Arena', id: sandID, icon: { type: 'data', value: textureAssets.sand.dataUrl } },\n\t\t{ name: 'Grava', id: gravelID, icon: { type: 'data', value: textureAssets.gravel.dataUrl } },\n\t\t{ name: 'Hojas', id: leavesID, icon: { type: 'data', value: textureAssets.leaves.dataUrl } },\n\t\t{ name: 'Cristal', id: glassID, icon: { type: 'data', value: textureAssets.glass.dataUrl } },\n\t\t{ name: 'Agua', id: waterID, icon: { type: 'data', value: textureAssets.water.dataUrl } },\n\t\t{ name: 'Valla', id: fenceID, icon: { type: 'data', value: textureAssets.plank.dataUrl }, locked: true },\n\t]\n\n\taddMusicBlocks()\n\n\treturn {\n\t\tblockCatalog: blockCatalog,\n\t\tmusicBlocks: musicBlocks,\n\t\tids: {\n\t\t\tgrassID: grassID,\n\t\t\tdirtID: dirtID,\n\t\t\tstoneID: stoneID,\n\t\t\tbrickID: brickID,\n\t\t\twoodID: woodID,\n\t\t\tplankID: plankID,\n\t\t\tsandID: sandID,\n\t\t\tgravelID: gravelID,\n\t\t\tleavesID: leavesID,\n\t\t\tglassID: glassID,\n\t\t\twaterID: waterID,\n\t\t\tfenceID: fenceID\n\t\t}\n\t}\n\n\tfunction registerClassicMaterial(name, asset, opts) {\n\t\topts = opts || {}\n\t\tvar mat = noa.rendering.flatMaterial.clone(name + '-mat')\n\t\tmat.diffuseTexture = asset.texture\n\t\tmat.specularColor = new BABYLON.Color3(0, 0, 0)\n\t\tif (opts.alpha) mat.alpha = opts.alpha\n\t\tif (opts.hasAlpha) mat.diffuseTexture.hasAlpha = true\n\t\tnoa.registry.registerMaterial(name, [1, 1, 1], null, !!opts.hasAlpha, mat)\n\t}\n\n\tfunction addMusicBlocks() {\n\t\tvar bpm = 120\n\t\tvar beat = 60 / bpm\n\n\t\tvar baseNotes = [\n\t\t\t{ name: 'Do', letter: 'C', freq: 261.63 },\n\t\t\t{ name: 'Re', letter: 'D', freq: 293.66 },\n\t\t\t{ name: 'Mi', letter: 'E', freq: 329.63 },\n\t\t\t{ name: 'Fa', letter: 'F', freq: 349.23 },\n\t\t\t{ name: 'Sol', letter: 'G', freq: 392.0 },\n\t\t\t{ name: 'La', letter: 'A', freq: 440.0 },\n\t\t\t{ name: 'Si', letter: 'B', freq: 493.88 },\n\t\t]\n\t\tvar palette = ['#ff6b6b', '#ffa94d', '#ffd43b', '#69db7c', '#4dabf7', '#9775fa', '#f783ac']\n\t\tvar notes = []\n\t\tvar octaves = [\n\t\t\t{ label: '4', mult: 1 },\n\t\t\t{ label: '5', mult: 2 },\n\t\t]\n\t\tfor (var o = 0; o < octaves.length; o++) {\n\t\t\tfor (var i = 0; i < baseNotes.length; i++) {\n\t\t\t\tvar base = baseNotes[i]\n\t\t\t\tnotes.push({\n\t\t\t\t\tname: base.name,\n\t\t\t\t\tletter: base.letter,\n\t\t\t\t\toctave: octaves[o].label,\n\t\t\t\t\tfreq: base.freq * octaves[o].mult,\n\t\t\t\t\tcolor: palette[i]\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tvar rhythms = [\n\t\t\t{ name: 'Blanca', beats: 2, shade: 0.25 },\n\t\t\t{ name: 'Negra', beats: 1, shade: 0 },\n\t\t\t{ name: 'Corchea', beats: 0.5, shade: -0.2 },\n\t\t]\n\n\t\tnotes.forEach(function (note) {\n\t\t\trhythms.forEach(function (rhythm) {\n\t\t\t\tvar label = note.name + note.octave + ' ' + rhythm.name\n\t\t\t\tvar color = shadeColor(note.color, rhythm.shade)\n\t\t\t\tvar id = registerMusicBlock(label, color, note.freq, rhythm.name, rhythm.beats, false, {\n\t\t\t\t\tname: note.name,\n\t\t\t\t\tletter: note.letter,\n\t\t\t\t\toctave: note.octave,\n\t\t\t\t})\n\t\t\t\tblockCatalog.push({\n\t\t\t\t\tname: label,\n\t\t\t\t\tid: id,\n\t\t\t\t\ticon: { type: 'color', value: color },\n\t\t\t\t\tmusic: {\n\t\t\t\t\t\tnote: note.name + note.octave,\n\t\t\t\t\t\trhythm: rhythm.name,\n\t\t\t\t\t\tisRest: false\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\trhythms.forEach(function (rhythm) {\n\t\t\tvar label = 'Silencio ' + rhythm.name\n\t\t\tvar color = shadeColor('#9aa5b1', rhythm.shade)\n\t\t\tvar id = registerMusicBlock(label, color, null, rhythm.name, rhythm.beats, true, null)\n\t\t\tblockCatalog.push({\n\t\t\t\tname: label,\n\t\t\t\tid: id,\n\t\t\t\ticon: { type: 'color', value: color },\n\t\t\t\tmusic: {\n\t\t\t\t\tnote: 'Rest',\n\t\t\t\t\trhythm: rhythm.name,\n\t\t\t\t\tisRest: true\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\tfunction registerMusicBlock(label, color, freq, rhythm, beats, isRest, noteData) {\n\t\tvar key = 'music-' + label.toLowerCase().replace(/\\s+/g, '-')\n\t\tnoa.registry.registerMaterial(key, hexToColor(color), null)\n\t\tvar id = noa.registry.registerBlock(idCounter++, { material: key, opaque: true })\n\t\tmusicBlocks[id] = {\n\t\t\tlabel: label,\n\t\t\tfrequency: freq,\n\t\t\trhythm: rhythm,\n\t\t\tduration: (60 / 120) * beats,\n\t\t\tisRest: isRest,\n\t\t\tnoteName: noteData ? noteData.name : null,\n\t\t\tnoteLetter: noteData ? noteData.letter : null,\n\t\t\tnoteOctave: noteData ? noteData.octave : null,\n\t\t}\n\t\treturn id\n\t}\n\n\tfunction buildClassicTextures(scene) {\n\t\tvar size = 16\n\t\treturn {\n\t\t\tgrassTop: makeTexture(scene, 'grass-top', size, function () {\n\t\t\t\treturn noisePixel('#5fa644', 18)\n\t\t\t}),\n\t\t\tdirt: makeTexture(scene, 'dirt', size, function () {\n\t\t\t\treturn noisePixel('#8b6b4c', 20)\n\t\t\t}),\n\t\t\tgrassSide: makeTexture(scene, 'grass-side', size, function (x, y) {\n\t\t\t\tif (y < 4) return noisePixel('#5fa644', 18)\n\t\t\t\treturn noisePixel('#8b6b4c', 20)\n\t\t\t}),\n\t\t\tstone: makeTexture(scene, 'stone', size, function () {\n\t\t\t\treturn noisePixel('#7f7f7f', 24)\n\t\t\t}),\n\t\t\tbrick: makeTexture(scene, 'brick', size, function (x, y) {\n\t\t\t\tvar mortar = (y % 4 === 0) || (x % 8 === 0 && y % 8 < 4)\n\t\t\t\tif (mortar) return [90, 35, 35, 255]\n\t\t\t\treturn noisePixel('#b04a3a', 16)\n\t\t\t}),\n\t\t\tplank: makeTexture(scene, 'plank', size, function (x, y) {\n\t\t\t\tvar line = (y % 4 === 0)\n\t\t\t\tif (line) return [120, 86, 50, 255]\n\t\t\t\treturn noisePixel('#c49b6a', 10)\n\t\t\t}),\n\t\t\twoodSide: makeTexture(scene, 'wood-side', size, function (x, y) {\n\t\t\t\tvar stripe = (x % 4 === 0)\n\t\t\t\tif (stripe) return [90, 60, 35, 255]\n\t\t\t\treturn noisePixel('#9b6b43', 14)\n\t\t\t}),\n\t\t\twoodTop: makeTexture(scene, 'wood-top', size, function (x, y) {\n\t\t\t\tvar dx = x - 8\n\t\t\t\tvar dy = y - 8\n\t\t\t\tvar dist = Math.sqrt(dx * dx + dy * dy)\n\t\t\t\tvar ring = (Math.floor(dist) % 3 === 0)\n\t\t\t\tif (ring) return [90, 60, 35, 255]\n\t\t\t\treturn noisePixel('#c49b6a', 8)\n\t\t\t}),\n\t\t\tsand: makeTexture(scene, 'sand', size, function () {\n\t\t\t\treturn noisePixel('#d9c57a', 12)\n\t\t\t}),\n\t\t\tgravel: makeTexture(scene, 'gravel', size, function () {\n\t\t\t\treturn noisePixel('#8b8b8b', 28)\n\t\t\t}),\n\t\t\tleaves: makeTexture(scene, 'leaves', size, function (x, y) {\n\t\t\t\tvar alpha = (Math.random() > 0.25) ? 200 : 0\n\t\t\t\tvar col = noisePixel('#3f8f3b', 18)\n\t\t\t\tcol[3] = alpha\n\t\t\t\treturn col\n\t\t\t}, true),\n\t\t\tglass: makeTexture(scene, 'glass', size, function (x, y) {\n\t\t\t\tvar border = (x === 0 || y === 0 || x === 15 || y === 15)\n\t\t\t\tif (border) return [210, 230, 255, 160]\n\t\t\t\tif (x === y || x === 15 - y) return [210, 230, 255, 90]\n\t\t\t\treturn [200, 230, 255, 20]\n\t\t\t}, true),\n\t\t\twater: makeTexture(scene, 'water', size, function () {\n\t\t\t\treturn noisePixel('#3b7dc4', 20, 170)\n\t\t\t}, true),\n\t\t}\n\t}\n\n\tfunction makeTexture(scene, name, size, pixelFn, hasAlpha) {\n\t\tvar canvas = document.createElement('canvas')\n\t\tcanvas.width = size\n\t\tcanvas.height = size\n\t\tvar ctx = canvas.getContext('2d')\n\t\tvar img = ctx.createImageData(size, size)\n\t\tfor (var y = 0; y < size; y++) {\n\t\t\tfor (var x = 0; x < size; x++) {\n\t\t\t\tvar idx = (y * size + x) * 4\n\t\t\t\tvar rgba = pixelFn(x, y)\n\t\t\t\timg.data[idx] = rgba[0]\n\t\t\t\timg.data[idx + 1] = rgba[1]\n\t\t\t\timg.data[idx + 2] = rgba[2]\n\t\t\t\timg.data[idx + 3] = (typeof rgba[3] === 'number') ? rgba[3] : 255\n\t\t\t}\n\t\t}\n\t\tctx.putImageData(img, 0, 0)\n\n\t\tvar texture = new BABYLON.DynamicTexture(name, { width: size, height: size }, scene, false)\n\t\tvar tctx = texture.getContext()\n\t\ttctx.drawImage(canvas, 0, 0)\n\t\ttexture.update()\n\t\ttexture.hasAlpha = !!hasAlpha\n\t\ttexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE\n\t\ttexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE\n\t\ttexture.updateSamplingMode(BABYLON.Texture.NEAREST_SAMPLINGMODE)\n\n\t\treturn {\n\t\t\ttexture: texture,\n\t\t\tdataUrl: canvas.toDataURL('image/png'),\n\t\t}\n\t}\n\n\tfunction noisePixel(hex, variance, alpha) {\n\t\tvar rgb = hexToRgb(hex)\n\t\tvar spread = variance || 0\n\t\treturn [\n\t\t\tclamp(rgb.r + rand(spread)),\n\t\t\tclamp(rgb.g + rand(spread)),\n\t\t\tclamp(rgb.b + rand(spread)),\n\t\t\t(typeof alpha === 'number') ? alpha : 255\n\t\t]\n\t}\n\n\tfunction rand(spread) {\n\t\treturn Math.floor((Math.random() * 2 - 1) * spread)\n\t}\n\n\tfunction hexToRgb(hex) {\n\t\tvar normalized = hex.replace('#', '')\n\t\treturn {\n\t\t\tr: parseInt(normalized.slice(0, 2), 16),\n\t\t\tg: parseInt(normalized.slice(2, 4), 16),\n\t\t\tb: parseInt(normalized.slice(4, 6), 16),\n\t\t}\n\t}\n\n\tfunction hexToColor(hex) {\n\t\tvar normalized = hex.replace('#', '')\n\t\tvar r = parseInt(normalized.slice(0, 2), 16) / 255\n\t\tvar g = parseInt(normalized.slice(2, 4), 16) / 255\n\t\tvar b = parseInt(normalized.slice(4, 6), 16) / 255\n\t\treturn [r, g, b]\n\t}\n\n\tfunction shadeColor(hex, amount) {\n\t\tvar normalized = hex.replace('#', '')\n\t\tvar r = parseInt(normalized.slice(0, 2), 16)\n\t\tvar g = parseInt(normalized.slice(2, 4), 16)\n\t\tvar b = parseInt(normalized.slice(4, 6), 16)\n\t\tvar amt = Math.round(255 * amount)\n\t\treturn '#' + toHex(clamp(r + amt)) + toHex(clamp(g + amt)) + toHex(clamp(b + amt))\n\t}\n\n\tfunction toHex(value) {\n\t\tvar hex = value.toString(16)\n\t\treturn hex.length === 1 ? '0' + hex : hex\n\t}\n\n\tfunction clamp(value) {\n\t\treturn Math.max(0, Math.min(255, value))\n\t}\n}\n\n\n//# sourceURL=webpack:///./registry.js?");

/***/ }),

/***/ "./storage.js":
/*!********************!*\
  !*** ./storage.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Dexie = __webpack_require__(/*! dexie/dist/dexie */ \"../../node_modules/dexie/dist/dexie.mjs\")\n\nvar db = new Dexie('educraft-storage')\ndb.version(1).stores({\n\tmain: 'name, data',\n\tworld: 'name, lastplay',\n\tworlddata: 'name, data'\n})\n\nfunction getSettings() {\n\treturn db.main.where('name').equals('settings').first().then(function (row) {\n\t\treturn row ? row.data : {}\n\t})\n}\n\nfunction saveSettings(data) {\n\treturn db.main.put({ name: 'settings', data: data })\n}\n\nfunction getWorldEdits(name) {\n\treturn db.worlddata.where('name').equals(name).first().then(function (row) {\n\t\treturn row ? row.data : {}\n\t})\n}\n\nfunction saveWorldEdits(name, edits) {\n\treturn Promise.all([\n\t\tdb.world.put({ name: name, lastplay: Date.now() }),\n\t\tdb.worlddata.put({ name: name, data: edits })\n\t]).then(function () { return true })\n}\n\nmodule.exports = {\n\tgetSettings: getSettings,\n\tsaveSettings: saveSettings,\n\tgetWorldEdits: getWorldEdits,\n\tsaveWorldEdits: saveWorldEdits\n}\n\n\n//# sourceURL=webpack:///./storage.js?");

/***/ })

/******/ });